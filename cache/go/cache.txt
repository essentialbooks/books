2385 1553594963206 glotoutput
Sha1: dccdc6ad6352880c659a5498f9109cb7380c24eb
Lang: Go
FileName: main.go
CodeFull:+1138
// :glot
package main

import (
	"bytes"
	"fmt"
	"io"
)

// :show start
// declaration of a single top-level variable
var topLevel int64 = 5

// grouping of multiple top-level declarations
var (
	intVal int            // value is initialized with zero-value
	str    string = "str" // assigning

	// functions are first-class values so can be assigned to variables
	// fn is variable of type func(a int) string
	// it's uninitialized so is nil (zero-value for function variables)
	fn func(a int) string
)

func f() {
	// shorthand using local type inference
	// type of `i` is int and is inferred from the value
	// note: this is not allowed at top-level
	i := 4

	// grouping inside a function
	var (
		i2 int
		s  string
	)

	// _ is like a variable whose value is discarded. It's called blank identifier.
	// Useful when we don't care about one of the values returned by a function
	_, err := io.Copy(dst, src) // don't care how many bytes were written
	// ...

	fmt.Printf("i: %d, i2: %d, s: %s, err: %v\n", i, i2, s, err)
}

// :show end

var (
	dst io.Writer = &bytes.Buffer{}
	src io.Reader = &bytes.Buffer{}
)

func main() {
	f()
}
CodeToRun:+1100
package main

import (
	"bytes"
	"fmt"
	"io"
)

// declaration of a single top-level variable
var topLevel int64 = 5

// grouping of multiple top-level declarations
var (
	intVal int            // value is initialized with zero-value
	str    string = "str" // assigning

	// functions are first-class values so can be assigned to variables
	// fn is variable of type func(a int) string
	// it's uninitialized so is nil (zero-value for function variables)
	fn func(a int) string
)

func f() {
	// shorthand using local type inference
	// type of `i` is int and is inferred from the value
	// note: this is not allowed at top-level
	i := 4

	// grouping inside a function
	var (
		i2 int
		s  string
	)

	// _ is like a variable whose value is discarded. It's called blank identifier.
	// Useful when we don't care about one of the values returned by a function
	_, err := io.Copy(dst, src) // don't care how many bytes were written
	// ...

	fmt.Printf("i: %d, i2: %d, s: %s, err: %v\n", i, i2, s, err)
}

var (
	dst io.Writer = &bytes.Buffer{}
	src io.Reader = &bytes.Buffer{}
)

func main() {
	f()
}
Output:+29
i: 4, i2: 0, s: , err: <nil>
66 1553594964048 glotid
Sha1: dccdc6ad6352880c659a5498f9109cb7380c24eb
GlotID: fapbo8wmdy
716 1553594965208 glotoutput
Sha1: 1de57d5bf41a1266d052e985e79814f4b73919e9
Lang: Go
FileName: main.go
CodeFull:+325
// :glot, no output
package main

// :show start
// Greeting is an exported (public) string constant
const Greeting string = "Hello World"

// we can group const declarations
const (
	// years is an unexported (package private) int constant
	years int  = 10
	truth bool = true
)

// :show end

func main() {
	// do  nothing
}
CodeToRun:+276
package main

// Greeting is an exported (public) string constant
const Greeting string = "Hello World"

// we can group const declarations
const (
	// years is an unexported (package private) int constant
	years int  = 10
	truth bool = true
)

func main() {
	// do  nothing
}
Output:+0
66 1553594965395 glotid
Sha1: 1de57d5bf41a1266d052e985e79814f4b73919e9
GlotID: fapbo9pg2w
1251 1553594966687 glotoutput
Sha1: 3e6ac778427fe13fd6c9d7a7f5d30405f6d33702
Lang: Go
FileName: main.go
CodeFull:+544
// :glot
package main

import (
	"fmt"
	"math"
)

const s string = "constant"

func main() {
	fmt.Println(s) // constant

	// A `const` statement can appear anywhere a `var` statement can.
	const n = 10
	fmt.Println(n)                           // 10
	fmt.Printf("n=%d is of type %T\n", n, n) // n=10 is of type int

	const m float64 = 4.3
	fmt.Println(m) // 4.3

	// An untyped constant takes the type needed by its context.
	// For example, here `math.Sin` expects a `float64`.
	const x = 10
	fmt.Println(math.Sin(x)) // -0.5440211108893699
}
CodeToRun:+535
package main

import (
	"fmt"
	"math"
)

const s string = "constant"

func main() {
	fmt.Println(s) // constant

	// A `const` statement can appear anywhere a `var` statement can.
	const n = 10
	fmt.Println(n)                           // 10
	fmt.Printf("n=%d is of type %T\n", n, n) // n=10 is of type int

	const m float64 = 4.3
	fmt.Println(m) // 4.3

	// An untyped constant takes the type needed by its context.
	// For example, here `math.Sin` expects a `float64`.
	const x = 10
	fmt.Println(math.Sin(x)) // -0.5440211108893699
}
Output:+56
constant
10
n=10 is of type int
4.3
-0.5440211108893699
66 1553594966870 glotid
Sha1: 3e6ac778427fe13fd6c9d7a7f5d30405f6d33702
GlotID: fapboal1q2
1676 1553594968019 glotoutput
Sha1: 6bd3d1fb0b4bf577aeb0992e557c2e87467fd7f4
Lang: Go
FileName: main.go
CodeFull:+685
// :glot
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters"
	s2 := `raw string literal
	which doesn't recgonize escape characters like \n
	`

	// you can add strings with +
	fmt.Printf("sum of string: %s\n", s+s1+s2)

	// you can compare strings with ==
	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	fmt.Printf("substring of s1: %s\n", s1[3:5])
	fmt.Printf("byte (character) at position 3 in s1: %d\n", s1[3])

	// C-style string formatting
	s = fmt.Sprintf("%d + %f = %s", 1, float64(3), "4")
	fmt.Printf("s: %s\n", s)
	// :show end
}
CodeToRun:+646
package main

import "fmt"

func main() {
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters"
	s2 := `raw string literal
	which doesn't recgonize escape characters like \n
	`

	// you can add strings with +
	fmt.Printf("sum of string: %s\n", s+s1+s2)

	// you can compare strings with ==
	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	fmt.Printf("substring of s1: %s\n", s1[3:5])
	fmt.Printf("byte (character) at position 3 in s1: %d\n", s1[3])

	// C-style string formatting
	s = fmt.Sprintf("%d + %f = %s", 1, float64(3), "4")
	fmt.Printf("s: %s\n", s)
}
Output:+228
sum of string: string
literal
with	escape charactersraw string literal
	which doesn't recgonize escape characters like \n
	
s1 is not equal to s2
substring of s1: in
byte (character) at position 3 in s1: 105
s: 1 + 3.000000 = 4
66 1553594968197 glotid
Sha1: 6bd3d1fb0b4bf577aeb0992e557c2e87467fd7f4
GlotID: fapbobdjp5
835 1553594969488 glotoutput
Sha1: e56c30b1c1fc3d54fcd267d9b33d7e628b07271d
Lang: Go
FileName: main.go
CodeFull:+347
// :glot
package main

import "fmt"

func main() {
	// :show start
	v := 5

	// pv is a pointer to v
	pv := &v
	fmt.Printf("v: %d, pv: %p\n", v, pv)

	// we change the value of v via pv
	*pv = 4
	fmt.Printf("v: %d\n", v)

	// two pointers to the same value have the same address
	pv2 := &v
	fmt.Printf("pv: %p, pv2: %p\n", pv, pv2)
	// :show end
}
CodeToRun:+308
package main

import "fmt"

func main() {
	v := 5

	// pv is a pointer to v
	pv := &v
	fmt.Printf("v: %d, pv: %p\n", v, pv)

	// we change the value of v via pv
	*pv = 4
	fmt.Printf("v: %d\n", v)

	// two pointers to the same value have the same address
	pv2 := &v
	fmt.Printf("pv: %p, pv2: %p\n", pv, pv2)
}
Output:+64
v: 5, pv: 0xc420016028
v: 4
pv: 0xc420016028, pv2: 0xc420016028
66 1553594969665 glotid
Sha1: e56c30b1c1fc3d54fcd267d9b33d7e628b07271d
GlotID: fapboc91ua
1001 1553594971113 glotoutput
Sha1: 0dd384865767d3b99acdf1c8d940988997706815
Lang: Go
FileName: main.go
CodeFull:+438
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := [2]int{4, 5} // array of 2 ints

	// access element of array
	fmt.Printf("a[1]: %d\n", a[1])

	// set element of array
	a[1] = 3

	// get size of array
	fmt.Printf("size of array  a: %d\n", len(a))

	// when using [...] size will be deduced from { ... }
	a2 := [...]int{4, 8, -1} // array of 3 integers
	fmt.Printf("size of array a2: %d\n", len(a2))
	// :show end
}
CodeToRun:+399
package main

import "fmt"

func main() {
	a := [2]int{4, 5} // array of 2 ints

	// access element of array
	fmt.Printf("a[1]: %d\n", a[1])

	// set element of array
	a[1] = 3

	// get size of array
	fmt.Printf("size of array  a: %d\n", len(a))

	// when using [...] size will be deduced from { ... }
	a2 := [...]int{4, 8, -1} // array of 3 integers
	fmt.Printf("size of array a2: %d\n", len(a2))
}
Output:+48
a[1]: 5
size of array  a: 2
size of array a2: 3
66 1553594971289 glotid
Sha1: 0dd384865767d3b99acdf1c8d940988997706815
GlotID: fapbod7up2
807 1553594972319 glotoutput
Sha1: ae767301ddee3aea794a8cc51abd5dbbedc5e44b
Lang: Go
FileName: main.go
CodeFull:+342
// :glot
package main

import "fmt"

func main() {
	// :show start
	slice := make([]int, 0, 5)
	// append element to end of slice
	slice = append(slice, 5)
	// append multiple elements to end
	slice = append(slice, 3, 4)
	fmt.Printf("length of slice is: %d\n", len(slice))
	fmt.Printf("capacity of slice is: %d\n", cap(slice))
	// :show end
}
CodeToRun:+303
package main

import "fmt"

func main() {
	slice := make([]int, 0, 5)
	// append element to end of slice
	slice = append(slice, 5)
	// append multiple elements to end
	slice = append(slice, 3, 4)
	fmt.Printf("length of slice is: %d\n", len(slice))
	fmt.Printf("capacity of slice is: %d\n", cap(slice))
}
Output:+46
length of slice is: 3
capacity of slice is: 5
66 1553594972498 glotid
Sha1: ae767301ddee3aea794a8cc51abd5dbbedc5e44b
GlotID: fapbodxr68
2239 1553594973857 glotoutput
Sha1: 3037a202bf1b79c2edb456550701c91595aa2a15
Lang: Go
FileName: main.go
CodeFull:+985
// :glot
package main

import "fmt"

func main() {
	// :show start
	m := make(map[string]int)

	// set the value
	m["three"] = 3
	m["four"] = 4

	// get the value and see if the value exists
	key := "four"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	key = "five"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	// if value doesn't exist, the result of lookup is zero value. In this case zero value of int is 0
	fmt.Printf("\nValue for non-existing key: %d\n\n", m["not-exists"])

	// iterating over keys and values
	fmt.Printf("All keys and their values:\n")
	for key, value := range m {
		fmt.Printf("%s => %d\n", key, value)
	}

	fmt.Printf("\nBefore deletion: len(m)=%d\n", len(m))
	delete(m, "four")
	fmt.Printf("After deletion : len(m)=%d\n", len(m))
	// :show end
}
CodeToRun:+946
package main

import "fmt"

func main() {
	m := make(map[string]int)

	// set the value
	m["three"] = 3
	m["four"] = 4

	// get the value and see if the value exists
	key := "four"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	key = "five"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	// if value doesn't exist, the result of lookup is zero value. In this case zero value of int is 0
	fmt.Printf("\nValue for non-existing key: %d\n\n", m["not-exists"])

	// iterating over keys and values
	fmt.Printf("All keys and their values:\n")
	for key, value := range m {
		fmt.Printf("%s => %d\n", key, value)
	}

	fmt.Printf("\nBefore deletion: len(m)=%d\n", len(m))
	delete(m, "four")
	fmt.Printf("After deletion : len(m)=%d\n", len(m))
}
Output:+191
Key 'four' exists and maps to 4
Key 'five' doesn't exists

Value for non-existing key: 0

All keys and their values:
three => 3
four => 4

Before deletion: len(m)=2
After deletion : len(m)=1
66 1553594974076 glotid
Sha1: 3037a202bf1b79c2edb456550701c91595aa2a15
GlotID: fapboevj61
1210 1553594977850 glotoutput
Sha1: 37c9014ba3b2bb12503199dc89c3b6896d9c5d3a
Lang: Go
FileName: main.go
CodeFull:+543
// :glot
package main

import (
	"fmt"
)

// :show start
// Person describes a person
type Person struct {
	FirstName string
	LastName  string
}

// FullName returns full name of a person
func (p *Person) FullName() string {
	return fmt.Sprintf("%s %s", p.FirstName, p.LastName)
}

func main() {
	// zero value of struct
	var p Person
	fmt.Printf("p: %v\n\n", p)

	p = Person{
		FirstName: "John",
		LastName:  "Doe",
	}
	fmt.Printf("p: %v\n\n", p)

	// call a method on a struct
	fmt.Printf("p.FullName(): %s\n", p.FullName())
}

// :show end
CodeToRun:+506
package main

import (
	"fmt"
)

// Person describes a person
type Person struct {
	FirstName string
	LastName  string
}

// FullName returns full name of a person
func (p *Person) FullName() string {
	return fmt.Sprintf("%s %s", p.FirstName, p.LastName)
}

func main() {
	// zero value of struct
	var p Person
	fmt.Printf("p: %v\n\n", p)

	p = Person{
		FirstName: "John",
		LastName:  "Doe",
	}
	fmt.Printf("p: %v\n\n", p)

	// call a method on a struct
	fmt.Printf("p.FullName(): %s\n", p.FullName())
}
Output:+46
p: { }

p: {John Doe}

p.FullName(): John Doe
66 1553594978026 glotid
Sha1: 37c9014ba3b2bb12503199dc89c3b6896d9c5d3a
GlotID: fapboh89e0
1679 1553594980102 glotoutput
Sha1: 4a2b493e7ae12a1d29b90aaff9b4199a3c076631
Lang: Go
FileName: main.go
CodeFull:+785
// :glot
package main

import (
	"fmt"
	"strconv"
)

// :show start
// Stringer is an interface with a single method
type Stringer interface {
	String() string
}

// User struct that implements Stringer interface
type User struct {
	Name string
}

func (u *User) String() string {
	return u.Name
}

// Any type can implement an interface. Here we create
// an alias of int type an implement Stringer interface

type MyInt int

func (mi MyInt) String() string {
	return strconv.Itoa(int(mi))
}

// printTypeAndString accepts an interface. 's' can be any value
// that implements Stringer interface
func printTypeAndString(s Stringer) {
	fmt.Printf("%T: %s\n", s, s)
}

func main() {
	u := &User{Name: "John"}
	printTypeAndString(u)

	n := MyInt(5)
	printTypeAndString(n)
}

// :show end
CodeToRun:+748
package main

import (
	"fmt"
	"strconv"
)

// Stringer is an interface with a single method
type Stringer interface {
	String() string
}

// User struct that implements Stringer interface
type User struct {
	Name string
}

func (u *User) String() string {
	return u.Name
}

// Any type can implement an interface. Here we create
// an alias of int type an implement Stringer interface

type MyInt int

func (mi MyInt) String() string {
	return strconv.Itoa(int(mi))
}

// printTypeAndString accepts an interface. 's' can be any value
// that implements Stringer interface
func printTypeAndString(s Stringer) {
	fmt.Printf("%T: %s\n", s, s)
}

func main() {
	u := &User{Name: "John"}
	printTypeAndString(u)

	n := MyInt(5)
	printTypeAndString(n)
}
Output:+31
*main.User: John
main.MyInt: 5
66 1553594980279 glotid
Sha1: 4a2b493e7ae12a1d29b90aaff9b4199a3c076631
GlotID: fapboikj7m
1014 1553594982049 glotoutput
Sha1: 1626c9aae89e13e23ae9e3f43aafe887503eaef0
Lang: Go
FileName: main.go
CodeFull:+437
// :glot
package main

import (
	"fmt"
)

// :show start
func printVariableType(v interface{}) {
	switch v.(type) {
	case string:
		fmt.Printf("v is of type 'string'\n")
	case int:
		fmt.Printf("v is of type 'int'\n")
	default:
		// generic fallback
		fmt.Printf("v is of type '%T'\n", v)
	}
}

func main() {
	printVariableType("string") // string
	printVariableType(5)        // int
	printVariableType(int32(5)) // int32
}

// :show end
CodeToRun:+400
package main

import (
	"fmt"
)

func printVariableType(v interface{}) {
	switch v.(type) {
	case string:
		fmt.Printf("v is of type 'string'\n")
	case int:
		fmt.Printf("v is of type 'int'\n")
	default:
		// generic fallback
		fmt.Printf("v is of type '%T'\n", v)
	}
}

func main() {
	printVariableType("string") // string
	printVariableType(5)        // int
	printVariableType(int32(5)) // int32
}
Output:+62
v is of type 'string'
v is of type 'int'
v is of type 'int32'
66 1553594982275 glotid
Sha1: 1626c9aae89e13e23ae9e3f43aafe887503eaef0
GlotID: fapbojr9zz
1917 1553594983381 glotoutput
Sha1: 1fbd5b428167eb0c1a18a729b87f8c5c9d363b11
Lang: Go
FileName: main.go
CodeFull:+752
// :glot, allow error
package main

import (
	"fmt"
)

// :show start
func printTypeAndValue(iv interface{}) {
	if v, ok := iv.(string); ok {
		fmt.Printf("iv is of type string and has value '%s'\n", v)
		return
	}
	if v, ok := iv.(int); ok {
		fmt.Printf("iv is of type int and has value '%d'\n", v)
		return
	}
	if v, ok := iv.(*int); ok {
		fmt.Printf("iv is of type *int and has value '%s'\n", v)
		return
	}
}

func panicOnInvalidConversion() {
	var iv interface{} = "string"

	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	// pass a string
	printTypeAndValue("string")
	i := 5
	// pass an int
	printTypeAndValue(i)
	// pass a pointer to int i.e. *int
	printTypeAndValue(&i)

	panicOnInvalidConversion()
}

// :show end
CodeToRun:+702
package main

import (
	"fmt"
)

func printTypeAndValue(iv interface{}) {
	if v, ok := iv.(string); ok {
		fmt.Printf("iv is of type string and has value '%s'\n", v)
		return
	}
	if v, ok := iv.(int); ok {
		fmt.Printf("iv is of type int and has value '%d'\n", v)
		return
	}
	if v, ok := iv.(*int); ok {
		fmt.Printf("iv is of type *int and has value '%s'\n", v)
		return
	}
}

func panicOnInvalidConversion() {
	var iv interface{} = "string"

	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	// pass a string
	printTypeAndValue("string")
	i := 5
	// pass an int
	printTypeAndValue(i)
	// pass a pointer to int i.e. *int
	printTypeAndValue(&i)

	panicOnInvalidConversion()
}
Output:+347
iv is of type string and has value 'string'
iv is of type int and has value '5'
iv is of type *int and has value '%!s(*int=0xc420016028)'
panic: interface conversion: interface {} is string, not int

goroutine 1 [running]:
main.panicOnInvalidConversion()
	/tmp/375769756/main.go:25 +0x45
main.main()
	/tmp/375769756/main.go:38 +0xb8
exit status 2
66 1553594984562 glotid
Sha1: 1fbd5b428167eb0c1a18a729b87f8c5c9d363b11
GlotID: fapbokiv5t
778 1553594986145 glotoutput
Sha1: 9e7f8cc2026a463c2c8fae34822dc4f8a0825d5b
Lang: Go
FileName: main.go
CodeFull:+243
// :glot, allow error
package main

import (
	"fmt"
)

// :show start
func panicOnInvalidConversion(iv interface{}) {
	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	panicOnInvalidConversion("string")
}

// :show end
CodeToRun:+193
package main

import (
	"fmt"
)

func panicOnInvalidConversion(iv interface{}) {
	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	panicOnInvalidConversion("string")
}
Output:+226
panic: interface conversion: interface {} is string, not int

goroutine 1 [running]:
main.panicOnInvalidConversion(0x493920, 0x4c4410)
	/tmp/013892416/main.go:8 +0xc7
main.main()
	/tmp/013892416/main.go:13 +0x39
exit status 2
66 1553594986323 glotid
Sha1: 9e7f8cc2026a463c2c8fae34822dc4f8a0825d5b
GlotID: fapbom61v4
1724 1553594987600 glotoutput
Sha1: 4c64010a7031bba8d9e3260ac6ddc1af7f697a52
Lang: Go
FileName: main.go
CodeFull:+757
// :glot
package main

import (
	"fmt"
	"strconv"
)

// :show start
func smartConvertToInt(iv interface{}) (int, error) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		return v, nil
	case string:
		return strconv.Atoi(v)
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("unsupported type: %T", iv)
	}
}

func printSmartConvertToInt(iv interface{}) {
	i, err := smartConvertToInt(iv)
	if err != nil {
		fmt.Printf("Failed to convert %#v to int\n", iv)
		return
	}
	fmt.Printf("%#v of type %T converted to %d\n", iv, iv, i)
}

func main() {
	printSmartConvertToInt("5")
	printSmartConvertToInt(4)
	printSmartConvertToInt(int32(8))
	printSmartConvertToInt("not valid int")
}

// :show end
CodeToRun:+720
package main

import (
	"fmt"
	"strconv"
)

func smartConvertToInt(iv interface{}) (int, error) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		return v, nil
	case string:
		return strconv.Atoi(v)
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("unsupported type: %T", iv)
	}
}

func printSmartConvertToInt(iv interface{}) {
	i, err := smartConvertToInt(iv)
	if err != nil {
		fmt.Printf("Failed to convert %#v to int\n", iv)
		return
	}
	fmt.Printf("%#v of type %T converted to %d\n", iv, iv, i)
}

func main() {
	printSmartConvertToInt("5")
	printSmartConvertToInt(4)
	printSmartConvertToInt(int32(8))
	printSmartConvertToInt("not valid int")
}
Output:+131
"5" of type string converted to 5
4 of type int converted to 4
Failed to convert 8 to int
Failed to convert "not valid int" to int
66 1553594987779 glotid
Sha1: 4c64010a7031bba8d9e3260ac6ddc1af7f697a52
GlotID: fapbon199g
485 1553594989463 glotoutput
Sha1: 5fd4f16af6a785d6422a2712e1933f6de95e751c
Lang: Go
FileName: main.go
CodeFull:+194
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := 5
	b := 6
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}
}

// :show end
CodeToRun:+156
package main

import "fmt"

func main() {
	a := 5
	b := 6
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}
}
Output:+20
a is not equal to b
66 1553594989641 glotid
Sha1: 5fd4f16af6a785d6422a2712e1933f6de95e751c
GlotID: fapboo56jy
687 1553594992597 glotoutput
Sha1: d597dd57fbf2925c3e36dbccc420a77041a73a2a
Lang: Go
FileName: main.go
CodeFull:+287
// :glot
package main

import "fmt"

func main() {
	// :show start
	stmt := "if"
	switch stmt {
	case "if", "for":
		fmt.Printf("stmt ('%s') is either 'if' or 'for'\n", stmt)
	case "else":
		fmt.Printf("stmt is 'else'\n")
	default:
		fmt.Printf("stmt is '%s'\n", stmt)
	}
	// :show end
}
CodeToRun:+248
package main

import "fmt"

func main() {
	stmt := "if"
	switch stmt {
	case "if", "for":
		fmt.Printf("stmt ('%s') is either 'if' or 'for'\n", stmt)
	case "else":
		fmt.Printf("stmt is 'else'\n")
	default:
		fmt.Printf("stmt is '%s'\n", stmt)
	}
}
Output:+36
stmt ('if') is either 'if' or 'for'
66 1553594992773 glotid
Sha1: d597dd57fbf2925c3e36dbccc420a77041a73a2a
GlotID: fapboq0bf9
374 1553594994542 glotoutput
Sha1: 950fe1a8d427999410302dc159c3a0e4a62d5a8a
Lang: Go
FileName: main.go
CodeFull:+141
// :glot
package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}
CodeToRun:+102
package main

import "fmt"

func main() {
	for i := 0; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
}
Output:+15
i: 0
i: 2
i: 4
66 1553594994719 glotid
Sha1: 950fe1a8d427999410302dc159c3a0e4a62d5a8a
GlotID: fapbor61p1
378 1553594995944 glotoutput
Sha1: 68b25b5196aa5676307346c888654c2ed240bfdb
Lang: Go
FileName: main.go
CodeFull:+143
// :glot
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for ; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}
CodeToRun:+104
package main

import "fmt"

func main() {
	i := 0
	for ; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
}
Output:+15
i: 0
i: 2
i: 4
66 1553594996122 glotid
Sha1: 68b25b5196aa5676307346c888654c2ed240bfdb
GlotID: fapbos017b
427 1553594998228 glotoutput
Sha1: 88f82cfc8d541d3c50aef15c2a74e96135e417b9
Lang: Go
FileName: main.go
CodeFull:+165
// :glot
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for ; ; i += 2 {
		fmt.Printf("i: %d\n", i)
		if i >= 5 {
			break
		}
	}
	// :show end
}
CodeToRun:+126
package main

import "fmt"

func main() {
	i := 0
	for ; ; i += 2 {
		fmt.Printf("i: %d\n", i)
		if i >= 5 {
			break
		}
	}
}
Output:+20
i: 0
i: 2
i: 4
i: 6
66 1553594998535 glotid
Sha1: 88f82cfc8d541d3c50aef15c2a74e96135e417b9
GlotID: fapbotd6sq
378 1553595000378 glotoutput
Sha1: 5e4a0bcf8baa33bd838b7313dd8ad9b221e10ac2
Lang: Go
FileName: main.go
CodeFull:+143
// :glot
package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 5; {
		fmt.Printf("i: %d\n", i)
		i += 2
	}
	// :show end
}
CodeToRun:+104
package main

import "fmt"

func main() {
	for i := 0; i < 5; {
		fmt.Printf("i: %d\n", i)
		i += 2
	}
}
Output:+15
i: 0
i: 2
i: 4
66 1553595000564 glotid
Sha1: 5e4a0bcf8baa33bd838b7313dd8ad9b221e10ac2
GlotID: fapbounb4z
420 1553595001814 glotoutput
Sha1: 4d79f8d0e7d9f77d2f106543d64bf1fa5d852d52
Lang: Go
FileName: main.go
CodeFull:+164
// :glot
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for {
		fmt.Printf("i: %d\n", i)
		i += 2
		if i >= 5 {
			break
		}
	}

	// :show end
}
CodeToRun:+125
package main

import "fmt"

func main() {
	i := 0
	for {
		fmt.Printf("i: %d\n", i)
		i += 2
		if i >= 5 {
			break
		}
	}

}
Output:+15
i: 0
i: 2
i: 4
66 1553595001993 glotid
Sha1: 4d79f8d0e7d9f77d2f106543d64bf1fa5d852d52
GlotID: fapbovhxfz
496 1553595003273 glotoutput
Sha1: fbf5261f6537304d0087b68f835ea82cf3b646fa
Lang: Go
FileName: main.go
CodeFull:+184
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []int{1, 3, 5}
	for idx, value := range a {
		fmt.Printf("idx: %d, value: %d\n", idx, value)
	}
	// :show end
}
CodeToRun:+145
package main

import "fmt"

func main() {
	a := []int{1, 3, 5}
	for idx, value := range a {
		fmt.Printf("idx: %d, value: %d\n", idx, value)
	}
}
Output:+51
idx: 0, value: 1
idx: 1, value: 3
idx: 2, value: 5
66 1553595003458 glotid
Sha1: fbf5261f6537304d0087b68f835ea82cf3b646fa
GlotID: fapbowd7c0
526 1553595005089 glotoutput
Sha1: b4b3a1eff48a41353ee83f827146591277686b93
Lang: Go
FileName: main.go
CodeFull:+169
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "Hey 世界"
	for i, r := range s {
		fmt.Printf("idx: %d, rune: %d\n", i, r)
	}
	// :show end
}
CodeToRun:+130
package main

import "fmt"

func main() {
	s := "Hey 世界"
	for i, r := range s {
		fmt.Printf("idx: %d, rune: %d\n", i, r)
	}
}
Output:+110
idx: 0, rune: 72
idx: 1, rune: 101
idx: 2, rune: 121
idx: 3, rune: 32
idx: 4, rune: 19990
idx: 7, rune: 30028
66 1553595005267 glotid
Sha1: b4b3a1eff48a41353ee83f827146591277686b93
GlotID: fapboxg3an
533 1553595006786 glotoutput
Sha1: 2442221713d54359783857c35db3fcbd66d0abec
Lang: Go
FileName: main.go
CodeFull:+184
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "a 世"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("idx: %d, byte: %d\n", i, c)
	}
	// :show end
}
CodeToRun:+145
package main

import "fmt"

func main() {
	s := "a 世"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("idx: %d, byte: %d\n", i, c)
	}
}
Output:+88
idx: 0, byte: 97
idx: 1, byte: 32
idx: 2, byte: 228
idx: 3, byte: 184
idx: 4, byte: 150
66 1553595006967 glotid
Sha1: 2442221713d54359783857c35db3fcbd66d0abec
GlotID: fapboygif1
489 1553595008263 glotoutput
Sha1: ab74504de7191041a4b3a95cb8d5208e47a6a4a4
Lang: Go
FileName: main.go
CodeFull:+177
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for i, el := range a {
		fmt.Printf("idx: %d, element: %d\n", i, el)
	}
	// :show end
}
CodeToRun:+138
package main

import "fmt"

func main() {
	a := []int{3, 15, 8}
	for i, el := range a {
		fmt.Printf("idx: %d, element: %d\n", i, el)
	}
}
Output:+58
idx: 0, element: 3
idx: 1, element: 15
idx: 2, element: 8
66 1553595008820 glotid
Sha1: ab74504de7191041a4b3a95cb8d5208e47a6a4a4
GlotID: fapbozk9es
550 1553595010209 glotoutput
Sha1: ff62d02a0583fcf0f5fd3e7c585e419c2b4e9417
Lang: Go
FileName: main.go
CodeFull:+216
// :glot
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key, value := range m {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}
CodeToRun:+177
package main

import "fmt"

func main() {
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key, value := range m {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
}
Output:+41
key: five, value: 5
key: three, value: 3
66 1553595010386 glotid
Sha1: ff62d02a0583fcf0f5fd3e7c585e419c2b4e9417
GlotID: fapbp0htfu
1282 1553595011447 glotoutput
Sha1: 2a30cc2d3dcf3aca30245f416f1e75e09d0959b8
Lang: Go
FileName: main.go
CodeFull:+561
// :glot
package main

import (
	"fmt"
)

// :show start
// addCheckOverflow adds two int16 numbers and additionally
// returns true if the result overflowed
func addCheckOverflow(a, b uint16) (uint16, bool) {
	res := a + b
	overflowed := res < a || res < b
	return res, overflowed
}

func main() {
	res, overflowed := addCheckOverflow(1, 3)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n\n", 1, 3, res, overflowed)
	res, overflowed = addCheckOverflow(65520, 10000)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n", 65550, 10000, res, overflowed)
}

// :show end
CodeToRun:+524
package main

import (
	"fmt"
)

// addCheckOverflow adds two int16 numbers and additionally
// returns true if the result overflowed
func addCheckOverflow(a, b uint16) (uint16, bool) {
	res := a + b
	overflowed := res < a || res < b
	return res, overflowed
}

func main() {
	res, overflowed := addCheckOverflow(1, 3)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n\n", 1, 3, res, overflowed)
	res, overflowed = addCheckOverflow(65520, 10000)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n", 65550, 10000, res, overflowed)
}
Output:+82
    1 +     3 =     4, overflowed: false

65550 + 10000 =  9984, overflowed: true
66 1553595011631 glotid
Sha1: 2a30cc2d3dcf3aca30245f416f1e75e09d0959b8
GlotID: fapbp18bvs
652 1553595012939 glotoutput
Sha1: f5d0835a5833e824853289ead2984686f429aac7
Lang: Go
FileName: main.go
CodeFull:+283
// :glot
package main

import "fmt"

// :show start
type Person struct {
	FirstName string
	LastName  string
}

func (p *Person) PrintFullName() {
	fmt.Printf("%s %s\n", p.FirstName, p.LastName)
}

func main() {
	p := &Person{
		"John",
		"Doe",
	}
	p.PrintFullName()
}

// :show end
CodeToRun:+246
package main

import "fmt"

type Person struct {
	FirstName string
	LastName  string
}

func (p *Person) PrintFullName() {
	fmt.Printf("%s %s\n", p.FirstName, p.LastName)
}

func main() {
	p := &Person{
		"John",
		"Doe",
	}
	p.PrintFullName()
}
Output:+9
John Doe
66 1553595013115 glotid
Sha1: f5d0835a5833e824853289ead2984686f429aac7
GlotID: fapbp24bdn
1230 1553595015554 glotoutput
Sha1: cad570f7ef10fb514fc42ea34e83dd7f9eef3209
Lang: Go
FileName: main.go
CodeFull:+499
// :glot
package main

import "fmt"

// :show start
type Person struct {
	FirstName string
	LastName  string
}

func (p Person) PrintFullNameValue() {
	fmt.Printf("PrintFullNameValue:   address of p is %p\n", &p)
}

func (p *Person) PrintFullNamePointer() {
	fmt.Printf("PrintFullNamePointer: p is            %p\n", p)
}

func main() {
	p := Person{
		"John",
		"Doe",
	}
	fmt.Printf("address of p:                         %p\n", &p)
	p.PrintFullNamePointer()
	p.PrintFullNameValue()
}

// :show end
CodeToRun:+462
package main

import "fmt"

type Person struct {
	FirstName string
	LastName  string
}

func (p Person) PrintFullNameValue() {
	fmt.Printf("PrintFullNameValue:   address of p is %p\n", &p)
}

func (p *Person) PrintFullNamePointer() {
	fmt.Printf("PrintFullNamePointer: p is            %p\n", p)
}

func main() {
	p := Person{
		"John",
		"Doe",
	}
	fmt.Printf("address of p:                         %p\n", &p)
	p.PrintFullNamePointer()
	p.PrintFullNameValue()
}
Output:+153
address of p:                         0xc42000a060
PrintFullNamePointer: p is            0xc42000a060
PrintFullNameValue:   address of p is 0xc42000a080
66 1553595015750 glotid
Sha1: cad570f7ef10fb514fc42ea34e83dd7f9eef3209
GlotID: fapbp3oewn
1103 1553595016968 glotoutput
Sha1: 446ae4f5ae2495e0d962fb5dd9f7e1554ae85dd3
Lang: Go
FileName: main.go
CodeFull:+457
// :glot
package main

import (
	"fmt"
	"math"
)

// :show start
func sqrt(n float64) (float64, error) {
	if n < 0 {
		return 0, fmt.Errorf("invalid argument '%f', must be >= 0", n)
	}
	return math.Sqrt(n), nil
}

func printSqrt(n float64) {
	if res, err := sqrt(n); err == nil {
		fmt.Printf("sqrt of %f is %f\n", n, res)
	} else {
		fmt.Printf("sqrt of %f returned error '%s'\n", n, err)
	}

}

func main() {
	printSqrt(16)
	printSqrt(-16)
}

// :show end
CodeToRun:+420
package main

import (
	"fmt"
	"math"
)

func sqrt(n float64) (float64, error) {
	if n < 0 {
		return 0, fmt.Errorf("invalid argument '%f', must be >= 0", n)
	}
	return math.Sqrt(n), nil
}

func printSqrt(n float64) {
	if res, err := sqrt(n); err == nil {
		fmt.Printf("sqrt of %f is %f\n", n, res)
	} else {
		fmt.Printf("sqrt of %f returned error '%s'\n", n, err)
	}

}

func main() {
	printSqrt(16)
	printSqrt(-16)
}
Output:+110
sqrt of 16.000000 is 4.000000
sqrt of -16.000000 returned error 'invalid argument '-16.000000', must be >= 0'
66 1553595017150 glotid
Sha1: 446ae4f5ae2495e0d962fb5dd9f7e1554ae85dd3
GlotID: fapbp4ipz0
1384 1553595018553 glotoutput
Sha1: b5dae3b5bd8c6c843e1d3fd91071bc86324cbe9d
Lang: Go
FileName: main.go
CodeFull:+601
// :glot
package main

import (
	"fmt"
	"sync"
)

// :show start
var wg sync.WaitGroup

func pow2Worker(chIn chan int, chOut chan int) {
	fmt.Printf("sqrtWorker started\n")
	for i := range chIn {
		sqrt := i * i
		chOut <- sqrt
	}
	fmt.Printf("sqrtWorker finished\n")
	wg.Done()
}

func main() {
	chIn := make(chan int)
	chOut := make(chan int)
	for i := 0; i < 2; i++ {
		wg.Add(1)
		go pow2Worker(chIn, chOut)
	}

	go func() {
		chIn <- 2
		chIn <- 4
		close(chIn)
	}()

	go func() {
		wg.Wait()
		close(chOut)
	}()

	for sqrt := range chOut {
		fmt.Printf("Got sqrt: %d\n", sqrt)
	}
}

// :show end
CodeToRun:+564
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func pow2Worker(chIn chan int, chOut chan int) {
	fmt.Printf("sqrtWorker started\n")
	for i := range chIn {
		sqrt := i * i
		chOut <- sqrt
	}
	fmt.Printf("sqrtWorker finished\n")
	wg.Done()
}

func main() {
	chIn := make(chan int)
	chOut := make(chan int)
	for i := 0; i < 2; i++ {
		wg.Add(1)
		go pow2Worker(chIn, chOut)
	}

	go func() {
		chIn <- 2
		chIn <- 4
		close(chIn)
	}()

	go func() {
		wg.Wait()
		close(chOut)
	}()

	for sqrt := range chOut {
		fmt.Printf("Got sqrt: %d\n", sqrt)
	}
}
Output:+103
sqrtWorker started
Got sqrt: 4
sqrtWorker started
sqrtWorker finished
sqrtWorker finished
Got sqrt: 16
66 1553595018767 glotid
Sha1: b5dae3b5bd8c6c843e1d3fd91071bc86324cbe9d
GlotID: fapbp5hfdy
772 1553595019938 glotoutput
Sha1: cc73429dcea528efa58bd0d73b1a908f2cadb14f
Lang: Go
FileName: main.go
CodeFull:+341
// :glot
package main

import (
	"fmt"
	"math/rand"
)

// :show start

func genInts(chInts chan int) {
	chInts <- rand.Intn(1000)
}

func main() {
	chInts := make(chan int)
	for i := 0; i < 2; i++ {
		go genInts(chInts)
	}
	n := <-chInts
	fmt.Printf("n: %d\n", n)

	select {
	case n := <-chInts:
		fmt.Printf("n: %d\n", n)
	}
}

// :show end
CodeToRun:+303
package main

import (
	"fmt"
	"math/rand"
)

func genInts(chInts chan int) {
	chInts <- rand.Intn(1000)
}

func main() {
	chInts := make(chan int)
	for i := 0; i < 2; i++ {
		go genInts(chInts)
	}
	n := <-chInts
	fmt.Printf("n: %d\n", n)

	select {
	case n := <-chInts:
		fmt.Printf("n: %d\n", n)
	}
}
Output:+13
n: 81
n: 887
66 1553595020117 glotid
Sha1: cc73429dcea528efa58bd0d73b1a908f2cadb14f
GlotID: fapbp6ad52
1682 1553595021365 glotoutput
Sha1: bcdef3e77d37f654eb1c1a849926e845eb4a06e0
Lang: Go
FileName: main.go
CodeFull:+807
// :glot
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start
var cache map[int]int
var mu sync.Mutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.Lock()
	v, isCached := cache[n]
	mu.Unlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

// :show end

func main() {
	// :show start
	cache = make(map[int]int)
	go accessCache()
	accessCache()
	// :show end

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
CodeToRun:+739
package main

import (
	"fmt"
	"sync"
	"time"
)

var cache map[int]int
var mu sync.Mutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.Lock()
	v, isCached := cache[n]
	mu.Unlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

func main() {
	cache = make(map[int]int)
	go accessCache()
	accessCache()

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
Output:+20
total: 30
total: 30
66 1553595021548 glotid
Sha1: bcdef3e77d37f654eb1c1a849926e845eb4a06e0
GlotID: fapbp74zwd
1030 1553595024422 glotoutput
Sha1: 7b88e295c0c00dd4a275de52bde2cde9aaa25fe3
Lang: Go
FileName: main.go
CodeFull:+471
// :glot, :name main.go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	// :show start
	path := "main.go"
	f, err := os.Open(path)
	if err != nil {
		log.Fatalf("os.Open() failed with '%s'\n", err)
	}
	defer f.Close()

	d, err := ioutil.ReadAll(f)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	lines := bytes.Split(d, []byte{'\n'})
	fmt.Printf("File %s has %d lines\n", path, len(lines))
	// :show end
}
CodeToRun:+417
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	path := "main.go"
	f, err := os.Open(path)
	if err != nil {
		log.Fatalf("os.Open() failed with '%s'\n", err)
	}
	defer f.Close()

	d, err := ioutil.ReadAll(f)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	lines := bytes.Split(d, []byte{'\n'})
	fmt.Printf("File %s has %d lines\n", path, len(lines))
}
Output:+26
File main.go has 26 lines
66 1553595024598 glotid
Sha1: 7b88e295c0c00dd4a275de52bde2cde9aaa25fe3
GlotID: fapbp8yf81
1333 1553595027618 glotoutput
Sha1: 5896cb339eb26e54317385994aa602f6113cdcf7
Lang: Go
FileName: main.go
CodeFull:+600
// :glot, :name main.go
// :run go run main.go -echo echo-arg additional arg
package main

import (
	"flag"
	"fmt"
	"os"
)

// :show start
var (
	flgHelp bool
	flgEcho string
)

func parseCmdLineFlags() {
	flag.BoolVar(&flgHelp, "help", false, "if true, show help")
	flag.StringVar(&flgEcho, "echo", "", "")
	flag.Parse()
}

func main() {
	parseCmdLineFlags()
	if flgHelp {
		flag.Usage()
		os.Exit(0)
	}
	if flgEcho != "" {
		fmt.Printf("flag -echo: '%s'\n", flgEcho)
	}

	remainingArgs := flag.Args()
	for _, arg := range remainingArgs {
		fmt.Printf("Remainig arg: '%s'\n", arg)
	}
}

// :show end
CodeToRun:+495
package main

import (
	"flag"
	"fmt"
	"os"
)

var (
	flgHelp bool
	flgEcho string
)

func parseCmdLineFlags() {
	flag.BoolVar(&flgHelp, "help", false, "if true, show help")
	flag.StringVar(&flgEcho, "echo", "", "")
	flag.Parse()
}

func main() {
	parseCmdLineFlags()
	if flgHelp {
		flag.Usage()
		os.Exit(0)
	}
	if flgEcho != "" {
		fmt.Printf("flag -echo: '%s'\n", flgEcho)
	}

	remainingArgs := flag.Args()
	for _, arg := range remainingArgs {
		fmt.Printf("Remainig arg: '%s'\n", arg)
	}
}
RunCmd: go run main.go -echo echo-arg additional arg
Output:+70
flag -echo: 'echo-arg'
Remainig arg: 'additional'
Remainig arg: 'arg'
66 1553595027803 glotid
Sha1: 5896cb339eb26e54317385994aa602f6113cdcf7
GlotID: fapbpauzmo
418 1553595029359 glotoutput
Sha1: e51db797da3ed280b8b4feb1bac21efc1a0e0d46
Lang: Go
FileName: main.go
CodeFull:+148
// :glot, :allow error
package main

import "log"

func main() {
	// :show start
	log.Printf("Logging")
	log.Printf("Second line\n")
	// :show end
}
CodeToRun:+95
package main

import "log"

func main() {
	log.Printf("Logging")
	log.Printf("Second line\n")
}
Output:+60
2019/03/26 10:07:11 Logging
2019/03/26 10:07:11 Second line
66 1553595029535 glotid
Sha1: e51db797da3ed280b8b4feb1bac21efc1a0e0d46
GlotID: fapbpbw944
779 1553595031409 glotoutput
Sha1: 78505c3eefba58977b81d80c99761228204852c6
Lang: Go
FileName: main.go
CodeFull:+358
// :glot
// no output
package main

import (
	"log"
	"os"
)

func main() {
	// :show start
	logfile, err := os.OpenFile("test.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("os.OpenFile() failed with '%s\n", err)
	}
	defer logfile.Close()

	log.SetOutput(logfile)
	log.Println("Log entry")
	// :show end
	os.Remove("test.log")
}
CodeToRun:+306
package main

import (
	"log"
	"os"
)

func main() {
	logfile, err := os.OpenFile("test.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("os.OpenFile() failed with '%s\n", err)
	}
	defer logfile.Close()

	log.SetOutput(logfile)
	log.Println("Log entry")
	os.Remove("test.log")
}
Output:+0
66 1553595031587 glotid
Sha1: 78505c3eefba58977b81d80c99761228204852c6
GlotID: fapbpd484e
718 1553595032805 glotoutput
Sha1: b3aebb6fdba37f3473fb8c0753e0a33c9f7c29b9
Lang: Go
FileName: main.go
CodeFull:+300
// :glot
package main

import (
	"fmt"
	"log"
	"os/exec"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("cmd.CombinedOutput() failed with '%s'\n", err)
	}
	fmt.Printf("Output:\n%s\n", string(out))
	// :show end
}
CodeToRun:+261
package main

import (
	"fmt"
	"log"
	"os/exec"
)

func main() {
	cmd := exec.Command("go", "version")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("cmd.CombinedOutput() failed with '%s'\n", err)
	}
	fmt.Printf("Output:\n%s\n", string(out))
}
Output:+41
Output:
go version go1.10.3 linux/amd64

66 1553595032984 glotid
Sha1: b3aebb6fdba37f3473fb8c0753e0a33c9f7c29b9
GlotID: fapbpdy4cb
1126 1553595034149 glotoutput
Sha1: e9b3bc2f728da183252482dd9c63283d0fe4cbff
Lang: Go
FileName: main.go
CodeFull:+504
// :glot
package main

import (
	"bytes"
	"fmt"
	"log"
	"os/exec"
)

func main() {
	// :show start
	var stdout, stderr bytes.Buffer
	cmd := exec.Command("go", "version")
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	err = cmd.Wait()
	if err != nil {
		log.Fatalf("cmd.Wait() failed with '%s'\n", err)
	}
	out := append(stdout.Bytes(), stderr.Bytes()...)
	fmt.Printf("Output:\n%s\n", string(out))
	// :show end
}
CodeToRun:+465
package main

import (
	"bytes"
	"fmt"
	"log"
	"os/exec"
)

func main() {
	var stdout, stderr bytes.Buffer
	cmd := exec.Command("go", "version")
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	err = cmd.Wait()
	if err != nil {
		log.Fatalf("cmd.Wait() failed with '%s'\n", err)
	}
	out := append(stdout.Bytes(), stderr.Bytes()...)
	fmt.Printf("Output:\n%s\n", string(out))
}
Output:+41
Output:
go version go1.10.3 linux/amd64

66 1553595034327 glotid
Sha1: e9b3bc2f728da183252482dd9c63283d0fe4cbff
GlotID: fapbpeqxv5
915 1553595035886 glotoutput
Sha1: a0771de26cc07adc3eb0743d548ff0a7e91ee317
Lang: Go
FileName: main.go
CodeFull:+412
// :glot
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := hex.EncodeToString(d)
	fmt.Printf("Hex: %s\n", s)

	d2, err := hex.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
CodeToRun:+373
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := hex.EncodeToString(d)
	fmt.Printf("Hex: %s\n", s)

	d2, err := hex.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
}
Output:+14
Hex: 01ff3acd
66 1553595036062 glotid
Sha1: a0771de26cc07adc3eb0743d548ff0a7e91ee317
GlotID: fapbpfs55c
1064 1553595037141 glotoutput
Sha1: 9161e69f65831e2f52916432cac4c1f29f96de1d
Lang: Go
FileName: main.go
CodeFull:+476
// :glot
package main

import (
	"bytes"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := fmt.Sprintf("%x", d)
	fmt.Printf("Hex: %s\n", s)

	var decoded []byte
	_, err := fmt.Sscanf(s, "%x", &decoded)
	if err != nil {
		log.Fatalf("fmt.Sscanf() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}

	n := 3824
	fmt.Printf("%d in hex is 0x%x\n", n, n)
	// :show end
}
CodeToRun:+437
package main

import (
	"bytes"
	"fmt"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := fmt.Sprintf("%x", d)
	fmt.Printf("Hex: %s\n", s)

	var decoded []byte
	_, err := fmt.Sscanf(s, "%x", &decoded)
	if err != nil {
		log.Fatalf("fmt.Sscanf() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}

	n := 3824
	fmt.Printf("%d in hex is 0x%x\n", n, n)
}
Output:+35
Hex: 01ff3acd
3824 in hex is 0xef0
66 1553595037320 glotid
Sha1: 9161e69f65831e2f52916432cac4c1f29f96de1d
GlotID: fapbpgj2n6
1495 1553595038477 glotoutput
Sha1: 100f5cb94a3784426b9f1e02cb5660492f64ad03
Lang: Go
FileName: main.go
CodeFull:+702
// :glot
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	hexWriter := hex.NewEncoder(writer)

	_, err := hexWriter.Write(d)
	if err != nil {
		log.Fatalf("hexWriter.Write() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Hex: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	hexReader := hex.NewDecoder(reader)

	decoded, err := ioutil.ReadAll(hexReader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
CodeToRun:+663
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	hexWriter := hex.NewEncoder(writer)

	_, err := hexWriter.Write(d)
	if err != nil {
		log.Fatalf("hexWriter.Write() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Hex: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	hexReader := hex.NewDecoder(reader)

	decoded, err := ioutil.ReadAll(hexReader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
}
Output:+14
Hex: 01ff3acd
66 1553595038678 glotid
Sha1: 100f5cb94a3784426b9f1e02cb5660492f64ad03
GlotID: fapbphbrym
990 1553595066555 glotoutput
Sha1: b085a8c7274c1c103789ebe8283506dfc628f450
Lang: Go
FileName: main.go
CodeFull:+448
// :glot
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.StdEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
CodeToRun:+409
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.StdEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
}
Output:+17
base64: Af86zQ==
66 1553595067214 glotid
Sha1: b085a8c7274c1c103789ebe8283506dfc628f450
GlotID: fapbpybtjc
990 1553595068638 glotoutput
Sha1: 251bcbaa4380e1d44981ff78ed27ad9233ebce67
Lang: Go
FileName: main.go
CodeFull:+448
// :glot
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.URLEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.URLEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
CodeToRun:+409
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.URLEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.URLEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
}
Output:+17
base64: Af86zQ==
66 1553595068818 glotid
Sha1: 251bcbaa4380e1d44981ff78ed27ad9233ebce67
GlotID: fapbpza6wc
1850 1553595070297 glotoutput
Sha1: 46c96fbc97915538acfc058d761dd5afa20f60a5
Lang: Go
FileName: main.go
CodeFull:+878
// :glot
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	base64Writer := base64.NewEncoder(base64.StdEncoding, writer)

	_, err := base64Writer.Write(d)
	if err != nil {
		log.Fatalf("base64Writer.Write() failed with '%s'\n", err)
	}
	err = base64Writer.Close()
	if err != nil {
		log.Fatalf("base64Writer.Close() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Base64: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	base64Reader := base64.NewDecoder(base64.StdEncoding, reader)

	decoded, err := ioutil.ReadAll(base64Reader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
CodeToRun:+839
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	base64Writer := base64.NewEncoder(base64.StdEncoding, writer)

	_, err := base64Writer.Write(d)
	if err != nil {
		log.Fatalf("base64Writer.Write() failed with '%s'\n", err)
	}
	err = base64Writer.Close()
	if err != nil {
		log.Fatalf("base64Writer.Close() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Base64: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	base64Reader := base64.NewDecoder(base64.StdEncoding, reader)

	decoded, err := ioutil.ReadAll(base64Reader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
}
Output:+17
Base64: Af86zQ==
66 1553595070472 glotid
Sha1: 46c96fbc97915538acfc058d761dd5afa20f60a5
GlotID: fapbq09nc4
1521 1553595071845 glotoutput
Sha1: 5e917843d3ba654fcaac242f3de70aead9f5b35c
Lang: Go
FileName: main.go
CodeFull:+665
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type Person struct {
	fullName string
	Name     string
	Age      int    `json:"age"`
	City     string `json:"city"`
}

// :show end

func main() {
	// :show start
	p := Person{
		Name: "John",
		Age:  37,
		City: "SF",
	}
	d, err := json.Marshal(&p)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

	d, err = json.MarshalIndent(p, "", "  ")
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in pretty-printed JSON:\n%s\n", string(d))
	// :show end
}
CodeToRun:+597
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

type Person struct {
	fullName string
	Name     string
	Age      int    `json:"age"`
	City     string `json:"city"`
}

func main() {
	p := Person{
		Name: "John",
		Age:  37,
		City: "SF",
	}
	d, err := json.Marshal(&p)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

	d, err = json.MarshalIndent(p, "", "  ")
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in pretty-printed JSON:\n%s\n", string(d))
}
Output:+142
Person in compact JSON: {"Name":"John","age":37,"city":"SF"}
Person in pretty-printed JSON:
{
  "Name": "John",
  "age": 37,
  "city": "SF"
}
66 1553595072017 glotid
Sha1: 5e917843d3ba654fcaac242f3de70aead9f5b35c
GlotID: fapbq16s73
1286 1553595074825 glotoutput
Sha1: 0a94dffc763ec9b6d0f6be4281115d724781b99a
Lang: Go
FileName: main.go
CodeFull:+558
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type Person struct {
	Name       *string `json:"name"`
	Age        int     `json:"age"`
	City       string
	Occupation string
}

var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`

// :show end

func main() {
	// :show start
	var p Person
	err := json.Unmarshal([]byte(jsonStr), &p)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("Person struct parsed from JSON: %#v\n", p)
	fmt.Printf("Name: %#v\n", *p.Name)
	// :show end
}
CodeToRun:+490
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

type Person struct {
	Name       *string `json:"name"`
	Age        int     `json:"age"`
	City       string
	Occupation string
}

var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`

func main() {
	var p Person
	err := json.Unmarshal([]byte(jsonStr), &p)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("Person struct parsed from JSON: %#v\n", p)
	fmt.Printf("Name: %#v\n", *p.Name)
}
Output:+121
Person struct parsed from JSON: main.Person{Name:(*string)(0xc42000e260), Age:24, City:"ny", Occupation:""}
Name: "Jane"
66 1553595074997 glotid
Sha1: 0a94dffc763ec9b6d0f6be4281115d724781b99a
GlotID: fapbq2ync1
1946 1553595076464 glotoutput
Sha1: 364c3f5d9c4ed4ef1ace1da699b96685da593c5f
Lang: Go
FileName: main.go
CodeFull:+833
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

// :show end

func main() {
	// :show start
	var people People
	data := []byte(xmlStr)
	err := xml.Unmarshal(data, &people)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
	// :show end
}
CodeToRun:+765
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

func main() {
	var people People
	data := []byte(xmlStr)
	err := xml.Unmarshal(data, &people)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
}
Output:+231
main.People{Person:[]main.Person{main.Person{Age:34, FirstName:"John", Address:main.Address{City:(*string)(0xc42000e400), State:"CA"}}, main.Person{Age:23, FirstName:"Julia", Address:main.Address{City:(*string)(nil), State:""}}}}

66 1553595076674 glotid
Sha1: 364c3f5d9c4ed4ef1ace1da699b96685da593c5f
GlotID: fapbq3ylp1
2373 1553595077972 glotoutput
Sha1: eda75a326ee389e05a531bbaf1cd320062148a61
Lang: Go
FileName: main.go
CodeFull:+992
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type People struct {
	XMLName        xml.Name `xml:"people"`
	Person         []Person `xml:"person"`
	noteSerialized int
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

// :show end

func main() {
	// :show start
	people := People{
		Person: []Person{
			Person{
				Age:       34,
				FirstName: "John",
				Address:   Address{City: "San Francisco", State: "CA"},
			},
		},
		noteSerialized: 8,
	}
	d, err := xml.Marshal(&people)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("Compact XML: %s\n\n", string(d))

	d, err = xml.MarshalIndent(&people, "", "  ")
	if err != nil {
		log.Fatalf("xml.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Pretty printed XML:\n%s\n", string(d))

	// :show end
}
CodeToRun:+924
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type People struct {
	XMLName        xml.Name `xml:"people"`
	Person         []Person `xml:"person"`
	noteSerialized int
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

func main() {
	people := People{
		Person: []Person{
			Person{
				Age:       34,
				FirstName: "John",
				Address:   Address{City: "San Francisco", State: "CA"},
			},
		},
		noteSerialized: 8,
	}
	d, err := xml.Marshal(&people)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("Compact XML: %s\n\n", string(d))

	d, err = xml.MarshalIndent(&people, "", "  ")
	if err != nil {
		log.Fatalf("xml.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Pretty printed XML:\n%s\n", string(d))

}
Output:+340
Compact XML: <people><person age="34"><first-name>John</first-name><address><city>San Francisco</city><state>CA</state></address></person></people>

Pretty printed XML:
<people>
  <person age="34">
    <first-name>John</first-name>
    <address>
      <city>San Francisco</city>
      <state>CA</state>
    </address>
  </person>
</people>
66 1553595078538 glotid
Sha1: eda75a326ee389e05a531bbaf1cd320062148a61
GlotID: fapbq52amb
2261 1553595081584 glotoutput
Sha1: ec402f97e3654701c0e401df305fae4a2b7e0498
Lang: Go
FileName: main.go
CodeFull:+1058
// :glot
package main

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

// :show start
func writeCSV() error {
	f, err := os.Create("stocks_tmp.csv")
	if err != nil {
		return err
	}

	w := csv.NewWriter(f)
	records := [][]string{
		{"date", "price", "name"},
		{"2013-02-08", "15,07", "GOOG"},
		{"2013-02-09", "15,09", "GOOG"},
	}
	for _, rec := range records {
		err = w.Write(rec)
		if err != nil {
			f.Close()
			return err
		}
	}

	// csv.Writer might buffer writes for performance so we must
	// Flush to ensure all data has been written to underlying
	// writer
	w.Flush()

	// Flush doesn't return an error. If it failed to write, we
	// can get the error with Error()
	err = w.Error()
	if err != nil {
		return err
	}
	// Close might also fail due to flushing out buffered writes
	err = f.Close()
	return err
}

// :show end

func main() {
	writeCSV()
	d, err := ioutil.ReadFile("stocks_tmp.csv")
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}
	fmt.Printf("%s\n", string(d))
	os.Remove("stocks_tmp.csv")
}
CodeToRun:+1020
package main

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

func writeCSV() error {
	f, err := os.Create("stocks_tmp.csv")
	if err != nil {
		return err
	}

	w := csv.NewWriter(f)
	records := [][]string{
		{"date", "price", "name"},
		{"2013-02-08", "15,07", "GOOG"},
		{"2013-02-09", "15,09", "GOOG"},
	}
	for _, rec := range records {
		err = w.Write(rec)
		if err != nil {
			f.Close()
			return err
		}
	}

	// csv.Writer might buffer writes for performance so we must
	// Flush to ensure all data has been written to underlying
	// writer
	w.Flush()

	// Flush doesn't return an error. If it failed to write, we
	// can get the error with Error()
	err = w.Error()
	if err != nil {
		return err
	}
	// Close might also fail due to flushing out buffered writes
	err = f.Close()
	return err
}

func main() {
	writeCSV()
	d, err := ioutil.ReadFile("stocks_tmp.csv")
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}
	fmt.Printf("%s\n", string(d))
	os.Remove("stocks_tmp.csv")
}
Output:+65
date,price,name
2013-02-08,"15,07",GOOG
2013-02-09,"15,09",GOOG

66 1553595081756 glotid
Sha1: ec402f97e3654701c0e401df305fae4a2b7e0498
GlotID: fapbq6zier
1786 1553595084567 glotoutput
Sha1: 1323be3e780ec8e9f9b6b9a957a610f235986dc0
Lang: Go
FileName: main.go
CodeFull:+813
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
var tmplStr = `User {{.User}} has {{.TotalTweets}} tweets.
{{- $tweetCount := len .RecentTweets }}
Recent tweets:
{{range $idx, $tweet := .RecentTweets}}Tweet {{$idx}} of {{$tweetCount}}: '{{.}}'
{{end -}}
Most recent tweet: '{{index .RecentTweets 0}}'
`

// :show end

func main() {
	// :show start
	t := template.New("tweets")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}
	data := struct {
		User         string
		TotalTweets  int
		RecentTweets []string
	}{
		User:         "kjk",
		TotalTweets:  124,
		RecentTweets: []string{"hello", "there"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+745
package main

import (
	"log"
	"os"
	"text/template"
)

var tmplStr = `User {{.User}} has {{.TotalTweets}} tweets.
{{- $tweetCount := len .RecentTweets }}
Recent tweets:
{{range $idx, $tweet := .RecentTweets}}Tweet {{$idx}} of {{$tweetCount}}: '{{.}}'
{{end -}}
Most recent tweet: '{{index .RecentTweets 0}}'
`

func main() {
	t := template.New("tweets")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}
	data := struct {
		User         string
		TotalTweets  int
		RecentTweets []string
	}{
		User:         "kjk",
		TotalTweets:  124,
		RecentTweets: []string{"hello", "there"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+111
User kjk has 124 tweets.
Recent tweets:
Tweet 0 of 2: 'hello'
Tweet 1 of 2: 'there'
Most recent tweet: 'hello'
66 1553595084750 glotid
Sha1: 1323be3e780ec8e9f9b6b9a957a610f235986dc0
GlotID: fapbq8ridf
1099 1553595086602 glotoutput
Sha1: ab17bc21d0da5d0e609ff3070b5dec64a8da0ccb
Lang: Go
FileName: main.go
CodeFull:+494
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	// :show start
	tmplStr := "Data: {{.}}\n"
	t := template.Must(template.New("simple").Parse(tmplStr))
	execWithData := func(data interface{}) {
		err := t.Execute(os.Stdout, data)
		if err != nil {
			log.Fatalf("t.Execute() failed with '%s'\n", err)
		}
	}

	execWithData(5)
	execWithData("foo")
	st := struct {
		Number int
		Str    string
	}{
		Number: 3,
		Str:    "hello",
	}
	execWithData(st)
	// :show end
}
CodeToRun:+455
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	tmplStr := "Data: {{.}}\n"
	t := template.Must(template.New("simple").Parse(tmplStr))
	execWithData := func(data interface{}) {
		err := t.Execute(os.Stdout, data)
		if err != nil {
			log.Fatalf("t.Execute() failed with '%s'\n", err)
		}
	}

	execWithData(5)
	execWithData("foo")
	st := struct {
		Number int
		Str    string
	}{
		Number: 3,
		Str:    "hello",
	}
	execWithData(st)
}
Output:+34
Data: 5
Data: foo
Data: {3 hello}
66 1553595086774 glotid
Sha1: ab17bc21d0da5d0e609ff3070b5dec64a8da0ccb
GlotID: fapbq9z1vt
866 1553595088508 glotoutput
Sha1: c991c9f35843f50e115ace9c62fe696e47a24412
Lang: Go
FileName: main.go
CodeFull:+366
// :glot
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	var v interface{} = 4
	var reflectVal reflect.Value = reflect.ValueOf(v)

	var typ reflect.Type = reflectVal.Type()
	fmt.Printf("Type '%s' of size: %d bytes\n", typ.Name(), typ.Size())
	if typ.Kind() == reflect.Int {
		fmt.Printf("v contains value of type int\n")
	}
	// :show end
}
CodeToRun:+327
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var v interface{} = 4
	var reflectVal reflect.Value = reflect.ValueOf(v)

	var typ reflect.Type = reflectVal.Type()
	fmt.Printf("Type '%s' of size: %d bytes\n", typ.Name(), typ.Size())
	if typ.Kind() == reflect.Int {
		fmt.Printf("v contains value of type int\n")
	}
}
Output:+57
Type 'int' of size: 8 bytes
v contains value of type int
66 1553595088681 glotid
Sha1: c991c9f35843f50e115ace9c62fe696e47a24412
GlotID: fapbqb3y1t
2772 1553595089770 glotoutput
Sha1: a4f1ae95fb32fa0340c56be0d57e0682defa5363
Lang: Go
FileName: main.go
CodeFull:+1322
// :glot
package main

import (
    "bytes"
    "fmt"
    "sync"
)

var pool = sync.Pool{
    // New creates an object when the pool has nothing available to return.
    // New must return an interface{} to make it flexible. You have to cast
    // your type after getting it.
    New: func() interface{} {
        // Pools often contain things like *bytes.Buffer, which are
        // temporary and re-usable.
        return &bytes.Buffer{}
    },
}

func main() {
    // When getting from a Pool, you need to cast
    s := pool.Get().(*bytes.Buffer)
    // We write to the object
    s.Write([]byte("dirty"))
    // Then put it back
    pool.Put(s)

    // Pools can return dirty results

    // Get 'another' buffer
    s = pool.Get().(*bytes.Buffer)
    // Write to it
    s.Write([]byte("append"))
    // At this point, if GC ran, this buffer *might* exist already, in
    // which case it will contain the bytes of the string "dirtyappend"
    fmt.Println(s)
    // So use pools wisely, and clean up after yourself
    s.Reset()
    pool.Put(s)

    // When you clean up, your buffer should be empty
    s = pool.Get().(*bytes.Buffer)
    // Defer your Puts to make sure you don't leak!
    defer pool.Put(s)
    s.Write([]byte("reset!"))
    // This prints "reset!", and not "dirtyappendreset!"
    fmt.Println(s)
}
CodeToRun:+1313
package main

import (
    "bytes"
    "fmt"
    "sync"
)

var pool = sync.Pool{
    // New creates an object when the pool has nothing available to return.
    // New must return an interface{} to make it flexible. You have to cast
    // your type after getting it.
    New: func() interface{} {
        // Pools often contain things like *bytes.Buffer, which are
        // temporary and re-usable.
        return &bytes.Buffer{}
    },
}

func main() {
    // When getting from a Pool, you need to cast
    s := pool.Get().(*bytes.Buffer)
    // We write to the object
    s.Write([]byte("dirty"))
    // Then put it back
    pool.Put(s)

    // Pools can return dirty results

    // Get 'another' buffer
    s = pool.Get().(*bytes.Buffer)
    // Write to it
    s.Write([]byte("append"))
    // At this point, if GC ran, this buffer *might* exist already, in
    // which case it will contain the bytes of the string "dirtyappend"
    fmt.Println(s)
    // So use pools wisely, and clean up after yourself
    s.Reset()
    pool.Put(s)

    // When you clean up, your buffer should be empty
    s = pool.Get().(*bytes.Buffer)
    // Defer your Puts to make sure you don't leak!
    defer pool.Put(s)
    s.Write([]byte("reset!"))
    // This prints "reset!", and not "dirtyappendreset!"
    fmt.Println(s)
}
Output:+19
dirtyappend
reset!
66 1553595089943 glotid
Sha1: a4f1ae95fb32fa0340c56be0d57e0682defa5363
GlotID: fapbqbuzpo
283 1553595091517 glotoutput
Sha1: 12375e0adc65593165a0b11fe569da80952cb9b2
Lang: Go
FileName: main.go
CodeFull:+82
// :glot
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
CodeToRun:+73
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
Output:+14
Hello, 世界
66 1553595091690 glotid
Sha1: 12375e0adc65593165a0b11fe569da80952cb9b2
GlotID: fapbqcwf1b
607 1553595092708 glotoutput
Sha1: 22e8cb51268849b89e5a102319541b49fbe22427
Lang: Go
FileName: main.go
CodeFull:+236
// :glot
package main

import "fmt"

func main() {
	// :show start
	var b bool = true
	fmt.Printf("b is: '%v'\n", b)
	b = false
	fmt.Printf("b is: '%v'\n", b)
	var b2 bool
	fmt.Printf("zero value of bool is: '%v'\n", b2)
	// :show end
}
CodeToRun:+197
package main

import "fmt"

func main() {
	var b bool = true
	fmt.Printf("b is: '%v'\n", b)
	b = false
	fmt.Printf("b is: '%v'\n", b)
	var b2 bool
	fmt.Printf("zero value of bool is: '%v'\n", b2)
}
Output:+58
b is: 'true'
b is: 'false'
zero value of bool is: 'false'
66 1553595092882 glotid
Sha1: 22e8cb51268849b89e5a102319541b49fbe22427
GlotID: fapbqdlyqx
422 1553595094385 glotoutput
Sha1: edfb56fb113b26f74499648bda4c73c8fbf8d7b5
Lang: Go
FileName: main.go
CodeFull:+163
// :glot
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	// :show start
	b := true
	fmt.Printf("size of bool is: %d\n", unsafe.Sizeof(b))
	// :show end
}
CodeToRun:+124
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	b := true
	fmt.Printf("size of bool is: %d\n", unsafe.Sizeof(b))
}
Output:+19
size of bool is: 1
66 1553595094560 glotid
Sha1: edfb56fb113b26f74499648bda4c73c8fbf8d7b5
GlotID: fapbqelw7z
545 1553595095977 glotoutput
Sha1: 529223a1c751db6a7e9099dd2074c818a68267d7
Lang: Go
FileName: main.go
CodeFull:+226
// :glot
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var i1 int = -38
	fmt.Printf("i1: %s\n", strconv.Itoa(i1))

	var i2 int32 = 148
	fmt.Printf("i2: %s\n", strconv.Itoa(int(i2)))
	// :show end
}
CodeToRun:+187
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var i1 int = -38
	fmt.Printf("i1: %s\n", strconv.Itoa(i1))

	var i2 int32 = 148
	fmt.Printf("i2: %s\n", strconv.Itoa(int(i2)))
}
Output:+16
i1: -38
i2: 148
66 1553595096149 glotid
Sha1: 529223a1c751db6a7e9099dd2074c818a68267d7
GlotID: fapbqfjz1h
573 1553595098183 glotoutput
Sha1: 013a8788bafeefbf719911a0deb7a4fe65fa03fd
Lang: Go
FileName: main.go
CodeFull:+240
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	var i1 int = -38
	s1 := fmt.Sprintf("%d", i1)
	fmt.Printf("i1: %s\n", s1)

	var i2 int32 = 148
	s2 := fmt.Sprintf("%d", i2)
	fmt.Printf("i2: %s\n", s2)
	// :show end
}
CodeToRun:+201
package main

import (
	"fmt"
)

func main() {
	var i1 int = -38
	s1 := fmt.Sprintf("%d", i1)
	fmt.Printf("i1: %s\n", s1)

	var i2 int32 = 148
	s2 := fmt.Sprintf("%d", i2)
	fmt.Printf("i2: %s\n", s2)
}
Output:+16
i1: -38
i2: 148
66 1553595098353 glotid
Sha1: 013a8788bafeefbf719911a0deb7a4fe65fa03fd
GlotID: fapbqgv98f
576 1553595100025 glotoutput
Sha1: 43999c7ab1380a34213942f6ba39266928f8f738
Lang: Go
FileName: main.go
CodeFull:+246
// :glot
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "-48"
	i1, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("strconv.Atoi() failed with %s\n", err)
	}
	fmt.Printf("i1: %d\n", i1)
	// :show end
}
CodeToRun:+207
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	s := "-48"
	i1, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("strconv.Atoi() failed with %s\n", err)
	}
	fmt.Printf("i1: %d\n", i1)
}
Output:+8
i1: -48
66 1553595100199 glotid
Sha1: 43999c7ab1380a34213942f6ba39266928f8f738
GlotID: fapbqhys3m
584 1553595101656 glotoutput
Sha1: d4c5251caf2fbd4d82397316a9bfb80fea6b89e0
Lang: Go
FileName: main.go
CodeFull:+250
// :glot
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "348"
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("i1: %d\n", i)
	// :show end
}
CodeToRun:+211
package main

import (
	"fmt"
	"log"
)

func main() {
	s := "348"
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("i1: %d\n", i)
}
Output:+8
i1: 348
66 1553595101828 glotid
Sha1: d4c5251caf2fbd4d82397316a9bfb80fea6b89e0
GlotID: fapbqixpvy
794 1553595103089 glotoutput
Sha1: 1aa0a0835b798707a20473b31dbf429c97a0c139
Lang: Go
FileName: main.go
CodeFull:+344
// :glot
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var f32 float32 = 1.3
	bitSize := 32
	s1 := strconv.FormatFloat(float64(f32), 'E', -1, bitSize)
	fmt.Printf("f32: %s\n", s1)

	var f64 float64 = 8.1234
	bitSize = 64
	s2 := strconv.FormatFloat(f64, 'e', -1, bitSize)
	fmt.Printf("f64: %s\n", s2)
	// :show end
}
CodeToRun:+305
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var f32 float32 = 1.3
	bitSize := 32
	s1 := strconv.FormatFloat(float64(f32), 'E', -1, bitSize)
	fmt.Printf("f32: %s\n", s1)

	var f64 float64 = 8.1234
	bitSize = 64
	s2 := strconv.FormatFloat(f64, 'e', -1, bitSize)
	fmt.Printf("f64: %s\n", s2)
}
Output:+29
f32: 1.3E+00
f64: 8.1234e+00
66 1553595103265 glotid
Sha1: 1aa0a0835b798707a20473b31dbf429c97a0c139
GlotID: fapbqjsht0
426 1553595105674 glotoutput
Sha1: a5c90bf0e77b04d1e589a1c8e2dadc5e9d3a5a23
Lang: Go
FileName: main.go
CodeFull:+166
// :glot
package main

import "fmt"

func main() {
	// :show start
	var f64 float64 = 1.54
	s := fmt.Sprintf("%f", f64)
	fmt.Printf("f is: '%s'\n", s)
	// :show end
}
CodeToRun:+127
package main

import "fmt"

func main() {
	var f64 float64 = 1.54
	s := fmt.Sprintf("%f", f64)
	fmt.Printf("f is: '%s'\n", s)
}
Output:+17
f is: '1.540000'
66 1553595105847 glotid
Sha1: a5c90bf0e77b04d1e589a1c8e2dadc5e9d3a5a23
GlotID: fapbqlbua1
642 1553595107399 glotoutput
Sha1: 450dbea877416d69b9b2114b7e9490b1448fa278
Lang: Go
FileName: main.go
CodeFull:+271
// :glot,
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "1.2341"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		log.Fatalf("strconv.ParseFloat() failed with '%s'\n", err)
	}
	fmt.Printf("f64: %f\n", f64)
	// :show end
}
CodeToRun:+241
// :glot,
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	s := "1.2341"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		log.Fatalf("strconv.ParseFloat() failed with '%s'\n", err)
	}
	fmt.Printf("f64: %f\n", f64)
}
Output:+14
f64: 1.234100
66 1553595107573 glotid
Sha1: 450dbea877416d69b9b2114b7e9490b1448fa278
GlotID: fapbqmctgl
601 1553595108719 glotoutput
Sha1: 6760c02fb721ce79f372fbb5758bfb198169bd3e
Lang: Go
FileName: main.go
CodeFull:+256
// :glot
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "1.2341"
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("f: %f\n", f)
	// :show end
}
CodeToRun:+217
package main

import (
	"fmt"
	"log"
)

func main() {
	s := "1.2341"
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("f: %f\n", f)
}
Output:+12
f: 1.234100
66 1553595108896 glotid
Sha1: 6760c02fb721ce79f372fbb5758bfb198169bd3e
GlotID: fapbqn55tw
565 1553595110770 glotoutput
Sha1: 3cbd441e99ca1d157c7d9e9aa719d7a6086ecf6c
Lang: Go
FileName: main.go
CodeFull:+199
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "str"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("Byte at index %d is '%c' (0x%x)\n", i, c, c)
	}
	// :show end
}
CodeToRun:+160
package main

import "fmt"

func main() {
	s := "str"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("Byte at index %d is '%c' (0x%x)\n", i, c, c)
	}
}
Output:+90
Byte at index 0 is 's' (0x73)
Byte at index 1 is 't' (0x74)
Byte at index 2 is 'r' (0x72)
66 1553595110943 glotid
Sha1: 3cbd441e99ca1d157c7d9e9aa719d7a6086ecf6c
GlotID: fapbqod2xr
590 1553595111999 glotoutput
Sha1: c1a81386de20109aa644aab3fd11dd1f892d6f67
Lang: Go
FileName: main.go
CodeFull:+196
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "日本語"
	for i, runeChar := range s {
		fmt.Printf("Rune at byte position %d is %#U\n", i, runeChar)
	}
	// :show end
}
CodeToRun:+157
package main

import "fmt"

func main() {
	s := "日本語"
	for i, runeChar := range s {
		fmt.Printf("Rune at byte position %d is %#U\n", i, runeChar)
	}
}
Output:+120
Rune at byte position 0 is U+65E5 '日'
Rune at byte position 3 is U+672C '本'
Rune at byte position 6 is U+8A9E '語'
66 1553595112173 glotid
Sha1: c1a81386de20109aa644aab3fd11dd1f892d6f67
GlotID: fapbqp3ez8
792 1553595113539 glotoutput
Sha1: 8e0e4a6590b2b620c652a817d4d2b4e9ac87188e
Lang: Go
FileName: main.go
CodeFull:+294
// :glot
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters\n"
	s2 := `raw string literal
which doesnt't recgonize escape characters like \n
`
	fmt.Printf("sum of strings\n'%s'\n", s+s1+s2)
	// :show end
}
CodeToRun:+255
package main

import "fmt"

func main() {
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters\n"
	s2 := `raw string literal
which doesnt't recgonize escape characters like \n
`
	fmt.Printf("sum of strings\n'%s'\n", s+s1+s2)
}
Output:+126
sum of strings
'string
literal
with	escape characters
raw string literal
which doesnt't recgonize escape characters like \n
'
66 1553595113713 glotid
Sha1: 8e0e4a6590b2b620c652a817d4d2b4e9ac87188e
GlotID: fapbqq0fo1
906 1553595114575 glotoutput
Sha1: a398c7af3255b466d5cbbe0c28f6104eab6f1c51
Lang: Go
FileName: main.go
CodeFull:+420
// :glot, no output
package main

// :show start
const (
	i  int = 32       // int constant
	s      = "string" // string constant
	i2     = 33       // untyped number constant
)

var (
	// values that are not read-only (like slices or maps or structs) cannot be
	// constants
	// we can declare them as top-level variables
	b = []byte{3, 4} // this could not be a constant
)

// :show end

func main() {
	// do nothing
}
CodeToRun:+371
package main

const (
	i  int = 32       // int constant
	s      = "string" // string constant
	i2     = 33       // untyped number constant
)

var (
	// values that are not read-only (like slices or maps or structs) cannot be
	// constants
	// we can declare them as top-level variables
	b = []byte{3, 4} // this could not be a constant
)

func main() {
	// do nothing
}
Output:+0
66 1553595114753 glotid
Sha1: a398c7af3255b466d5cbbe0c28f6104eab6f1c51
GlotID: fapbqqmogo
711 1553595116019 glotoutput
Sha1: f5f192a2ec03805e3db1f6cbd99499de64ffbed0
Lang: Go
FileName: main.go
CodeFull:+298
// :glot,
package main

import "fmt"

func main() {
	// :show start
	var a1 = [2]byte{3, 8} // array of 2 bytes
	// when using [...] size will be deduced from { ... }
	a2 := [...]int{1, 2, 3} // array of 3 integers

	fmt.Printf("Size of a1: %d.\nSize of a2: %d\n", len(a1), len(a2))
	// :show end
}
CodeToRun:+268
// :glot,
package main

import "fmt"

func main() {
	var a1 = [2]byte{3, 8} // array of 2 bytes
	// when using [...] size will be deduced from { ... }
	a2 := [...]int{1, 2, 3} // array of 3 integers

	fmt.Printf("Size of a1: %d.\nSize of a2: %d\n", len(a1), len(a2))
}
Output:+29
Size of a1: 2.
Size of a2: 3
66 1553595116191 glotid
Sha1: f5f192a2ec03805e3db1f6cbd99499de64ffbed0
GlotID: fapbqrhj07
1304 1553595117644 glotoutput
Sha1: fa54357fd561e85809bbc02f7156d027720c3b24
Lang: Go
FileName: main.go
CodeFull:+553
// :glot
package main

import "fmt"

func main() {
	// :show start
	m := make(map[string]int)
	m["number3"] = 3

	checkKey := func(k string) {
		if n, ok := m[k]; ok {
			fmt.Printf("value for key '%s' is %d\n", k, n)
		} else {
			fmt.Printf("key '%s' doesn't exist in map\n", k)
		}
	}

	// get value for a key that exists
	checkKey("number3")

	// get value for a key that doesn't exist
	checkKey("number4")

	// remove a key
	delete(m, "number3")
	fmt.Printf("deleted key 'number3\n")
	checkKey("number3") // and now it doesn't exist
	// :show end
}
CodeToRun:+514
package main

import "fmt"

func main() {
	m := make(map[string]int)
	m["number3"] = 3

	checkKey := func(k string) {
		if n, ok := m[k]; ok {
			fmt.Printf("value for key '%s' is %d\n", k, n)
		} else {
			fmt.Printf("key '%s' doesn't exist in map\n", k)
		}
	}

	// get value for a key that exists
	checkKey("number3")

	// get value for a key that doesn't exist
	checkKey("number4")

	// remove a key
	delete(m, "number3")
	fmt.Printf("deleted key 'number3\n")
	checkKey("number3") // and now it doesn't exist
}
Output:+120
value for key 'number3' is 3
key 'number4' doesn't exist in map
deleted key 'number3
key 'number3' doesn't exist in map
66 1553595117819 glotid
Sha1: fa54357fd561e85809bbc02f7156d027720c3b24
GlotID: fapbqsgf26
442 1553595120088 glotoutput
Sha1: 23f6131e28ef365551ffb219a7ec8b0b25811bd6
Lang: Go
FileName: main.go
CodeFull:+188
// :glot, no output
package main

// :show start
type MyStruct struct {
	IntVal           int
	StringVal        string
	unexportedIntVal int
}

// :show end

func main() {
	// do nothing
}
CodeToRun:+139
package main

type MyStruct struct {
	IntVal           int
	StringVal        string
	unexportedIntVal int
}

func main() {
	// do nothing
}
Output:+0
66 1553595120265 glotid
Sha1: 23f6131e28ef365551ffb219a7ec8b0b25811bd6
GlotID: fapbqtwsbj
520 1553595122179 glotoutput
Sha1: 55dcdfb2a56707748923a24c4a98c5bcf42b43d2
Lang: Go
FileName: main.go
CodeFull:+189
// :glot
package main

import "fmt"

func main() {
	// :show start
	var a int = 4
	pa := &a
	fmt.Printf("Address of a variable in memory is %p. Its value is: %d\n", pa, *pa)
	// :show end
}
CodeToRun:+150
package main

import "fmt"

func main() {
	var a int = 4
	pa := &a
	fmt.Printf("Address of a variable in memory is %p. Its value is: %d\n", pa, *pa)
}
Output:+65
Address of a variable in memory is 0xc42006c010. Its value is: 4
66 1553595122362 glotid
Sha1: 55dcdfb2a56707748923a24c4a98c5bcf42b43d2
GlotID: fapbqv5kuz
825 1553595123776 glotoutput
Sha1: 65917487e32af83d83a19c1d7cbcf0e86c00bcbd
Lang: Go
FileName: main.go
CodeFull:+372
// :glot
package main

import "fmt"

func main() {
	// :show start
	// create unbuffered channel of int values with capacity of 1
	ch := make(chan int)
	// start a new goroutine that sends value 3 over a channel
	go func() { ch <- 3 }()
	// read the value from a channel
	// it waits until goroutine above sends a value
	n := <-ch
	fmt.Printf("n: %d\n", n)
	// :show end
}
CodeToRun:+333
package main

import "fmt"

func main() {
	// create unbuffered channel of int values with capacity of 1
	ch := make(chan int)
	// start a new goroutine that sends value 3 over a channel
	go func() { ch <- 3 }()
	// read the value from a channel
	// it waits until goroutine above sends a value
	n := <-ch
	fmt.Printf("n: %d\n", n)
}
Output:+5
n: 3
66 1553595123949 glotid
Sha1: 65917487e32af83d83a19c1d7cbcf0e86c00bcbd
GlotID: fapbqw3tnd
2416 1553595125438 glotoutput
Sha1: 3b58865c58f1398700e9a0e9fd8edf508f5fdf34
Lang: Go
FileName: main.go
CodeFull:+1028
// :glot
package main

import "fmt"

func main() {
	// :show start
  fmt.Println("zero values for basic types:")

	var zeroBool bool
	fmt.Printf("bool:       %v\n", zeroBool)

	var zeroInt int
	fmt.Printf("int:        %v\n", zeroInt)

	var zeroF32 float32
	fmt.Printf("float32:    %v\n", zeroF32)

	var zeroF64 float64
	fmt.Printf("float64:    %v\n", zeroF64)

	var zeroStr string
	fmt.Printf("string:     %#v\n", zeroStr)

	var zeroPtr *int
	fmt.Printf("pointer:    %v\n", zeroPtr)

	var zeroSlice []uint32
	fmt.Printf("slice:      %v\n", zeroSlice)

	var zeroMap map[string]int
	fmt.Printf("map:        %#v\n", zeroMap)

	var zeroInterface interface{}
	fmt.Printf("interface:  %v\n", zeroInterface)

	var zeroChan chan bool
	fmt.Printf("channel:    %v\n", zeroChan)

	var zeroArray [5]int
	fmt.Printf("array:      %v\n", zeroArray)

	type struc struct {
		a int
		b string
	}
	var zeroStruct struc
	fmt.Printf("struct:     %#v\n", zeroStruct)

	var zeroFunc func(bool)
	fmt.Printf("function:   %v\n", zeroFunc)
	// :show end
}
CodeToRun:+989
package main

import "fmt"

func main() {
  fmt.Println("zero values for basic types:")

	var zeroBool bool
	fmt.Printf("bool:       %v\n", zeroBool)

	var zeroInt int
	fmt.Printf("int:        %v\n", zeroInt)

	var zeroF32 float32
	fmt.Printf("float32:    %v\n", zeroF32)

	var zeroF64 float64
	fmt.Printf("float64:    %v\n", zeroF64)

	var zeroStr string
	fmt.Printf("string:     %#v\n", zeroStr)

	var zeroPtr *int
	fmt.Printf("pointer:    %v\n", zeroPtr)

	var zeroSlice []uint32
	fmt.Printf("slice:      %v\n", zeroSlice)

	var zeroMap map[string]int
	fmt.Printf("map:        %#v\n", zeroMap)

	var zeroInterface interface{}
	fmt.Printf("interface:  %v\n", zeroInterface)

	var zeroChan chan bool
	fmt.Printf("channel:    %v\n", zeroChan)

	var zeroArray [5]int
	fmt.Printf("array:      %v\n", zeroArray)

	type struc struct {
		a int
		b string
	}
	var zeroStruct struc
	fmt.Printf("struct:     %#v\n", zeroStruct)

	var zeroFunc func(bool)
	fmt.Printf("function:   %v\n", zeroFunc)
}
Output:+281
zero values for basic types:
bool:       false
int:        0
float32:    0
float64:    0
string:     ""
pointer:    <nil>
slice:      []
map:        map[string]int(nil)
interface:  <nil>
channel:    <nil>
array:      [0 0 0 0 0]
struct:     main.struc{a:0, b:""}
function:   <nil>
66 1553595125611 glotid
Sha1: 3b58865c58f1398700e9a0e9fd8edf508f5fdf34
GlotID: fapbqx3gzc
1119 1553595126504 glotoutput
Sha1: 5e2075441bcce0bd59b1f50b3aa14d25d18a31b7
Lang: Go
FileName: main.go
CodeFull:+527
// :glot, no output
package main

func main() {
	// :show start
	// you can cast between numbers i.e. integers of various sizes and floating point numbers
	var i1 int32 = 3
	var i2 int = int(i1) // we must explicitly cast from int32 to int
	var f float64 = float64(i1)

	s := "string"
	// we can cast between string and []byte and vice-versa
	// note that unless optimizted by the compiler, this involves allocation
	var d []byte = []byte(s)
	// :show end

	_, _, _ = i2, f, d // silence compiler error about unused variables
}
CodeToRun:+477
package main

func main() {
	// you can cast between numbers i.e. integers of various sizes and floating point numbers
	var i1 int32 = 3
	var i2 int = int(i1) // we must explicitly cast from int32 to int
	var f float64 = float64(i1)

	s := "string"
	// we can cast between string and []byte and vice-versa
	// note that unless optimizted by the compiler, this involves allocation
	var d []byte = []byte(s)

	_, _, _ = i2, f, d // silence compiler error about unused variables
}
Output:+0
66 1553595126675 glotid
Sha1: 5e2075441bcce0bd59b1f50b3aa14d25d18a31b7
GlotID: fapbqxqae9
1481 1553595127627 glotoutput
Sha1: a1943efafdc94576101b04d4e7f7df42233b83ae
Lang: Go
FileName: main.go
CodeFull:+708
// :glot, no output
package main

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	// :show start
	// Basic variable declaration. Declares a variable of type specified on the right.
	// The variable is initialized to the zero value of the respective type.
	var x int
	var s string
	var p Person // Assuming type Person struct {}

	// Assignment of a value to a variable
	x = 3

	// Short declaration using := infers the type
	y := 4

	u := int64(100)    // declare variable of type int64 and init with 100
	var u2 int64 = 100 // declare variable of type int64 and init with 100
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _ = x, s, p, y, u, u2
}
CodeToRun:+658
package main

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	// Basic variable declaration. Declares a variable of type specified on the right.
	// The variable is initialized to the zero value of the respective type.
	var x int
	var s string
	var p Person // Assuming type Person struct {}

	// Assignment of a value to a variable
	x = 3

	// Short declaration using := infers the type
	y := 4

	u := int64(100)    // declare variable of type int64 and init with 100
	var u2 int64 = 100 // declare variable of type int64 and init with 100

	// silence compiler error about unused variables
	_, _, _, _, _, _ = x, s, p, y, u, u2
}
Output:+0
66 1553595127803 glotid
Sha1: a1943efafdc94576101b04d4e7f7df42233b83ae
GlotID: fapbqyefx8
1029 1553595128886 glotoutput
Sha1: 13101e39a354cc0f1dd6579311fee334edfc42f7
Lang: Go
FileName: main.go
CodeFull:+482
// :glot, no output
package main

func main() {
	// :show start
	// You can declare multiple variables of the same type in one line
	var a, b, c string

	var d, e string = "Hello", "world!"

	// You can also use short declaration to assign multiple variables
	x, y, z := 1, 2, 3

	foo, bar := 4, "stack" // `foo` is type `int`, `bar` is type `string`
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, x, y, z, foo, bar
}
CodeToRun:+432
package main

func main() {
	// You can declare multiple variables of the same type in one line
	var a, b, c string

	var d, e string = "Hello", "world!"

	// You can also use short declaration to assign multiple variables
	x, y, z := 1, 2, 3

	foo, bar := 4, "stack" // `foo` is type `int`, `bar` is type `string`

	// silence compiler error about unused variables
	_, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, x, y, z, foo, bar
}
Output:+0
66 1553595129056 glotid
Sha1: 13101e39a354cc0f1dd6579311fee334edfc42f7
GlotID: fapbqz5c1v
778 1553595130531 glotoutput
Sha1: e03c08fd09c5e2e757a7733e0679c25aee1cc619
Lang: Go
FileName: main.go
CodeFull:+339
// :glot
package main

import "fmt"

// :show start
func multipleReturn() (int, int) {
	return 1, 2
}

func multipleReturn2() (a int, b int) {
	a = 3
	b = 4
	return
}

func main() {
	x, y := multipleReturn()  // x = 1, y = 2
	w, z := multipleReturn2() // w = 3, z = 4
	fmt.Printf("x: %d, y: %d\nw: %d, z: %d\n", x, y, w, z)
	// :show end
}
CodeToRun:+301
package main

import "fmt"

func multipleReturn() (int, int) {
	return 1, 2
}

func multipleReturn2() (a int, b int) {
	a = 3
	b = 4
	return
}

func main() {
	x, y := multipleReturn()  // x = 1, y = 2
	w, z := multipleReturn2() // w = 3, z = 4
	fmt.Printf("x: %d, y: %d\nw: %d, z: %d\n", x, y, w, z)
}
Output:+22
x: 1, y: 2
w: 3, z: 4
66 1553595130703 glotid
Sha1: e03c08fd09c5e2e757a7733e0679c25aee1cc619
GlotID: fapbr04njv
599 1553595131759 glotoutput
Sha1: ef42399d54d601274d779745bacfb6d74cccdb84
Lang: Go
FileName: main.go
CodeFull:+260
// :glot
package main

import "fmt"

// :show start
func SumProduct(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	// only need the sum
	sum, _ := SumProduct(1, 2) // the product gets discarded
	fmt.Println(sum)           // -> 3
}

// :show end
CodeToRun:+223
package main

import "fmt"

func SumProduct(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	// only need the sum
	sum, _ := SumProduct(1, 2) // the product gets discarded
	fmt.Println(sum)           // -> 3
}
Output:+2
3
66 1553595131930 glotid
Sha1: ef42399d54d601274d779745bacfb6d74cccdb84
GlotID: fapbr0uzd6
633 1553595133764 glotoutput
Sha1: 4669fa1dbdf2d335b500505d9d91de552a52bf99
Lang: Go
FileName: main.go
CodeFull:+271
// :glot
package main

import "fmt"

// :show start
func main() {
	pets := []string{"dog", "cat", "fish"}

	// range returns both the current index and value
	// but sometimes we only need one or the other
	for _, pet := range pets {
		fmt.Println(pet)
	}
}

// :show end
CodeToRun:+234
package main

import "fmt"

func main() {
	pets := []string{"dog", "cat", "fish"}

	// range returns both the current index and value
	// but sometimes we only need one or the other
	for _, pet := range pets {
		fmt.Println(pet)
	}
}
Output:+13
dog
cat
fish
66 1553595133937 glotid
Sha1: 4669fa1dbdf2d335b500505d9d91de552a52bf99
GlotID: fapbr21zvl
1519 1553595134933 glotoutput
Sha1: 92d4cb28095371083b8074c16deb0ea9f290841a
Lang: Go
FileName: main.go
CodeFull:+694
// :glot, :allow error
package main

func main() {
	// :show start
	const untypedNumber = 345

	// if this was a variable declaration, untypedNumber would have its type
	// inferred as int.
	// since it's a const, it remains untyped until it's e.g. assigned to a variable
	var i int = untypedNumber      // no need to cast to int
	var u16 uint16 = untypedNumber // no need to cast to uint16
	var f float64 = untypedNumber  // no need to cast to float64

	// incompatible assignments are detected by the compiler
	// 345 is too big to fit in int8 and compiler detects that
	var b int8 = untypedNumber

	// :show end

	// silence compiler error about unused variables
	_, _, _, _ = i, u16, f, b
}
CodeToRun:+640
package main

func main() {
	const untypedNumber = 345

	// if this was a variable declaration, untypedNumber would have its type
	// inferred as int.
	// since it's a const, it remains untyped until it's e.g. assigned to a variable
	var i int = untypedNumber      // no need to cast to int
	var u16 uint16 = untypedNumber // no need to cast to uint16
	var f float64 = untypedNumber  // no need to cast to float64

	// incompatible assignments are detected by the compiler
	// 345 is too big to fit in int8 and compiler detects that
	var b int8 = untypedNumber

	// silence compiler error about unused variables
	_, _, _, _ = i, u16, f, b
}
Output:+69
# command-line-arguments
./main.go:15:6: constant 345 overflows int8
66 1553595135105 glotid
Sha1: 92d4cb28095371083b8074c16deb0ea9f290841a
GlotID: fapbr2r0vg
482 1553595136552 glotoutput
Sha1: 93542d33fa00f5f67f71601d392051ad67c56dbf
Lang: Go
FileName: main.go
CodeFull:+190
// :glot
package main

import "fmt"

func main() {
	// :show start
	const (
		Low = iota
		Medium
		High
	)
	fmt.Printf("Low: %d\nMedium: %d\nHigh: %d\n", Low, Medium, High)

	// :show end
}
CodeToRun:+151
package main

import "fmt"

func main() {
	const (
		Low = iota
		Medium
		High
	)
	fmt.Printf("Low: %d\nMedium: %d\nHigh: %d\n", Low, Medium, High)

}
Output:+25
Low: 0
Medium: 1
High: 2
66 1553595136723 glotid
Sha1: 93542d33fa00f5f67f71601d392051ad67c56dbf
GlotID: fapbr3pqvb
998 1553595138113 glotoutput
Sha1: f957e69e7d4a573fc605611959931313c3edb709
Lang: Go
FileName: main.go
CodeFull:+426
// :glot
package main

import "fmt"

func main() {
	// :show start
	const (
		Secure = 1 << iota // 0b001
		Authn              // 0b010
		Ready              // 0b100
	)

	ConnState := Secure | Authn // 0b011: Connection is secure and authenticated, but not yet Ready

	fmt.Printf(`Secure:    0x%x (0b%03b)
Authn:     0x%x (0b%03b)
ConnState: 0x%x (0b%03b)
`, Secure, Secure, Authn, Authn, ConnState, ConnState)
	// :show end
}
CodeToRun:+387
package main

import "fmt"

func main() {
	const (
		Secure = 1 << iota // 0b001
		Authn              // 0b010
		Ready              // 0b100
	)

	ConnState := Secure | Authn // 0b011: Connection is secure and authenticated, but not yet Ready

	fmt.Printf(`Secure:    0x%x (0b%03b)
Authn:     0x%x (0b%03b)
ConnState: 0x%x (0b%03b)
`, Secure, Secure, Authn, Authn, ConnState, ConnState)
}
Output:+69
Secure:    0x1 (0b001)
Authn:     0x2 (0b010)
ConnState: 0x3 (0b011)
66 1553595138286 glotid
Sha1: f957e69e7d4a573fc605611959931313c3edb709
GlotID: fapbr4n82t
736 1553595139685 glotoutput
Sha1: 9e25edcd534ff4f76131be006a03c658ac909e57
Lang: Go
FileName: main.go
CodeFull:+318
// :glot
package main

import "fmt"

func main() {
	// :show start
	const ( // iota is reset to 0
		a = 1 << iota // a == 1
		b = 1 << iota // b == 2
		c = 3         // c == 3  (iota is not used but still incremented)
		d = 1 << iota // d == 8
	)
	fmt.Printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d)
	// :show end
}
CodeToRun:+279
package main

import "fmt"

func main() {
	const ( // iota is reset to 0
		a = 1 << iota // a == 1
		b = 1 << iota // b == 2
		c = 3         // c == 3  (iota is not used but still incremented)
		d = 1 << iota // d == 8
	)
	fmt.Printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d)
}
Output:+23
a: 1, b: 2, c: 3, d: 8
66 1553595139865 glotid
Sha1: 9e25edcd534ff4f76131be006a03c658ac909e57
GlotID: fapbr5l3e6
498 1553595141075 glotoutput
Sha1: c5461f8fb6ac5a639af293015a5d5cdaebe1d898
Lang: Go
FileName: main.go
CodeFull:+205
// :glot
package main

import "fmt"

func main() {
	// :show start
	const (
		a = iota // a = 0
		_        // iota is incremented
		b        // b = 2a
	)
	fmt.Printf("a: %d, b: %d\n", a, b)
	// :show end
}
CodeToRun:+166
package main

import "fmt"

func main() {
	const (
		a = iota // a = 0
		_        // iota is incremented
		b        // b = 2a
	)
	fmt.Printf("a: %d, b: %d\n", a, b)
}
Output:+11
a: 0, b: 2
66 1553595141279 glotid
Sha1: c5461f8fb6ac5a639af293015a5d5cdaebe1d898
GlotID: fapbr6eqpo
1013 1553595142769 glotoutput
Sha1: b5f001783b61983333b8b96e409c8c59900fd966
Lang: Go
FileName: main.go
CodeFull:+448
// :glot
package main

import "fmt"

func main() {
	// :show start
	const (
		bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0
		bit1, mask1                          // bit1 == 2, mask1 == 1
		_, _                                 // skips iota == 2
		bit3, mask3                          // bit3 == 8, mask3 == 7
	)
	fmt.Printf("bit0: %d, mask0: 0x%x\n", bit0, mask0)
	fmt.Printf("bit3: %d, mask3: 0x%x\n", bit3, mask3)
	// :show end
}
CodeToRun:+409
package main

import "fmt"

func main() {
	const (
		bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0
		bit1, mask1                          // bit1 == 2, mask1 == 1
		_, _                                 // skips iota == 2
		bit3, mask3                          // bit3 == 8, mask3 == 7
	)
	fmt.Printf("bit0: %d, mask0: 0x%x\n", bit0, mask0)
	fmt.Printf("bit3: %d, mask3: 0x%x\n", bit3, mask3)
}
Output:+40
bit0: 1, mask0: 0x0
bit3: 8, mask3: 0x7
66 1553595142943 glotid
Sha1: b5f001783b61983333b8b96e409c8c59900fd966
GlotID: fapbr7f2e7
627 1553595143941 glotoutput
Sha1: 5aae5c5fb5a4e6341ccabf9f506439c514dee1dc
Lang: Go
FileName: main.go
CodeFull:+271
// :glot
package main

import "fmt"

func main() {
	// :show start
	type ByteSize int

	const (
		_           = iota // ignore first value by assigning to blank identifier
		KB ByteSize = 1 << (10 * iota)
		MB
		GB
		TB
		PB
	)
	fmt.Printf("KB: %d\n", KB)
	// :show end
}
CodeToRun:+232
package main

import "fmt"

func main() {
	type ByteSize int

	const (
		_           = iota // ignore first value by assigning to blank identifier
		KB ByteSize = 1 << (10 * iota)
		MB
		GB
		TB
		PB
	)
	fmt.Printf("KB: %d\n", KB)
}
Output:+9
KB: 1024
66 1553595144112 glotid
Sha1: 5aae5c5fb5a4e6341ccabf9f506439c514dee1dc
GlotID: fapbr846fm
925 1553595145375 glotoutput
Sha1: c64e87c1f9fb0bda74531b22ef528fd874061af0
Lang: Go
FileName: main.go
CodeFull:+385
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "where hello is?"
	toFind := "hello"
	idx := strings.Index(s, toFind)
	fmt.Printf("'%s' is in s starting at position %d\n", toFind, idx)

	// when string is not found, result is -1
	idx = strings.Index(s, "not present")
	fmt.Printf("Index of non-existent substring is: %d\n", idx)
	// :show end
}
CodeToRun:+346
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "where hello is?"
	toFind := "hello"
	idx := strings.Index(s, toFind)
	fmt.Printf("'%s' is in s starting at position %d\n", toFind, idx)

	// when string is not found, result is -1
	idx = strings.Index(s, "not present")
	fmt.Printf("Index of non-existent substring is: %d\n", idx)
}
Output:+78
'hello' is in s starting at position 6
Index of non-existent substring is: -1
66 1553595145549 glotid
Sha1: c64e87c1f9fb0bda74531b22ef528fd874061af0
GlotID: fapbr8ywxz
669 1553595146911 glotoutput
Sha1: 430a7678584716e8c6a18c7942610aa1fc64d2c1
Lang: Go
FileName: main.go
CodeFull:+268
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "hello and second hello"
	toFind := "hello"
	idx := strings.LastIndex(s, toFind)
	fmt.Printf("when searching from end, '%s' is in s at position %d\n", toFind, idx)
	// :show end
}
CodeToRun:+229
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "hello and second hello"
	toFind := "hello"
	idx := strings.LastIndex(s, toFind)
	fmt.Printf("when searching from end, '%s' is in s at position %d\n", toFind, idx)
}
Output:+56
when searching from end, 'hello' is in s at position 17
66 1553595147086 glotid
Sha1: 430a7678584716e8c6a18c7942610aa1fc64d2c1
GlotID: fapbr9vv72
890 1553595148164 glotoutput
Sha1: 85c817a6388349fc708ad8dd295991501cc99afe
Lang: Go
FileName: main.go
CodeFull:+368
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "first is, second is, third is"
	toFind := "is"
	currStart := 0
	for {
		idx := strings.Index(s, toFind)
		if idx == -1 {
			break
		}
		fmt.Printf("found '%s' at position %d\n", toFind, currStart+idx)
		currStart += idx + len(toFind)
		s = s[idx+len(toFind):]
	}
	// :show end
}
CodeToRun:+329
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "first is, second is, third is"
	toFind := "is"
	currStart := 0
	for {
		idx := strings.Index(s, toFind)
		if idx == -1 {
			break
		}
		fmt.Printf("found '%s' at position %d\n", toFind, currStart+idx)
		currStart += idx + len(toFind)
		s = s[idx+len(toFind):]
	}
}
Output:+77
found 'is' at position 6
found 'is' at position 17
found 'is' at position 27
66 1553595148339 glotid
Sha1: 85c817a6388349fc708ad8dd295991501cc99afe
GlotID: fapbramq4y
694 1553595149408 glotoutput
Sha1: 06a4a67d4688d8677c68fcca39d1ee4744f8ca13
Lang: Go
FileName: main.go
CodeFull:+291
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "is hello there?"
	toFind := "hello"
	if strings.Contains(s, toFind) {
		fmt.Printf("'%s' contains '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't contain '%s'\n", s, toFind)
	}
	// :show end
}
CodeToRun:+252
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "is hello there?"
	toFind := "hello"
	if strings.Contains(s, toFind) {
		fmt.Printf("'%s' contains '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't contain '%s'\n", s, toFind)
	}
}
Output:+35
'is hello there?' contains 'hello'
66 1553595149582 glotid
Sha1: 06a4a67d4688d8677c68fcca39d1ee4744f8ca13
GlotID: fapbrbdfjh
705 1553595150597 glotoutput
Sha1: 22d8e3e2774cd4f1698335e67bfabfb07b481b7a
Lang: Go
FileName: main.go
CodeFull:+296
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "this"
	if strings.HasPrefix(s, toFind) {
		fmt.Printf("'%s' starts with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't start with '%s'\n", s, toFind)
	}
	// :show end
}
CodeToRun:+257
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "this is string"
	toFind := "this"
	if strings.HasPrefix(s, toFind) {
		fmt.Printf("'%s' starts with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't start with '%s'\n", s, toFind)
	}
}
Output:+36
'this is string' starts with 'this'
66 1553595150769 glotid
Sha1: 22d8e3e2774cd4f1698335e67bfabfb07b481b7a
GlotID: fapbrc2v4p
701 1553595151825 glotoutput
Sha1: 3dc9572b703ec6964918fa3d3a80cdee91706256
Lang: Go
FileName: main.go
CodeFull:+294
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "string"
	if strings.HasSuffix(s, toFind) {
		fmt.Printf("'%s' ends with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't end with '%s'\n", s, toFind)
	}
	// :show end
}
CodeToRun:+255
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "this is string"
	toFind := "string"
	if strings.HasSuffix(s, toFind) {
		fmt.Printf("'%s' ends with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't end with '%s'\n", s, toFind)
	}
}
Output:+36
'this is string' ends with 'string'
66 1553595151995 glotid
Sha1: 3dc9572b703ec6964918fa3d3a80cdee91706256
GlotID: fapbrct58f
725 1553595153054 glotoutput
Sha1: c5743d21ed1f110ac003f047850d43b068e5dabe
Lang: Go
FileName: main.go
CodeFull:+303
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s1 := "gone"
	s2 := "GoNe"
	if strings.EqualFold(s1, s2) {
		fmt.Printf("'%s' is equal '%s' when ignoring case\n", s1, s2)
	} else {
		fmt.Printf("'%s' is not equal '%s' when ignoring case\n", s1, s2)
	}
	// :show end
}
CodeToRun:+264
package main

import (
	"fmt"
	"strings"
)

func main() {
	s1 := "gone"
	s2 := "GoNe"
	if strings.EqualFold(s1, s2) {
		fmt.Printf("'%s' is equal '%s' when ignoring case\n", s1, s2)
	} else {
		fmt.Printf("'%s' is not equal '%s' when ignoring case\n", s1, s2)
	}
}
Output:+42
'gone' is equal 'GoNe' when ignoring case
66 1553595153225 glotid
Sha1: c5743d21ed1f110ac003f047850d43b068e5dabe
GlotID: fapbrdjibu
1263 1553595154497 glotoutput
Sha1: 8536b7224b8c7c3853c636ac1c14ba34ece99b13
Lang: Go
FileName: main.go
CodeFull:+555
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	s1 := "string one"
	s2 := "string two"

	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	if s1 == s1 {
		fmt.Printf("s1 is equal to s1\n")
	} else {
		fmt.Printf("inconcivable! s1 is not equal to itself\n")
	}

	if s1 > s2 {
		fmt.Printf("s1 is > than s2\n")
	} else {
		fmt.Printf("s1 is not > than s2\n")
	}

	if s1 < s2 {
		fmt.Printf("s1 is < than s2\n")
	} else {
		fmt.Printf("s1 is not < than s2\n")
	}
	// :show end
}
CodeToRun:+516
package main

import (
	"fmt"
)

func main() {
	s1 := "string one"
	s2 := "string two"

	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	if s1 == s1 {
		fmt.Printf("s1 is equal to s1\n")
	} else {
		fmt.Printf("inconcivable! s1 is not equal to itself\n")
	}

	if s1 > s2 {
		fmt.Printf("s1 is > than s2\n")
	} else {
		fmt.Printf("s1 is not > than s2\n")
	}

	if s1 < s2 {
		fmt.Printf("s1 is < than s2\n")
	} else {
		fmt.Printf("s1 is not < than s2\n")
	}
}
Output:+76
s1 is not equal to s2
s1 is equal to s1
s1 is not > than s2
s1 is < than s2
66 1553595154668 glotid
Sha1: 8536b7224b8c7c3853c636ac1c14ba34ece99b13
GlotID: fapbreeg4h
710 1553595155818 glotoutput
Sha1: 99cfeac8925ef1c4ac2baeb788ca909b28ff6e9c
Lang: Go
FileName: main.go
CodeFull:+279
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "Mixed Case"
	fmt.Printf("ToLower(s): '%s'\n", strings.ToLower(s))
	fmt.Printf("ToUpper(s): '%s'\n", strings.ToUpper(s))
	fmt.Printf("ToTitle(s): '%s'\n", strings.ToTitle(s))
	// :show end
}
CodeToRun:+240
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "Mixed Case"
	fmt.Printf("ToLower(s): '%s'\n", strings.ToLower(s))
	fmt.Printf("ToUpper(s): '%s'\n", strings.ToUpper(s))
	fmt.Printf("ToTitle(s): '%s'\n", strings.ToTitle(s))
}
Output:+75
ToLower(s): 'mixed case'
ToUpper(s): 'MIXED CASE'
ToTitle(s): 'MIXED CASE'
66 1553595155990 glotid
Sha1: 99cfeac8925ef1c4ac2baeb788ca909b28ff6e9c
GlotID: fapbrf6rai
2145 1553595157246 glotoutput
Sha1: 9a45537f8a22d70f2fdb398221ac44061d6c3ee2
Lang: Go
FileName: main.go
CodeFull:+925
// :glot
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	s := "234"
	i, err := strconv.Atoi(s)
	if err != nil {
		fmt.Printf("strconv.Atoi() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.Atoi('%s'): %d\n", s, i)

	i, err = strconv.Atoi("not a number")
	if err != nil {
		fmt.Printf("strconv.Atoi('not a number') failed with: '%s'\n", err)
	}

	i64, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Printf("strconv.ParseInt() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseInt('%s', 64): %d\n", s, i64)

	s = "-3.234"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		fmt.Printf("strconv.ParseFloat() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseFloat('%s', 64): %g\n", s, f64)

	var f2 float64
	_, err = fmt.Sscanf(s, "%f", &f2)
	if err != nil {
		fmt.Printf("fmt.Sscanf() failed with: '%s'\n", err)
	}
	fmt.Printf("fmt.Sscanf(): %g\n", f2)
	// :show end
}
CodeToRun:+886
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "234"
	i, err := strconv.Atoi(s)
	if err != nil {
		fmt.Printf("strconv.Atoi() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.Atoi('%s'): %d\n", s, i)

	i, err = strconv.Atoi("not a number")
	if err != nil {
		fmt.Printf("strconv.Atoi('not a number') failed with: '%s'\n", err)
	}

	i64, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Printf("strconv.ParseInt() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseInt('%s', 64): %d\n", s, i64)

	s = "-3.234"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		fmt.Printf("strconv.ParseFloat() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseFloat('%s', 64): %g\n", s, f64)

	var f2 float64
	_, err = fmt.Sscanf(s, "%f", &f2)
	if err != nil {
		fmt.Printf("fmt.Sscanf() failed with: '%s'\n", err)
	}
	fmt.Printf("fmt.Sscanf(): %g\n", f2)
}
Output:+217
strconv.Atoi('234'): 234
strconv.Atoi('not a number') failed with: 'strconv.Atoi: parsing "not a number": invalid syntax'
strconv.ParseInt('234', 64): 234
strconv.ParseFloat('-3.234', 64): -3.234
fmt.Sscanf(): -3.234
66 1553595157419 glotid
Sha1: 9a45537f8a22d70f2fdb398221ac44061d6c3ee2
GlotID: fapbrg1dlz
1648 1553595158427 glotoutput
Sha1: 035ee6001d16c52073f189307a33ada12e1d9b0c
Lang: Go
FileName: main.go
CodeFull:+680
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "  str  "
	fmt.Printf("TrimSpace('%s'): '%s'\n\n", s, strings.TrimSpace(s))

	s = "abacdda"
	cutset := "ab"
	fmt.Printf("Trim('%s', '%s'): '%s'\n\n", s, cutset, strings.Trim(s, cutset))

	fmt.Printf("TrimLeft('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimLeft(s, cutset))

	fmt.Printf("TrimRight('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimRight(s, cutset))

	suffix := "ab"
	fmt.Printf("TrimSuffix('%s', '%s'): '%s'\n\n", s, suffix, strings.TrimSuffix(s, suffix))

	prefix := "ab"
	fmt.Printf("TrimPrefix('%s', '%s'): '%s'\n\n", s, prefix, strings.TrimPrefix(s, prefix))
	// :show end
}
CodeToRun:+641
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "  str  "
	fmt.Printf("TrimSpace('%s'): '%s'\n\n", s, strings.TrimSpace(s))

	s = "abacdda"
	cutset := "ab"
	fmt.Printf("Trim('%s', '%s'): '%s'\n\n", s, cutset, strings.Trim(s, cutset))

	fmt.Printf("TrimLeft('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimLeft(s, cutset))

	fmt.Printf("TrimRight('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimRight(s, cutset))

	suffix := "ab"
	fmt.Printf("TrimSuffix('%s', '%s'): '%s'\n\n", s, suffix, strings.TrimSuffix(s, suffix))

	prefix := "ab"
	fmt.Printf("TrimPrefix('%s', '%s'): '%s'\n\n", s, prefix, strings.TrimPrefix(s, prefix))
}
Output:+210
TrimSpace('  str  '): 'str'

Trim('abacdda', 'ab'): 'cdd'

TrimLeft('abacdda', 'ab'): 'cdda'

TrimRight('abacdda', 'ab'): 'abacdd'

TrimSuffix('abacdda', 'ab'): 'abacdda'

TrimPrefix('abacdda', 'ab'): 'acdda'

66 1553595158718 glotid
Sha1: 035ee6001d16c52073f189307a33ada12e1d9b0c
GlotID: fapbrgqno7
613 1553595159905 glotoutput
Sha1: 5c6bc8cc4b09b7564398fd2d42522a2dd0260898
Lang: Go
FileName: main.go
CodeFull:+236
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is a string"
	a := strings.Split(s, " ")
	fmt.Printf("a: %#v\n", a)

	s2 := strings.Join(a, ",")
	fmt.Printf("s2: %#v\n", s2)
	// :show end
}
CodeToRun:+197
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "this is a string"
	a := strings.Split(s, " ")
	fmt.Printf("a: %#v\n", a)

	s2 := strings.Join(a, ",")
	fmt.Printf("s2: %#v\n", s2)
}
Output:+64
a: []string{"this", "is", "a", "string"}
s2: "this,is,a,string"
66 1553595160086 glotid
Sha1: 5c6bc8cc4b09b7564398fd2d42522a2dd0260898
GlotID: fapbrhmk71
553 1553595161286 glotoutput
Sha1: 179105e3e31b8eeaf8bea81e0bb4fd9677a6a253
Lang: Go
FileName: main.go
CodeFull:+221
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	s := fmt.Sprintf("Hello %s", "World")
	fmt.Printf("s: '%s'\n", s)
	s = fmt.Sprintf("%d + %f = %d", 2, float64(3), 5)
	fmt.Println(s)
	// :show end
}
CodeToRun:+182
package main

import (
	"fmt"
)

func main() {
	s := fmt.Sprintf("Hello %s", "World")
	fmt.Printf("s: '%s'\n", s)
	s = fmt.Sprintf("%d + %f = %d", 2, float64(3), 5)
	fmt.Println(s)
}
Output:+34
s: 'Hello World'
2 + 3.000000 = 5
66 1553595161466 glotid
Sha1: 179105e3e31b8eeaf8bea81e0bb4fd9677a6a253
GlotID: fapbrig1s5
1164 1553595162610 glotoutput
Sha1: 5f51ce0fa44948759f808c7586bdf5b65c12afe0
Lang: Go
FileName: main.go
CodeFull:+506
// :glot
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	// extract int and float from a string
	s := "48 123.45"
	var f float64
	var i int
	nParsed, err := fmt.Sscanf(s, "%d %f", &i, &f)
	if err != nil {
		log.Fatalf("first fmt.Sscanf failed with %s\n", err)
	}
	fmt.Printf("i: %d, f: %f, extracted %d values\n", i, f, nParsed)

	var i2 int
	_, err = fmt.Sscanf(s, "%d %f %d", &i, &f, &i2)
	if err != nil {
		fmt.Printf("second fmt.Sscanf failed with %s\n", err)
	}

	// :show end
}
CodeToRun:+467
package main

import (
	"fmt"
	"log"
)

func main() {
	// extract int and float from a string
	s := "48 123.45"
	var f float64
	var i int
	nParsed, err := fmt.Sscanf(s, "%d %f", &i, &f)
	if err != nil {
		log.Fatalf("first fmt.Sscanf failed with %s\n", err)
	}
	fmt.Printf("i: %d, f: %f, extracted %d values\n", i, f, nParsed)

	var i2 int
	_, err = fmt.Sscanf(s, "%d %f %d", &i, &f, &i2)
	if err != nil {
		fmt.Printf("second fmt.Sscanf failed with %s\n", err)
	}

}
Output:+75
i: 48, f: 123.450000, extracted 2 values
second fmt.Sscanf failed with EOF
66 1553595162782 glotid
Sha1: 5f51ce0fa44948759f808c7586bdf5b65c12afe0
GlotID: fapbrj8c72
491 1553595164012 glotoutput
Sha1: 6573072b34e5789fbf91cbcf7efc992de527e765
Lang: Go
FileName: main.go
CodeFull:+185
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this,. is,. a,. string"
	a := strings.Split(s, ",.")
	fmt.Printf("a: %#v\n", a)
	// :show end
}
CodeToRun:+146
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "this,. is,. a,. string"
	a := strings.Split(s, ",.")
	fmt.Printf("a: %#v\n", a)
}
Output:+44
a: []string{"this", " is", " a", " string"}
66 1553595164184 glotid
Sha1: 6573072b34e5789fbf91cbcf7efc992de527e765
GlotID: fapbrk2eq3
538 1553595165525 glotoutput
Sha1: 925255597c5f757db4e473781cb796c9641f57a6
Lang: Go
FileName: main.go
CodeFull:+215
// :glot
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "original string original"
	s2 := strings.Replace(s, "original", "replaced", -1)
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}
CodeToRun:+176
package main

import (
	"fmt"
	"strings"
)

func main() {
	s := "original string original"
	s2 := strings.Replace(s, "original", "replaced", -1)
	fmt.Printf("s2: '%s'\n", s2)
}
Output:+31
s2: 'replaced string replaced'
66 1553595165697 glotid
Sha1: 925255597c5f757db4e473781cb796c9641f57a6
GlotID: fapbrkytgx
592 1553595167285 glotoutput
Sha1: 80f9f63400d0835d5ff8a3a4987360f41f92cb47
Lang: Go
FileName: main.go
CodeFull:+242
// :glot
package main

import (
	"fmt"
	"regexp"
)

func main() {
	// :show start
	s := "original string original"
	rx := regexp.MustCompile("(?U)or.*al")
	s2 := rx.ReplaceAllString(s, "replaced")
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}
CodeToRun:+203
package main

import (
	"fmt"
	"regexp"
)

func main() {
	s := "original string original"
	rx := regexp.MustCompile("(?U)or.*al")
	s2 := rx.ReplaceAllString(s, "replaced")
	fmt.Printf("s2: '%s'\n", s2)
}
Output:+31
s2: 'replaced string replaced'
66 1553595167460 glotid
Sha1: 80f9f63400d0835d5ff8a3a4987360f41f92cb47
GlotID: fapbrm0mbq
1257 1553595168927 glotoutput
Sha1: 8c348b8c1d7b961723a893c4fdda63b5bddd47fc
Lang: Go
FileName: main.go
CodeFull:+581
// :glot, :name main.go
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

// :show start
// ReadFileAsLines reads a file and splits it into lines
func ReadFileAsLines(path string) ([]string, error) {
	d, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := string(d)
	lines := strings.Split(s, "\n")
	return lines, nil
}

// :show end

func main() {
	path := "main.go"
	lines, err := ReadFileAsLines(path)
	if err != nil {
		log.Fatalf("ReadFileAsLines() failed with '%s'\n", err)
	}
	fmt.Printf("There are %d lines in '%s'\n", len(lines), path)
}
CodeToRun:+528
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

// ReadFileAsLines reads a file and splits it into lines
func ReadFileAsLines(path string) ([]string, error) {
	d, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := string(d)
	lines := strings.Split(s, "\n")
	return lines, nil
}

func main() {
	path := "main.go"
	lines, err := ReadFileAsLines(path)
	if err != nil {
		log.Fatalf("ReadFileAsLines() failed with '%s'\n", err)
	}
	fmt.Printf("There are %d lines in '%s'\n", len(lines), path)
}
Output:+32
There are 28 lines in 'main.go'
66 1553595169113 glotid
Sha1: 8c348b8c1d7b961723a893c4fdda63b5bddd47fc
GlotID: fapbrmzq2d
1718 1553595170235 glotoutput
Sha1: b123889da54e42b9e103e88004c2422ea9d2d963
Lang: Go
FileName: main.go
CodeFull:+816
// :glot, :file main.go
package main

import (
  "fmt"
  "os"
  "bufio"
)

// :show start
func IterLinesInFile(filePath string, process func (s string) bool) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()
    scanner := bufio.NewScanner(file)
    // Scan() reads next line and returns false when reached end or error
    for scanner.Scan() {
        line := scanner.Text()
        if !process(line) {
          return nil
        }
        // process the line
    }
    // check if Scan() finished because of error or because it reached end of file
    return scanner.Err()
}
// :show end

func main() {
  nLines := 0
  IterLinesInFile("main.go", func(s string) bool {
    nLines++
    return true
  })
  fmt.Printf("%d lines in 'main.go'\n", nLines)
}
CodeToRun:+764
package main

import (
  "fmt"
  "os"
  "bufio"
)

func IterLinesInFile(filePath string, process func (s string) bool) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()
    scanner := bufio.NewScanner(file)
    // Scan() reads next line and returns false when reached end or error
    for scanner.Scan() {
        line := scanner.Text()
        if !process(line) {
          return nil
        }
        // process the line
    }
    // check if Scan() finished because of error or because it reached end of file
    return scanner.Err()
}

func main() {
  nLines := 0
  IterLinesInFile("main.go", func(s string) bool {
    nLines++
    return true
  })
  fmt.Printf("%d lines in 'main.go'\n", nLines)
}
Output:+22
35 lines in 'main.go'
66 1553595170406 glotid
Sha1: b123889da54e42b9e103e88004c2422ea9d2d963
GlotID: fapbrnrquw
1112 1553595171691 glotoutput
Sha1: 6aa09cf12a1f4c21b089711b10ee896b9bb208b3
Lang: Go
FileName: main.go
CodeFull:+511
// :glot
package main

import (
	"bytes"
	"fmt"
)

// :show start
// NormalizeNewlines normalizes \r\n (windows) and \r (mac)
// into \n (unix)
func NormalizeNewlines(d []byte) []byte {
	// replace CR LF \r\n (windows) with LF \n (unix)
	d = bytes.Replace(d, []byte{13, 10}, []byte{10}, -1)
	// replace CF \r (mac) with LF \n (unix)
	d = bytes.Replace(d, []byte{13}, []byte{10}, -1)
	return d
}

// :show end

func main() {
	d := []byte("new\r\nline")
	d = NormalizeNewlines(d)
	fmt.Printf("%#v\n", string(d))
}
CodeToRun:+473
package main

import (
	"bytes"
	"fmt"
)

// NormalizeNewlines normalizes \r\n (windows) and \r (mac)
// into \n (unix)
func NormalizeNewlines(d []byte) []byte {
	// replace CR LF \r\n (windows) with LF \n (unix)
	d = bytes.Replace(d, []byte{13, 10}, []byte{10}, -1)
	// replace CF \r (mac) with LF \n (unix)
	d = bytes.Replace(d, []byte{13}, []byte{10}, -1)
	return d
}

func main() {
	d := []byte("new\r\nline")
	d = NormalizeNewlines(d)
	fmt.Printf("%#v\n", string(d))
}
Output:+12
"new\nline"
66 1553595171896 glotid
Sha1: 6aa09cf12a1f4c21b089711b10ee896b9bb208b3
GlotID: fapbromzz7
1571 1553595173228 glotoutput
Sha1: d9c6cd9f911cdb122c85d9a2d9f9b7162498f3f4
Lang: Go
FileName: main.go
CodeFull:+753
// :glot, no output
package main

// :show start

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

// :show end

func main() {
}
CodeToRun:+703
package main

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
}
Output:+0
66 1553595173402 glotid
Sha1: d9c6cd9f911cdb122c85d9a2d9f9b7162498f3f4
GlotID: fapbrpjz8l
2476 1553595174864 glotoutput
Sha1: eeb99816cfe57bd74a378a399eed694a8c9ef061
Lang: Go
FileName: main.go
CodeFull:+1171
// :glot
package main

import "fmt"

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	// :show start
	i := 1
	fmt.Println("initial:", i)

	zeroval(i)
	fmt.Println("zeroval:", i)
	// `i` is still equal to 1 because `zeroval` edited
	// a "copy" of `i`, not the original.

	// The `&i` syntax gives the memory address of `i`,
	// i.e. a pointer to `i`. When calling `zeroptr`,
	// it will edit the "original" `i`.
	zeroptr(&i)
	fmt.Println("zeroptr:", i)

	// Pointers can be printed too.
	fmt.Println("pointer:", &i)
	// :show end
}
CodeToRun:+1132
package main

import "fmt"

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	i := 1
	fmt.Println("initial:", i)

	zeroval(i)
	fmt.Println("zeroval:", i)
	// `i` is still equal to 1 because `zeroval` edited
	// a "copy" of `i`, not the original.

	// The `&i` syntax gives the memory address of `i`,
	// i.e. a pointer to `i`. When calling `zeroptr`,
	// it will edit the "original" `i`.
	zeroptr(&i)
	fmt.Println("zeroptr:", i)

	// Pointers can be printed too.
	fmt.Println("pointer:", &i)
}
Output:+55
initial: 1
zeroval: 1
zeroptr: 0
pointer: 0xc42006c010
66 1553595175038 glotid
Sha1: eeb99816cfe57bd74a378a399eed694a8c9ef061
GlotID: fapbrqj27s
1094 1553595176913 glotoutput
Sha1: a10a0a690ada4f1eaaa35ffae6b782ded38b9a36
Lang: Go
FileName: main.go
CodeFull:+490
// :glot
package main

import "fmt"

// :show start
type Person struct {
	Name string
}

func main() {
	c := new(Person) // returns pointer
	c.Name = "Catherine"
	fmt.Println(c.Name) // prints: Catherine
	d := c
	d.Name = "Daniel"
	fmt.Println(c.Name) // prints: Daniel
	// Adding an Asterix before a pointer dereferences the pointer
	i := *d
	i.Name = "Ines"
	fmt.Println(c.Name) // prints: Daniel
	fmt.Println(d.Name) // prints: Daniel
	fmt.Println(i.Name) // prints: Ines
	// :show end
}
CodeToRun:+452
package main

import "fmt"

type Person struct {
	Name string
}

func main() {
	c := new(Person) // returns pointer
	c.Name = "Catherine"
	fmt.Println(c.Name) // prints: Catherine
	d := c
	d.Name = "Daniel"
	fmt.Println(c.Name) // prints: Daniel
	// Adding an Asterix before a pointer dereferences the pointer
	i := *d
	i.Name = "Ines"
	fmt.Println(c.Name) // prints: Daniel
	fmt.Println(d.Name) // prints: Daniel
	fmt.Println(i.Name) // prints: Ines
}
Output:+36
Catherine
Daniel
Daniel
Daniel
Ines
66 1553595177086 glotid
Sha1: a10a0a690ada4f1eaaa35ffae6b782ded38b9a36
GlotID: fapbrrqy1n
1174 1553595178551 glotoutput
Sha1: 5a827f2536ee8f3bb1be5b955dde6de7eb440cd2
Lang: Go
FileName: main.go
CodeFull:+526
// :glot
package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f *Foo) Increment() {
	f.Bar++
}

func main() {
	var f Foo

	// Calling `f.Increment` is automatically changed to `(&f).Increment` by the compiler.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	f.Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)

	// As you can see, calling `(&f).Increment` directly does the same thing.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	(&f).Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)
}

// :show end
CodeToRun:+489
package main

import "fmt"

type Foo struct {
	Bar int
}

func (f *Foo) Increment() {
	f.Bar++
}

func main() {
	var f Foo

	// Calling `f.Increment` is automatically changed to `(&f).Increment` by the compiler.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	f.Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)

	// As you can see, calling `(&f).Increment` directly does the same thing.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	(&f).Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)
}
Output:+44
f.Bar is 0
f.Bar is 1
f.Bar is 0
f.Bar is 1
66 1553595178724 glotid
Sha1: 5a827f2536ee8f3bb1be5b955dde6de7eb440cd2
GlotID: fapbrsq1dk
1462 1553595179985 glotoutput
Sha1: 1a6590b3dcee095a2b31c9d04370acb3a3cd2a8f
Lang: Go
FileName: main.go
CodeFull:+664
// :glot
package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f Foo) Increment() {
	f.Bar++
}

func main() {
	var p *Foo

	// Calling `p.Increment` is automatically changed to `(*p).Increment` by the compiler.
	// (Note that `*p` is going to remain at 0 because a copy of `*p`, and not the original `*p` are being edited)
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	p.Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)

	// As you can see, calling `(*p).Increment` directly does the same thing.
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	(*p).Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
}

// :show end
CodeToRun:+627
package main

import "fmt"

type Foo struct {
	Bar int
}

func (f Foo) Increment() {
	f.Bar++
}

func main() {
	var p *Foo

	// Calling `p.Increment` is automatically changed to `(*p).Increment` by the compiler.
	// (Note that `*p` is going to remain at 0 because a copy of `*p`, and not the original `*p` are being edited)
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	p.Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)

	// As you can see, calling `(*p).Increment` directly does the same thing.
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	(*p).Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
}
Output:+56
(*p).Bar is 0
(*p).Bar is 0
(*p).Bar is 0
(*p).Bar is 0
66 1553595180165 glotid
Sha1: 1a6590b3dcee095a2b31c9d04370acb3a3cd2a8f
GlotID: fapbrtkseg
3385 1553595181747 glotoutput
Sha1: 5d9cd0c6b04f137c78238d0df8a42bde253ff1db
Lang: Go
FileName: main.go
CodeFull:+1543
// :glot
package main

import "fmt"

func main() {
	// :show start
	// Creating arrays of 6 elements of type int,
	// and put elements 1, 2, 3, 4, 5 and 6 inside it, in this exact order:
	var array1 = [6]int{1, 2, 3, 4, 5, 6}   // classical way
	var array2 = [6]int{1, 2, 3, 4, 5, 6}   // a less verbose way
	var array3 = [...]int{1, 2, 3, 4, 5, 6} // the compiler will count the array elements by itself

	fmt.Println("array1:", array1) // > [1 2 3 4 5 6]
	fmt.Println("array2:", array2) // > [1 2 3 4 5 6]
	fmt.Println("array3:", array3) // > [1 2 3 4 5 6]

	// Creating arrays with default values inside:
	zeros := [8]int{}       // Create a list of 8 int filled with 0
	ptrs := [8]*int{}       // a list of int pointers, filled with 8 nil references ( <nil> )
	emptystr := [8]string{} // a list of string filled with 8 times ""

	fmt.Println("zeroes:", zeros)      // > [0 0 0 0 0 0 0 0]
	fmt.Println("ptrs:", ptrs)         // > [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]
	fmt.Println("emptystr:", emptystr) // > [       ]
	// values are empty strings, separated by spaces,
	// so we can just see separating spaces

	// Arrays are also working with a personalized type
	type Data struct {
		Number int
		Text   string
	}

	// Creating an array with 8 'Data' elements
	// All the 8 elements will be like {0, ""} (Number = 0, Text = "")
	structs := [8]Data{}

	fmt.Println("structs:", structs) // > [{0 } {0 } {0 } {0 } {0 } {0 } {0 } {0 }]
	// prints {0 } because Number are 0 and Text are empty; separated by a space
	// :show end
}
CodeToRun:+1504
package main

import "fmt"

func main() {
	// Creating arrays of 6 elements of type int,
	// and put elements 1, 2, 3, 4, 5 and 6 inside it, in this exact order:
	var array1 = [6]int{1, 2, 3, 4, 5, 6}   // classical way
	var array2 = [6]int{1, 2, 3, 4, 5, 6}   // a less verbose way
	var array3 = [...]int{1, 2, 3, 4, 5, 6} // the compiler will count the array elements by itself

	fmt.Println("array1:", array1) // > [1 2 3 4 5 6]
	fmt.Println("array2:", array2) // > [1 2 3 4 5 6]
	fmt.Println("array3:", array3) // > [1 2 3 4 5 6]

	// Creating arrays with default values inside:
	zeros := [8]int{}       // Create a list of 8 int filled with 0
	ptrs := [8]*int{}       // a list of int pointers, filled with 8 nil references ( <nil> )
	emptystr := [8]string{} // a list of string filled with 8 times ""

	fmt.Println("zeroes:", zeros)      // > [0 0 0 0 0 0 0 0]
	fmt.Println("ptrs:", ptrs)         // > [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]
	fmt.Println("emptystr:", emptystr) // > [       ]
	// values are empty strings, separated by spaces,
	// so we can just see separating spaces

	// Arrays are also working with a personalized type
	type Data struct {
		Number int
		Text   string
	}

	// Creating an array with 8 'Data' elements
	// All the 8 elements will be like {0, ""} (Number = 0, Text = "")
	structs := [8]Data{}

	fmt.Println("structs:", structs) // > [{0 } {0 } {0 } {0 } {0 } {0 } {0 } {0 }]
	// prints {0 } because Number are 0 and Text are empty; separated by a space
}
Output:+219
array1: [1 2 3 4 5 6]
array2: [1 2 3 4 5 6]
array3: [1 2 3 4 5 6]
zeroes: [0 0 0 0 0 0 0 0]
ptrs: [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]
emptystr: [       ]
structs: [{0 } {0 } {0 } {0 } {0 } {0 } {0 } {0 }]
66 1553595181920 glotid
Sha1: 5d9cd0c6b04f137c78238d0df8a42bde253ff1db
GlotID: fapbrumjoa
1089 1553595183057 glotoutput
Sha1: 5949d44325e71f97ca0e5d9f730208966687c2c2
Lang: Go
FileName: main.go
CodeFull:+500
// :glot
package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	// doesn't work: invalid array index -1 (index must be non-negative)
	// fmt.Println(array[-42])
	fmt.Println(array[0]) // > 1
	fmt.Println(array[1]) // > 2
	fmt.Println(array[2]) // > 3
	fmt.Println(array[3]) // > 4
	fmt.Println(array[4]) // > 5
	fmt.Println(array[5]) // > 6
	// doesn't work: invalid array index 6 (out of bounds for 6-element array)
	//fmt.Println(array[6])
	// :show end
}
CodeToRun:+461
package main

import "fmt"

func main() {
	var array = [6]int{1, 2, 3, 4, 5, 6}

	// doesn't work: invalid array index -1 (index must be non-negative)
	// fmt.Println(array[-42])
	fmt.Println(array[0]) // > 1
	fmt.Println(array[1]) // > 2
	fmt.Println(array[2]) // > 3
	fmt.Println(array[3]) // > 4
	fmt.Println(array[4]) // > 5
	fmt.Println(array[5]) // > 6
	// doesn't work: invalid array index 6 (out of bounds for 6-element array)
	//fmt.Println(array[6])
}
Output:+12
1
2
3
4
5
6
66 1553595183231 glotid
Sha1: 5949d44325e71f97ca0e5d9f730208966687c2c2
GlotID: fapbrvemrf
1143 1553595184490 glotoutput
Sha1: 5890bf4420630d402384957d295212509bdbd1a5
Lang: Go
FileName: main.go
CodeFull:+484
// :glot
package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	fmt.Println(array) // > [1 2 3 4 5 6]

	array[0] = 6
	fmt.Println(array) // > [6 2 3 4 5 6]

	array[1] = 5
	fmt.Println(array) // > [6 5 3 4 5 6]

	array[2] = 4
	fmt.Println(array) // > [6 5 4 4 5 6]

	array[3] = 3
	fmt.Println(array) // > [6 5 4 3 5 6]

	array[4] = 2
	fmt.Println(array) // > [6 5 4 3 2 6]

	array[5] = 1
	fmt.Println(array) // > [6 5 4 3 2 1]
	// :show end
}
CodeToRun:+445
package main

import "fmt"

func main() {
	var array = [6]int{1, 2, 3, 4, 5, 6}

	fmt.Println(array) // > [1 2 3 4 5 6]

	array[0] = 6
	fmt.Println(array) // > [6 2 3 4 5 6]

	array[1] = 5
	fmt.Println(array) // > [6 5 3 4 5 6]

	array[2] = 4
	fmt.Println(array) // > [6 5 4 4 5 6]

	array[3] = 3
	fmt.Println(array) // > [6 5 4 3 5 6]

	array[4] = 2
	fmt.Println(array) // > [6 5 4 3 2 6]

	array[5] = 1
	fmt.Println(array) // > [6 5 4 3 2 1]
}
Output:+98
[1 2 3 4 5 6]
[6 2 3 4 5 6]
[6 5 3 4 5 6]
[6 5 4 4 5 6]
[6 5 4 3 5 6]
[6 5 4 3 2 6]
[6 5 4 3 2 1]
66 1553595184665 glotid
Sha1: 5890bf4420630d402384957d295212509bdbd1a5
GlotID: fapbrw9cmh
1498 1553595185872 glotoutput
Sha1: 038f882ccc81cfd8c6124571b82ccf29a08a4fc3
Lang: Go
FileName: main.go
CodeFull:+697
// :glot
package main

import "fmt"

func main() {
	// :show start
	// Defining a 2d Array to represent a matrix like
	// 1 2 3     So with 2 lines and 3 columns;
	// 4 5 6
	multiDimArray := [2] /*lines*/ [3] /*columns*/ int{[3]int{1, 2, 3}, [3]int{4, 5, 6}}

	// That can be simplified like this:
	var simplified = [2][3]int{{1, 2, 3}, {4, 5, 6}}

	// What does it looks like ?
	fmt.Println(multiDimArray)
	// > [[1 2 3] [4 5 6]]

	fmt.Println(multiDimArray[0])
	// > [1 2 3]    (first line of the array)

	fmt.Println(multiDimArray[0][1])
	// > 2          (cell of line 0 (the first one), column 1 (the 2nd one))

	// :show end

	// silence compiler error about unused variable
	_ = simplified
}
CodeToRun:+657
package main

import "fmt"

func main() {
	// Defining a 2d Array to represent a matrix like
	// 1 2 3     So with 2 lines and 3 columns;
	// 4 5 6
	multiDimArray := [2] /*lines*/ [3] /*columns*/ int{[3]int{1, 2, 3}, [3]int{4, 5, 6}}

	// That can be simplified like this:
	var simplified = [2][3]int{{1, 2, 3}, {4, 5, 6}}

	// What does it looks like ?
	fmt.Println(multiDimArray)
	// > [[1 2 3] [4 5 6]]

	fmt.Println(multiDimArray[0])
	// > [1 2 3]    (first line of the array)

	fmt.Println(multiDimArray[0][1])
	// > 2          (cell of line 0 (the first one), column 1 (the 2nd one))

	// silence compiler error about unused variable
	_ = simplified
}
Output:+28
[[1 2 3] [4 5 6]]
[1 2 3]
2
66 1553595186046 glotid
Sha1: 038f882ccc81cfd8c6124571b82ccf29a08a4fc3
GlotID: fapbrx2z3w
2271 1553595187192 glotoutput
Sha1: 08a7f089c440aceb621bc227b5584b26a1d95227
Lang: Go
FileName: main.go
CodeFull:+786
// :glot
package main

import "fmt"

func main() {
	// :show start
	// We can also define array with as much dimensions as we need
	// here, initialized with all zeros
	var multiDimArray = [2][4][3][2]string{}

	// the data is:
	// > [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
CodeToRun:+747
package main

import "fmt"

func main() {
	// We can also define array with as much dimensions as we need
	// here, initialized with all zeros
	var multiDimArray = [2][4][3][2]string{}

	// the data is:
	// > [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]

	fmt.Printf("%#v\n", multiDimArray)
}
Output:+621
[2][4][3][2]string{[4][3][2]string{[3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}}, [4][3][2]string{[3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}}}
66 1553595187460 glotid
Sha1: 08a7f089c440aceb621bc227b5584b26a1d95227
GlotID: fapbrxv8tu
2624 1553595188587 glotoutput
Sha1: fae1c2df264ccbb25d9fdf9b29452d993ac38aac
Lang: Go
FileName: main.go
CodeFull:+946
// :glot
package main

import "fmt"

func main() {
	// :show start

	var multiDimArray = [2][4][3][2]string{}

	// We can set some values in the array's cells
	multiDimArray[0][0][0][0] = "All zero indexes"   // Setting the first value
	multiDimArray[1][3][2][1] = "All indexes to max" // Setting the value at extreme location

	// The data looks like:
	// > [[[["All zero indexes" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" "All indexes to max"]]]]

	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
CodeToRun:+906
package main

import "fmt"

func main() {

	var multiDimArray = [2][4][3][2]string{}

	// We can set some values in the array's cells
	multiDimArray[0][0][0][0] = "All zero indexes"   // Setting the first value
	multiDimArray[1][3][2][1] = "All indexes to max" // Setting the value at extreme location

	// The data looks like:
	// > [[[["All zero indexes" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" "All indexes to max"]]]]

	fmt.Printf("%#v\n", multiDimArray)
}
Output:+655
[2][4][3][2]string{[4][3][2]string{[3][2]string{[2]string{"All zero indexes", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}}, [4][3][2]string{[3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", ""}}, [3][2]string{[2]string{"", ""}, [2]string{"", ""}, [2]string{"", "All indexes to max"}}}}
66 1553595188764 glotid
Sha1: fae1c2df264ccbb25d9fdf9b29452d993ac38aac
GlotID: fapbryp7kr
421 1553595190470 glotoutput
Sha1: 23274a5a11cc7195952199791285b6327218bde6
Lang: Go
FileName: main.go
CodeFull:+157
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []string{"hello"}
	a = append(a, "world")
	fmt.Printf("a: %#v\n", a)
	// :show end
}
CodeToRun:+118
package main

import "fmt"

func main() {
	a := []string{"hello"}
	a = append(a, "world")
	fmt.Printf("a: %#v\n", a)
}
Output:+30
a: []string{"hello", "world"}
66 1553595190649 glotid
Sha1: 23274a5a11cc7195952199791285b6327218bde6
GlotID: fapbrztgif
442 1553595192888 glotoutput
Sha1: dcc82bc30eaadc807c3b068297151af2bc39637a
Lang: Go
FileName: main.go
CodeFull:+164
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []string{"hello"}
	a = append(a, "world", "now")
	fmt.Printf("a: %#v\n", a)
	// :show end
}
CodeToRun:+125
package main

import "fmt"

func main() {
	a := []string{"hello"}
	a = append(a, "world", "now")
	fmt.Printf("a: %#v\n", a)
}
Output:+37
a: []string{"hello", "world", "now"}
66 1553595193062 glotid
Sha1: dcc82bc30eaadc807c3b068297151af2bc39637a
GlotID: fapbs19bdo
482 1553595195561 glotoutput
Sha1: c535f97b5c54a156428140000e3875591bf6f01e
Lang: Go
FileName: main.go
CodeFull:+185
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []string{"!"}
	a2 := []string{"Hello", "world"}
	a = append(a, a2...)
	fmt.Printf("a: %#v\n", a)
	// :show end
}
CodeToRun:+146
package main

import "fmt"

func main() {
	a := []string{"!"}
	a2 := []string{"Hello", "world"}
	a = append(a, a2...)
	fmt.Printf("a: %#v\n", a)
}
Output:+35
a: []string{"!", "Hello", "world"}
66 1553595195744 glotid
Sha1: c535f97b5c54a156428140000e3875591bf6f01e
GlotID: fapbs2umgu
1088 1553595196983 glotoutput
Sha1: c2389421f29e5357ccce1dfd53d85e086bf90855
Lang: Go
FileName: main.go
CodeFull:+388
// :glot
package main

import "fmt"

func main() {
	// :show start
	var a []int
	ptr := fmt.Sprintf("%p", a)
	n := 0
	nAppends := 0
	for {
		a = append(a, 1)
		nAppends++
		currPtr := fmt.Sprintf("%p", a)
		if currPtr != ptr {
			fmt.Printf("Appends needed to re-allocate slice: %d\n", nAppends)
			nAppends = 0
			ptr = currPtr
			n++
			if n == 6 {
				break
			}
		}
	}
	// :show end
}
CodeToRun:+349
package main

import "fmt"

func main() {
	var a []int
	ptr := fmt.Sprintf("%p", a)
	n := 0
	nAppends := 0
	for {
		a = append(a, 1)
		nAppends++
		currPtr := fmt.Sprintf("%p", a)
		if currPtr != ptr {
			fmt.Printf("Appends needed to re-allocate slice: %d\n", nAppends)
			nAppends = 0
			ptr = currPtr
			n++
			if n == 6 {
				break
			}
		}
	}
}
Output:+234
Appends needed to re-allocate slice: 1
Appends needed to re-allocate slice: 1
Appends needed to re-allocate slice: 1
Appends needed to re-allocate slice: 2
Appends needed to re-allocate slice: 4
Appends needed to re-allocate slice: 8
66 1553595197162 glotid
Sha1: c2389421f29e5357ccce1dfd53d85e086bf90855
GlotID: fapbs3p3l7
744 1553595199033 glotoutput
Sha1: 89b5c936a554e2e5658f0de4bb6008582d4c518d
Lang: Go
FileName: main.go
CodeFull:+342
// :glot
package main

import "fmt"

// :show start
func filterEvenValues(a []int) []int {
	var res []int
	for _, el := range a {
		if el%2 == 0 {
			continue
		}
		res = append(res, el)
	}
	return res
}

// :show end

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValues(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
CodeToRun:+274
package main

import "fmt"

func filterEvenValues(a []int) []int {
	var res []int
	for _, el := range a {
		if el%2 == 0 {
			continue
		}
		res = append(res, el)
	}
	return res
}

func main() {
	a := []int{1, 2, 3, 4}
	res := filterEvenValues(a)
	fmt.Printf("%#v\n", res)
}
Output:+12
[]int{1, 3}
66 1553595199233 glotid
Sha1: 89b5c936a554e2e5658f0de4bb6008582d4c518d
GlotID: fapbs4x1wq
905 1553595200465 glotoutput
Sha1: d35317b9e8d10fae4021ed4b71b5465597461b0c
Lang: Go
FileName: main.go
CodeFull:+408
// :glot
package main

import "fmt"

func filterEvenValuesInPlace(a []int) []int {
	// create a zero-length slice with the same underlying array
	res := a[:0]

	for _, v := range a {
		if v%2 == 0 {
			// collect only wanted values
			res = append(res, v)
		}
	}
	return res
}

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValuesInPlace(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
CodeToRun:+369
package main

import "fmt"

func filterEvenValuesInPlace(a []int) []int {
	// create a zero-length slice with the same underlying array
	res := a[:0]

	for _, v := range a {
		if v%2 == 0 {
			// collect only wanted values
			res = append(res, v)
		}
	}
	return res
}

func main() {
	a := []int{1, 2, 3, 4}
	res := filterEvenValuesInPlace(a)
	fmt.Printf("%#v\n", res)
}
Output:+12
[]int{2, 4}
66 1553595200641 glotid
Sha1: d35317b9e8d10fae4021ed4b71b5465597461b0c
GlotID: fapbs5rraw
543 1553595202144 glotoutput
Sha1: 7dd6db8f1e69a4e0c6eee1a0040f2437e47277b6
Lang: Go
FileName: main.go
CodeFull:+213
// :glot
package main

import "fmt"

func main() {
	// :show start
	src := []int{1, 2, 3}
	dst := make([]int, len(src))
	copy(dst, src)
	fmt.Printf("src: %#v\n", src)
	fmt.Printf("dst: %#v\n", dst)
	// :show end
}
CodeToRun:+174
package main

import "fmt"

func main() {
	src := []int{1, 2, 3}
	dst := make([]int, len(src))
	copy(dst, src)
	fmt.Printf("src: %#v\n", src)
	fmt.Printf("dst: %#v\n", dst)
}
Output:+40
src: []int{1, 2, 3}
dst: []int{1, 2, 3}
66 1553595202318 glotid
Sha1: 7dd6db8f1e69a4e0c6eee1a0040f2437e47277b6
GlotID: fapbs6rr2v
1055 1553595203642 glotoutput
Sha1: 56b0fc1e961d92909a09a639f2a21da73db8ec6e
Lang: Go
FileName: main.go
CodeFull:+427
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	s := []byte("123456")
	var d []byte
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	// :show end
}
CodeToRun:+388
package main

import (
	"fmt"
)

func main() {
	s := []byte("123456")
	var d []byte
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
}
Output:+123
d: 0x0, len: 0, cap: 0
d: 0xc42006c018, len: 6, cap: 8
d: 0xc42006c040, len: 12, cap: 16
d: 0xc420080020, len: 18, cap: 32
66 1553595203813 glotid
Sha1: 56b0fc1e961d92909a09a639f2a21da73db8ec6e
GlotID: fapbs7nsvp
1144 1553595205210 glotoutput
Sha1: 48fdb3ee60fa07cf3b685d1922ae9662a2062674
Lang: Go
FileName: main.go
CodeFull:+466
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	s := []byte("123456")
	d := make([]byte, 0, len(s)*4)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	// :show end
}
CodeToRun:+427
package main

import (
	"fmt"
)

func main() {
	s := []byte("123456")
	d := make([]byte, 0, len(s)*4)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
	d = append(d, s...)
	d = append(d, s...)
	fmt.Printf("d: %p, len: %d, cap: %d\n", d, len(d), cap(d))
}
Output:+134
d: 0xc42007a000, len: 0, cap: 24
d: 0xc42007a000, len: 6, cap: 24
d: 0xc42007a000, len: 12, cap: 24
d: 0xc42007a000, len: 24, cap: 24
66 1553595205381 glotid
Sha1: 48fdb3ee60fa07cf3b685d1922ae9662a2062674
GlotID: fapbs8leq6
515 1553595206405 glotoutput
Sha1: 77602ae8e4f7b3a50460442f601cc9d0de1b8540
Lang: Go
FileName: main.go
CodeFull:+225
// :glot, no output
package main

func main() {
	// :show start
	src := make(map[string]int)
	src["one"] = 1
	src["two"] = 2

	dst := make(map[string]int)

	for key, value := range src {
		dst[key] = value
	}

	// :show end
}
CodeToRun:+175
package main

func main() {
	src := make(map[string]int)
	src["one"] = 1
	src["two"] = 2

	dst := make(map[string]int)

	for key, value := range src {
		dst[key] = value
	}

}
Output:+0
66 1553595206577 glotid
Sha1: 77602ae8e4f7b3a50460442f601cc9d0de1b8540
GlotID: fapbs9b1vf
622 1553595208044 glotoutput
Sha1: 56c562e02cc1602cf9603f9088928c4deb11b30d
Lang: Go
FileName: main.go
CodeFull:+241
// :glot
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key, value := range people {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}
CodeToRun:+202
package main

import "fmt"

func main() {
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key, value := range people {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
}
Output:+63
key: john, value: 30
key: jane, value: 29
key: mark, value: 11
66 1553595208215 glotid
Sha1: 56c562e02cc1602cf9603f9088928c4deb11b30d
GlotID: fapbsaa5ep
539 1553595209579 glotoutput
Sha1: 7753237be2d38854896a252f6f58c2dfea1101b5
Lang: Go
FileName: main.go
CodeFull:+216
// :glot
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key := range people {
		fmt.Printf("key: %s\n", key)
	}
	// :show end
}
CodeToRun:+177
package main

import "fmt"

func main() {
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key := range people {
		fmt.Printf("key: %s\n", key)
	}
}
Output:+30
key: john
key: jane
key: mark
66 1553595209752 glotid
Sha1: 7753237be2d38854896a252f6f58c2dfea1101b5
GlotID: fapbsb72vo
557 1553595211218 glotoutput
Sha1: d80047d5ec01ba1dd1224ad8c8f8fe748acfff0b
Lang: Go
FileName: main.go
CodeFull:+225
// :glot
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for _, value := range people {
		fmt.Printf("value: %d\n", value)
	}
	// :show end
}
CodeToRun:+186
package main

import "fmt"

func main() {
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for _, value := range people {
		fmt.Printf("value: %d\n", value)
	}
}
Output:+30
value: 30
value: 29
value: 11
66 1553595211390 glotid
Sha1: d80047d5ec01ba1dd1224ad8c8f8fe748acfff0b
GlotID: fapbsc66pp
547 1553595212951 glotoutput
Sha1: 1a32406ec71020e717fe094f71ef6b52e3f8b96a
Lang: Go
FileName: main.go
CodeFull:+218
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	people := map[string]int{"john": 30, "jane": 29}
	fmt.Printf("%v\n", people)

	delete(people, "john")
	fmt.Printf("%v\n", people)
	// :show end
}
CodeToRun:+179
package main

import (
	"fmt"
)

func main() {
	people := map[string]int{"john": 30, "jane": 29}
	fmt.Printf("%v\n", people)

	delete(people, "john")
	fmt.Printf("%v\n", people)
}
Output:+34
map[jane:29 john:30]
map[jane:29]
66 1553595213128 glotid
Sha1: 1a32406ec71020e717fe094f71ef6b52e3f8b96a
GlotID: fapbsd7evd
867 1553595214791 glotoutput
Sha1: 4eaadb170249d44d0a430112f7eb92667353315a
Lang: Go
FileName: main.go
CodeFull:+374
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	people := map[string]int{"john": 30, "jane": 29}
	fmt.Printf("%v\n", people)

	// deleting a key that doesn't exist is a no-op
	delete(people, "notfound")
	fmt.Printf("%v\n", people)

	// deleting a key in nil map is a no-op
	var something map[string]int
	delete(something, "notfound")
	// :show end
}
CodeToRun:+335
package main

import (
	"fmt"
)

func main() {
	people := map[string]int{"john": 30, "jane": 29}
	fmt.Printf("%v\n", people)

	// deleting a key that doesn't exist is a no-op
	delete(people, "notfound")
	fmt.Printf("%v\n", people)

	// deleting a key in nil map is a no-op
	var something map[string]int
	delete(something, "notfound")
}
Output:+42
map[john:30 jane:29]
map[john:30 jane:29]
66 1553595215005 glotid
Sha1: 4eaadb170249d44d0a430112f7eb92667353315a
GlotID: fapbsebmah
3260 1553595216850 glotoutput
Sha1: 7f134ff7596d222d7657aa751f8eca5fa0e2aa80
Lang: Go
FileName: main.go
CodeFull:+1511
// :glot
package main

import "fmt"

// StringSet is a set of unique strings
type StringSet struct {
	m map[string]struct{}
}

func NewStringSet(strings ...string) *StringSet {
	res := &StringSet{
		m: map[string]struct{}{},
	}
	for _, s := range strings {
		res.Add(s)
	}
	return res
}

// Add adds a string to the set. If string is already in the set, it has no effect
func (s *StringSet) Add(str string) {
	s.m[str] = struct{}{}
}

// Exists checks if string exists in the set
func (s *StringSet) Exists(str string) bool {
	_, exists := s.m[str]
	return exists
}

// Delete removes a string from the set
func (s *StringSet) Delete(str string) {
	delete(s.m, str)
}

// Strings returns strings in the set
func (s *StringSet) Strings() []string {
	n := len(s.m)
	if n == 0 {
		return nil
	}
	// for efficiency, pre-allocate the array with known, final capacity
	// this avoids re-allocating underlying array in append
	res := make([]string, 0, n)
	for str := range s.m {
		res = append(res, str)
	}
	return res
}

func printExists(set *StringSet, str string) {
	if set.Exists(str) {
		fmt.Printf("'%s' exists in set\n", str)
	} else {
		fmt.Printf("'%s' doesn't exist in set\n", str)
	}
}

func main() {
	// :show start
	set := NewStringSet("hi", "hello")
	fmt.Printf("Original set: %#v\n", set.Strings())

	set.Delete("hi")
	fmt.Printf("After delete: %#v\n", set.Strings())

	set.Add("hey")
	fmt.Printf("After add   : %#v\n", set.Strings())

	printExists(set, "hello")
	printExists(set, "ola")
	// :show end
}
CodeToRun:+1472
package main

import "fmt"

// StringSet is a set of unique strings
type StringSet struct {
	m map[string]struct{}
}

func NewStringSet(strings ...string) *StringSet {
	res := &StringSet{
		m: map[string]struct{}{},
	}
	for _, s := range strings {
		res.Add(s)
	}
	return res
}

// Add adds a string to the set. If string is already in the set, it has no effect
func (s *StringSet) Add(str string) {
	s.m[str] = struct{}{}
}

// Exists checks if string exists in the set
func (s *StringSet) Exists(str string) bool {
	_, exists := s.m[str]
	return exists
}

// Delete removes a string from the set
func (s *StringSet) Delete(str string) {
	delete(s.m, str)
}

// Strings returns strings in the set
func (s *StringSet) Strings() []string {
	n := len(s.m)
	if n == 0 {
		return nil
	}
	// for efficiency, pre-allocate the array with known, final capacity
	// this avoids re-allocating underlying array in append
	res := make([]string, 0, n)
	for str := range s.m {
		res = append(res, str)
	}
	return res
}

func printExists(set *StringSet, str string) {
	if set.Exists(str) {
		fmt.Printf("'%s' exists in set\n", str)
	} else {
		fmt.Printf("'%s' doesn't exist in set\n", str)
	}
}

func main() {
	set := NewStringSet("hi", "hello")
	fmt.Printf("Original set: %#v\n", set.Strings())

	set.Delete("hi")
	fmt.Printf("After delete: %#v\n", set.Strings())

	set.Add("hey")
	fmt.Printf("After add   : %#v\n", set.Strings())

	printExists(set, "hello")
	printExists(set, "ola")
}
Output:+158
Original set: []string{"hi", "hello"}
After delete: []string{"hello"}
After add   : []string{"hey", "hello"}
'hello' exists in set
'ola' doesn't exist in set
66 1553595217026 glotid
Sha1: 7f134ff7596d222d7657aa751f8eca5fa0e2aa80
GlotID: fapbsfizqk
1071 1553595218385 glotoutput
Sha1: 01f69fe2d3bb957658901593db206f256c3b654a
Lang: Go
FileName: main.go
CodeFull:+421
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	m := make(map[string][]int)
	fmt.Printf("Non-existing key returns zero value of []int, i.e. nil: %#v\n", m["key1"])

	m["key1"] = append(m["key1"], 8)
	m["key1"] = append(m["key1"], 3)
	fmt.Printf("\nAfter appending to slice: %#v\n", m["key1"])

	delete(m, "key1")
	fmt.Printf("\ndelete() sets back to nil slice: %#v\n", m["key1"])

	// :show end
}
CodeToRun:+382
package main

import (
	"fmt"
)

func main() {
	m := make(map[string][]int)
	fmt.Printf("Non-existing key returns zero value of []int, i.e. nil: %#v\n", m["key1"])

	m["key1"] = append(m["key1"], 8)
	m["key1"] = append(m["key1"], 3)
	fmt.Printf("\nAfter appending to slice: %#v\n", m["key1"])

	delete(m, "key1")
	fmt.Printf("\ndelete() sets back to nil slice: %#v\n", m["key1"])

}
Output:+151
Non-existing key returns zero value of []int, i.e. nil: []int(nil)

After appending to slice: []int{8, 3}

delete() sets back to nil slice: []int(nil)
66 1553595218560 glotid
Sha1: 01f69fe2d3bb957658901593db206f256c3b654a
GlotID: fapbsgfv9v
1613 1553595219922 glotoutput
Sha1: e0ffcce831ade59731a2b2b9eaacbb127f718ada
Lang: Go
FileName: main.go
CodeFull:+744
// :glot
package main

import (
	"fmt"
	"sync"
)

// ConcurrentMap is a wrapper around map that is safe for concurrent use
type ConcurrentMap struct {
	sync.RWMutex
	m map[string]int
}

// Get gets a value for a key
func (r *ConcurrentMap) Get(key string) int {
	r.RLock()
	defer r.RUnlock()
	return r.m[key]
}

// Set sets a key to a given value
func (r *ConcurrentMap) Set(key string, val int) {
	r.Lock()
	defer r.Unlock()
	r.m[key] = val
}

// Add increases the value under a key by n
func (r *ConcurrentMap) Add(key string, n int) int {
	r.Lock()
	defer r.Unlock()
	r.m[key] += n
	return r.m[key]
}

func main() {
	counter := ConcurrentMap{m: make(map[string]int)}

	n := counter.Add("some_key", 2)
	fmt.Printf("Final value is: %d\n", n)
}
CodeToRun:+735
package main

import (
	"fmt"
	"sync"
)

// ConcurrentMap is a wrapper around map that is safe for concurrent use
type ConcurrentMap struct {
	sync.RWMutex
	m map[string]int
}

// Get gets a value for a key
func (r *ConcurrentMap) Get(key string) int {
	r.RLock()
	defer r.RUnlock()
	return r.m[key]
}

// Set sets a key to a given value
func (r *ConcurrentMap) Set(key string, val int) {
	r.Lock()
	defer r.Unlock()
	r.m[key] = val
}

// Add increases the value under a key by n
func (r *ConcurrentMap) Add(key string, n int) int {
	r.Lock()
	defer r.Unlock()
	r.m[key] += n
	return r.m[key]
}

func main() {
	counter := ConcurrentMap{m: make(map[string]int)}

	n := counter.Add("some_key", 2)
	fmt.Printf("Final value is: %d\n", n)
}
Output:+18
Final value is: 2
66 1553595220096 glotid
Sha1: e0ffcce831ade59731a2b2b9eaacbb127f718ada
GlotID: fapbshcs5m
474 1553595222482 glotoutput
Sha1: d99a6d99c3a17da84aa8b9fc0643947aa3fe44ab
Lang: Go
FileName: main.go
CodeFull:+185
// :glot
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string
	fmt.Printf("m == nil ? %v\n", m == nil)
	fmt.Printf("len(m) = %d\n", len(m))
	// :show end
}
CodeToRun:+146
package main

import "fmt"

func main() {
	var m map[string]string
	fmt.Printf("m == nil ? %v\n", m == nil)
	fmt.Printf("len(m) = %d\n", len(m))
}
Output:+27
m == nil ? true
len(m) = 0
66 1553595222656 glotid
Sha1: d99a6d99c3a17da84aa8b9fc0643947aa3fe44ab
GlotID: fapbsivo02
843 1553595224632 glotoutput
Sha1: 9748c898800861ab18733d3228b84c280cbea873
Lang: Go
FileName: main.go
CodeFull:+317
// :glot, allow error
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string

	// you can read read from un-initialized map
	fmt.Printf(`m["foo"] = %s`+"\n", m["foo"])
	_, ok := m["foo"]
	fmt.Printf("ok: %v\n", ok)

	// writing to uninitialized map panics
	m["foo"] = "bar"
	// :show end
}
CodeToRun:+265
package main

import "fmt"

func main() {
	var m map[string]string

	// you can read read from un-initialized map
	fmt.Printf(`m["foo"] = %s`+"\n", m["foo"])
	_, ok := m["foo"]
	fmt.Printf("ok: %v\n", ok)

	// writing to uninitialized map panics
	m["foo"] = "bar"
}
Output:+144
m["foo"] = 
ok: false
panic: assignment to entry in nil map

goroutine 1 [running]:
main.main()
	/tmp/042344720/main.go:14 +0x189
exit status 2
66 1553595224837 glotid
Sha1: 9748c898800861ab18733d3228b84c280cbea873
GlotID: fapbsk5ocf
1781 1553595226886 glotoutput
Sha1: c0b9e086702af42fb47f2497343110e1a488a95a
Lang: Go
FileName: main.go
CodeFull:+735
// :glot
package main

import (
	"fmt"
)

// :show start
// User describes a user
type User struct {
	FirstName, LastName string
	Email               string
	Age                 int
	userID              int
}

// FullName returns full name of a user
func (u *User) FullName() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

func main() {
	// zero value of struct
	var u User
	fmt.Printf("u: %#v\n\n", u)

	// pu is *User i.e. a pointer to User struct
	pu := new(User)
	pu.Age = 33
	fmt.Printf("*pu: %#v\n", *pu)

	// &User{} is the same as new(User)
	pu = &User{}
	pu.Age = 18
	fmt.Printf("*pu: %#v\n", *pu)

	pu.FirstName, pu.LastName = "Jane", "Doe"
	fmt.Printf("pu.FullName(): %s\n", pu.FullName())
}

// :show end
CodeToRun:+698
package main

import (
	"fmt"
)

// User describes a user
type User struct {
	FirstName, LastName string
	Email               string
	Age                 int
	userID              int
}

// FullName returns full name of a user
func (u *User) FullName() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

func main() {
	// zero value of struct
	var u User
	fmt.Printf("u: %#v\n\n", u)

	// pu is *User i.e. a pointer to User struct
	pu := new(User)
	pu.Age = 33
	fmt.Printf("*pu: %#v\n", *pu)

	// &User{} is the same as new(User)
	pu = &User{}
	pu.Age = 18
	fmt.Printf("*pu: %#v\n", *pu)

	pu.FirstName, pu.LastName = "Jane", "Doe"
	fmt.Printf("pu.FullName(): %s\n", pu.FullName())
}
Output:+232
u: main.User{FirstName:"", LastName:"", Email:"", Age:0, userID:0}

*pu: main.User{FirstName:"", LastName:"", Email:"", Age:33, userID:0}
*pu: main.User{FirstName:"", LastName:"", Email:"", Age:18, userID:0}
pu.FullName(): Jane Doe
66 1553595227056 glotid
Sha1: c0b9e086702af42fb47f2497343110e1a488a95a
GlotID: fapbslhzqs
501 1553595229037 glotoutput
Sha1: 183cd366bc7f05f9bbfd14c683180a6312ed60ae
Lang: Go
FileName: main.go
CodeFull:+194
// :glot
package main

import "fmt"

func main() {
	// :show start
	data := struct {
		Number int
		Text   string
	}{
		42,
		"Hello world!",
	}

	fmt.Printf("data: %+v\n", data)
	// :show end
}
CodeToRun:+155
package main

import "fmt"

func main() {
	data := struct {
		Number int
		Text   string
	}{
		42,
		"Hello world!",
	}

	fmt.Printf("data: %+v\n", data)
}
Output:+36
data: {Number:42 Text:Hello world!}
66 1553595229210 glotid
Sha1: 183cd366bc7f05f9bbfd14c683180a6312ed60ae
GlotID: fapbsms46i
709 1553595233484 glotoutput
Sha1: 229fe847f2f25646d2e2dca64ccc98c0a8948027
Lang: Go
FileName: main.go
CodeFull:+305
// :glot
package main

import "fmt"

// :show start

type User struct {
	name string
}

func (u User) Name() string {
	return u.name
}

func (u *User) SetName(newName string) {
	u.name = newName
}

func main() {
	var me User

	me.SetName("Slim Shady")
	fmt.Println("My name is", me.Name())
}

// :show end
CodeToRun:+267
package main

import "fmt"

type User struct {
	name string
}

func (u User) Name() string {
	return u.name
}

func (u *User) SetName(newName string) {
	u.name = newName
}

func main() {
	var me User

	me.SetName("Slim Shady")
	fmt.Println("My name is", me.Name())
}
Output:+22
My name is Slim Shady
66 1553595234010 glotid
Sha1: 229fe847f2f25646d2e2dca64ccc98c0a8948027
GlotID: fapbspmzn8
738 1553595236717 glotoutput
Sha1: 8f8335e55ada31cf0f3d25f292145f48320515aa
Lang: Go
FileName: main.go
CodeFull:+236
// :glot
// allow error
package main

import "io"

// :show start
type MyReadCloser struct {
}

func (rc *MyReadCloser) Read(d []byte) (int, error) {
	return 0, nil
}

var _ io.ReadCloser = &MyReadCloser{}

// :show end

func main() {
}
CodeToRun:+183
package main

import "io"

type MyReadCloser struct {
}

func (rc *MyReadCloser) Read(d []byte) (int, error) {
	return 0, nil
}

var _ io.ReadCloser = &MyReadCloser{}

func main() {
}
Output:+202
# command-line-arguments
./main.go:12:5: cannot use MyReadCloser literal (type *MyReadCloser) as type io.ReadCloser in assignment:
	*MyReadCloser does not implement io.ReadCloser (missing Close method)
66 1553595237389 glotid
Sha1: 8f8335e55ada31cf0f3d25f292145f48320515aa
GlotID: fapbsrndxi
1052 1553595239181 glotoutput
Sha1: 704ba0ca1885937698cfcfde209fffda215acc18
Lang: Go
FileName: main.go
CodeFull:+469
// :glot
package main

import "fmt"

// :show start
func retVals(ok bool) (int, bool) {
	return 5, ok
}

func main() {
	a := 5
	b := 5
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}

	if n, ok := retVals(true); ok {
		fmt.Print("ok is true, n: %d\n", n)
	} else {
		fmt.Print("ok is false, n: %d\n", n)
	}

	// n is only visible within if loop, so this would fail compilation
	// fmt.Printf("n: %d\n", n)
}

// :show end
CodeToRun:+432
package main

import "fmt"

func retVals(ok bool) (int, bool) {
	return 5, ok
}

func main() {
	a := 5
	b := 5
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}

	if n, ok := retVals(true); ok {
		fmt.Print("ok is true, n: %d\n", n)
	} else {
		fmt.Print("ok is false, n: %d\n", n)
	}

	// n is only visible within if loop, so this would fail compilation
	// fmt.Printf("n: %d\n", n)
}
Output:+35
a is equal to b
ok is true, n: %d
5
66 1553595239394 glotid
Sha1: 704ba0ca1885937698cfcfde209fffda215acc18
GlotID: fapbsstqfg
547 1553595240915 glotoutput
Sha1: 342f97c96379568049bce74eb32e20cf7381a0b5
Lang: Go
FileName: main.go
CodeFull:+229
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1, 3:
		fmt.Printf("a is 1 or 3\n")
	case 2:
		fmt.Printf("a is 2\n")
	default:
		fmt.Printf("default: a is %d\n", a)
	}
	// :show end
}
CodeToRun:+190
package main

import "fmt"

func main() {
	a := 1
	switch a {
	case 1, 3:
		fmt.Printf("a is 1 or 3\n")
	case 2:
		fmt.Printf("a is 2\n")
	default:
		fmt.Printf("default: a is %d\n", a)
	}
}
Output:+12
a is 1 or 3
66 1553595241090 glotid
Sha1: 342f97c96379568049bce74eb32e20cf7381a0b5
GlotID: fapbstukyv
465 1553595242963 glotoutput
Sha1: a28b97ba99b1c5e331c847515c051c1ecbb18e93
Lang: Go
FileName: main.go
CodeFull:+187
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1:
		fmt.Printf("case 1\n")
		fallthrough
	case 2:
		fmt.Printf("caes 2\n")
	}
	// :show end
}
CodeToRun:+148
package main

import "fmt"

func main() {
	a := 1
	switch a {
	case 1:
		fmt.Printf("case 1\n")
		fallthrough
	case 2:
		fmt.Printf("caes 2\n")
	}
}
Output:+14
case 1
caes 2
66 1553595243131 glotid
Sha1: a28b97ba99b1c5e331c847515c051c1ecbb18e93
GlotID: fapbsv2hrn
474 1553595244537 glotoutput
Sha1: 8222f2f428d66f922bfbca9ca4f8ff683057c13c
Lang: Go
FileName: main.go
CodeFull:+193
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "foo"
	switch s {
	case "foo":
		fmt.Printf("s is 'foo'\n")
	case "bar":
		fmt.Printf("s is 'bar'\n")
	}
	// :show end
}
CodeToRun:+154
package main

import "fmt"

func main() {
	s := "foo"
	switch s {
	case "foo":
		fmt.Printf("s is 'foo'\n")
	case "bar":
		fmt.Printf("s is 'bar'\n")
	}
}
Output:+11
s is 'foo'
66 1553595244710 glotid
Sha1: 8222f2f428d66f922bfbca9ca4f8ff683057c13c
GlotID: fapbsw0cji
843 1553595246174 glotoutput
Sha1: 5b7e2a3eed9166e09ceb9ca27ae895c76e48ffe4
Lang: Go
FileName: main.go
CodeFull:+359
// :glot
package main

import (
	"fmt"
)

// :show start
func check(n int) {
	switch {
	case n > 0 && n%3 == 0:
		fmt.Printf("n is %d, divisible by 3\n", n)
	case n >= 4:
		fmt.Printf("n is %d (>= 4)\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
}

// :show end
func main() {
	// :show start
	check(3)
	check(4)
	check(6)
	check(1)
	// :show end
}
CodeToRun:+292
package main

import (
	"fmt"
)

func check(n int) {
	switch {
	case n > 0 && n%3 == 0:
		fmt.Printf("n is %d, divisible by 3\n", n)
	case n >= 4:
		fmt.Printf("n is %d (>= 4)\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
}

func main() {
	check(3)
	check(4)
	check(6)
	check(1)
}
Output:+76
n is 3, divisible by 3
n is 4 (>= 4)
n is 6, divisible by 3
default: n is 1
66 1553595246342 glotid
Sha1: 5b7e2a3eed9166e09ceb9ca27ae895c76e48ffe4
GlotID: fapbswzbls
900 1553595247878 glotoutput
Sha1: ee3ded7c20d615ecdb38a2fa6d3fff93f1ff2588
Lang: Go
FileName: main.go
CodeFull:+401
// :glot
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// without seeding rand.Intn will always return the same sequence
	rand.Seed(time.Now().UnixNano())
	// :show start
	switch n := rand.Intn(9); n {
	case 1, 2, 3:
		fmt.Printf("case 1, 2, 3: n is %d\n", n)
	case 4, 5:
		fmt.Printf("case 4, 5: n is %d\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
	// :show end
}
CodeToRun:+362
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// without seeding rand.Intn will always return the same sequence
	rand.Seed(time.Now().UnixNano())
	switch n := rand.Intn(9); n {
	case 1, 2, 3:
		fmt.Printf("case 1, 2, 3: n is %d\n", n)
	case 4, 5:
		fmt.Printf("case 4, 5: n is %d\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
}
Output:+21
case 1, 2, 3: n is 3
66 1553595248047 glotid
Sha1: ee3ded7c20d615ecdb38a2fa6d3fff93f1ff2588
GlotID: fapbsxzuen
1118 1553595249824 glotoutput
Sha1: 13a945490d681f1f62c8db21d4403658961851e6
Lang: Go
FileName: main.go
CodeFull:+485
// :glot
package main

import (
	"fmt"
)

// :show start
func printType(iv interface{}) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		fmt.Printf("'%d' is of type int\n", v)
	case string:
		fmt.Printf("'%s' is of type string\n", v)
	case float64:
		fmt.Printf("'%f' is of type float64\n", v)
	default:
		fmt.Printf("We don't support type '%T'\n", v)
	}
}

func main() {
	printType("5")
	printType(4)
	printType(true)
}

// :show end
CodeToRun:+448
package main

import (
	"fmt"
)

func printType(iv interface{}) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		fmt.Printf("'%d' is of type int\n", v)
	case string:
		fmt.Printf("'%s' is of type string\n", v)
	case float64:
		fmt.Printf("'%f' is of type float64\n", v)
	default:
		fmt.Printf("We don't support type '%T'\n", v)
	}
}

func main() {
	printType("5")
	printType(4)
	printType(true)
}
Output:+70
'5' is of type string
'4' is of type int
We don't support type 'bool'
66 1553595249994 glotid
Sha1: 13a945490d681f1f62c8db21d4403658961851e6
GlotID: fapbsz5ln8
624 1553595251300 glotoutput
Sha1: 35f54f50401d2162121b854790ed8e8d310a09cc
Lang: Go
FileName: main.go
CodeFull:+278
// :glot
package main

import "fmt"

// :show start
func printIsOdd(n int) {
	if n%2 == 1 {
		goto isOdd
	}
	fmt.Printf("%d is even\n", n)
	return

isOdd:
	fmt.Printf("%d is odd\n", n)
}

// :show end

func main() {
	// :show start
	printIsOdd(5)
	printIsOdd(18)
	// :show end
}
CodeToRun:+210
package main

import "fmt"

func printIsOdd(n int) {
	if n%2 == 1 {
		goto isOdd
	}
	fmt.Printf("%d is even\n", n)
	return

isOdd:
	fmt.Printf("%d is odd\n", n)
}

func main() {
	printIsOdd(5)
	printIsOdd(18)
}
Output:+20
5 is odd
18 is even
66 1553595251469 glotid
Sha1: 35f54f50401d2162121b854790ed8e8d310a09cc
GlotID: fapbt016s7
447 1553595252487 glotoutput
Sha1: 4edb4f4f14fb62c7fa86b53bd186310b92d1fe3e
Lang: Go
FileName: main.go
CodeFull:+146
// :glot
// allow error
package main

import "fmt"

func main() {
	// :show start
	goto end
	a := 3
	fmt.Printf("a: %d\n", a)
end:
	// :show end
}
CodeToRun:+92
package main

import "fmt"

func main() {
	goto end
	a := 3
	fmt.Printf("a: %d\n", a)
end:
}
Output:+94
# command-line-arguments
./main.go:6:7: goto end jumps over declaration of a at ./main.go:7:4
66 1553595252655 glotid
Sha1: 4edb4f4f14fb62c7fa86b53bd186310b92d1fe3e
GlotID: fapbt0qldw
405 1553595254020 glotoutput
Sha1: b12b78fbf064124f0e65137dd6e5e3630f612796
Lang: Go
FileName: main.go
CodeFull:+159
// :glot
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for {
		i++
		if i > 2 {
			break
		}
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}
CodeToRun:+120
package main

import "fmt"

func main() {
	i := 0
	for {
		i++
		if i > 2 {
			break
		}
		fmt.Printf("i: %d\n", i)
	}
}
Output:+10
i: 1
i: 2
66 1553595254330 glotid
Sha1: b12b78fbf064124f0e65137dd6e5e3630f612796
GlotID: fapbt1obmf
423 1553595255607 glotoutput
Sha1: b7465098a88942276113022aa9d4e4fa84e5695b
Lang: Go
FileName: main.go
CodeFull:+168
// :glot
package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 3; i++ {
		if i == 1 {
			continue
		}
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}
CodeToRun:+129
package main

import "fmt"

func main() {
	for i := 0; i < 3; i++ {
		if i == 1 {
			continue
		}
		fmt.Printf("i: %d\n", i)
	}
}
Output:+10
i: 0
i: 2
66 1553595255777 glotid
Sha1: b7465098a88942276113022aa9d4e4fa84e5695b
GlotID: fapbt2lif3
506 1553595257008 glotoutput
Sha1: cd76f02b76ee5b9ce608d908b7b5828c7dcec746
Lang: Go
FileName: main.go
CodeFull:+194
// :glot
package main

import "fmt"

func main() {
	j := 100

loop:
	for j < 110 {
		j++

		switch j % 3 {
		case 0:
			continue loop
		case 1:
			break loop
		}

		fmt.Println("Var : ", j)
	}
}
CodeToRun:+185
package main

import "fmt"

func main() {
	j := 100

loop:
	for j < 110 {
		j++

		switch j % 3 {
		case 0:
			continue loop
		case 1:
			break loop
		}

		fmt.Println("Var : ", j)
	}
}
Output:+11
Var :  101
66 1553595257176 glotid
Sha1: cd76f02b76ee5b9ce608d908b7b5828c7dcec746
GlotID: fapbt3fitu
367 1553595258323 glotoutput
Sha1: 6df50012c77d3d2defa40b61bf398cb8ccb49ba5
Lang: Go
FileName: main.go
CodeFull:+138
// :glot
package main

import "fmt"

func main() {
	// :show start
	for n := 0; n < 3; n++ {
		fmt.Printf("n: %d\n", n)
	}
	// :show end
}
CodeToRun:+99
package main

import "fmt"

func main() {
	for n := 0; n < 3; n++ {
		fmt.Printf("n: %d\n", n)
	}
}
Output:+15
n: 0
n: 1
n: 2
66 1553595258492 glotid
Sha1: 6df50012c77d3d2defa40b61bf398cb8ccb49ba5
GlotID: fapbt47pag
475 1553595259758 glotoutput
Sha1: 62cecc89cb16552ae5cf80a5c12db1940d06172e
Lang: Go
FileName: main.go
CodeFull:+173
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "a 世"
	for i := range s {
		b := s[i]
		fmt.Printf("idx: %d, byte: %d\n", i, b)
	}
	// :show end
}
CodeToRun:+134
package main

import "fmt"

func main() {
	s := "a 世"
	for i := range s {
		b := s[i]
		fmt.Printf("idx: %d, byte: %d\n", i, b)
	}
}
Output:+52
idx: 0, byte: 97
idx: 1, byte: 32
idx: 2, byte: 228
66 1553595259925 glotid
Sha1: 62cecc89cb16552ae5cf80a5c12db1940d06172e
GlotID: fapbt52fxx
538 1553595261187 glotoutput
Sha1: 06dfe793c8fe0812f64a0f9d06e999edb103ddb2
Lang: Go
FileName: main.go
CodeFull:+175
// :glot
package main

import "fmt"

func main() {
	// :show start
	s := "Hey 世界"
	for i, rune := range s {
		fmt.Printf("idx: %d, rune: %d\n", i, rune)
	}
	// :show end
}
CodeToRun:+136
package main

import "fmt"

func main() {
	s := "Hey 世界"
	for i, rune := range s {
		fmt.Printf("idx: %d, rune: %d\n", i, rune)
	}
}
Output:+110
idx: 0, rune: 72
idx: 1, rune: 101
idx: 2, rune: 121
idx: 3, rune: 32
idx: 4, rune: 19990
idx: 7, rune: 30028
66 1553595261356 glotid
Sha1: 06dfe793c8fe0812f64a0f9d06e999edb103ddb2
GlotID: fapbt5x42q
410 1553595262627 glotoutput
Sha1: e75fb6fcd637b3423214dddfa1bfd8ff7cb72a0f
Lang: Go
FileName: main.go
CodeFull:+156
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for i := range a {
		fmt.Printf("idx: %d\n", i)
	}
	// :show end
}
CodeToRun:+117
package main

import "fmt"

func main() {
	a := []int{3, 15, 8}
	for i := range a {
		fmt.Printf("idx: %d\n", i)
	}
}
Output:+21
idx: 0
idx: 1
idx: 2
66 1553595262794 glotid
Sha1: e75fb6fcd637b3423214dddfa1bfd8ff7cb72a0f
GlotID: fapbt6ry11
441 1553595263939 glotoutput
Sha1: 1e6b50c581f3fba7d8e5d116e40ed59a3b95f123
Lang: Go
FileName: main.go
CodeFull:+165
// :glot
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for _, el := range a {
		fmt.Printf("element: %d\n", el)
	}
	// :show end
}
CodeToRun:+126
package main

import "fmt"

func main() {
	a := []int{3, 15, 8}
	for _, el := range a {
		fmt.Printf("element: %d\n", el)
	}
}
Output:+34
element: 3
element: 15
element: 8
66 1553595264106 glotid
Sha1: 1e6b50c581f3fba7d8e5d116e40ed59a3b95f123
GlotID: fapbt7k1wm
480 1553595265492 glotoutput
Sha1: 72a2efe44f0023782f12769dceeeab9d931f66a6
Lang: Go
FileName: main.go
CodeFull:+191
// :glot
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key := range m {
		fmt.Printf("key: %s\n", key)
	}
	// :show end
}
CodeToRun:+152
package main

import "fmt"

func main() {
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key := range m {
		fmt.Printf("key: %s\n", key)
	}
}
Output:+21
key: three
key: five
66 1553595265660 glotid
Sha1: 72a2efe44f0023782f12769dceeeab9d931f66a6
GlotID: fapbt8hd0y
495 1553595266925 glotoutput
Sha1: 4f4e823180dff51092763272f75678fcb01cba17
Lang: Go
FileName: main.go
CodeFull:+200
// :glot
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for _, value := range m {
		fmt.Printf("value: %d\n", value)
	}
	// :show end
}
CodeToRun:+161
package main

import "fmt"

func main() {
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for _, value := range m {
		fmt.Printf("value: %d\n", value)
	}
}
Output:+18
value: 3
value: 5
66 1553595267094 glotid
Sha1: 4f4e823180dff51092763272f75678fcb01cba17
GlotID: fapbt9c3ti
683 1553595268540 glotoutput
Sha1: ff998a064344be257aa220e6f24c289f8177ae85
Lang: Go
FileName: main.go
CodeFull:+310
// :glot
package main

import "fmt"

// :show start
func fillAndCloseChannel(ch chan int) {
	for i := 0; i < 3; i++ {
		ch <- i + 3
	}
	close(ch)
}

// :show end

func main() {
	// :show start
	ch := make(chan int)
	go fillAndCloseChannel(ch)

	for v := range ch {
		fmt.Printf("v: %d\n", v)
	}
	// :show end
}
CodeToRun:+242
package main

import "fmt"

func fillAndCloseChannel(ch chan int) {
	for i := 0; i < 3; i++ {
		ch <- i + 3
	}
	close(ch)
}

func main() {
	ch := make(chan int)
	go fillAndCloseChannel(ch)

	for v := range ch {
		fmt.Printf("v: %d\n", v)
	}
}
Output:+15
v: 3
v: 4
v: 5
66 1553595268707 glotid
Sha1: ff998a064344be257aa220e6f24c289f8177ae85
GlotID: fapbtaaot9
634 1553595270085 glotoutput
Sha1: 6cb56341c8bd61af8421da0a61fefbe23670abc3
Lang: Go
FileName: main.go
CodeFull:+264
// :glot
package main

import (
	"fmt"
)

// :show start
func SayHelloToMe(firstName, lastName string, age int) {
	fmt.Printf("Hello, %s %s!\n", firstName, lastName)
	fmt.Printf("You are %d\n", age)
}

func main() {
	SayHelloToMe("John", "Doe", 35)
}

// :show end
CodeToRun:+227
package main

import (
	"fmt"
)

func SayHelloToMe(firstName, lastName string, age int) {
	fmt.Printf("Hello, %s %s!\n", firstName, lastName)
	fmt.Printf("You are %d\n", age)
}

func main() {
	SayHelloToMe("John", "Doe", 35)
}
Output:+28
Hello, John Doe!
You are 35
66 1553595270254 glotid
Sha1: 6cb56341c8bd61af8421da0a61fefbe23670abc3
GlotID: fapbtb7s7z
733 1553595271841 glotoutput
Sha1: c9a24c48c6d9195872be6683811e12149e30a655
Lang: Go
FileName: main.go
CodeFull:+316
// :glot
package main

import "fmt"

// :show start
func Add(a, b int) int {
	return a + b
}

func AddAndMultiply(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	sum, mult := AddAndMultiply(5, 8)
	fmt.Printf("5+8=%d, 5*8=%d\n", sum, mult)
	sum = Add(6, 12)
	fmt.Printf("6+12=%d\n", sum)
}

// :show end
CodeToRun:+279
package main

import "fmt"

func Add(a, b int) int {
	return a + b
}

func AddAndMultiply(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	sum, mult := AddAndMultiply(5, 8)
	fmt.Printf("5+8=%d, 5*8=%d\n", sum, mult)
	sum = Add(6, 12)
	fmt.Printf("6+12=%d\n", sum)
}
Output:+23
5+8=13, 5*8=40
6+12=18
66 1553595272009 glotid
Sha1: c9a24c48c6d9195872be6683811e12149e30a655
GlotID: fapbtc9fz6
778 1553595273399 glotoutput
Sha1: f1d2c33f76c58834569a520c2f55d040d39e4c1f
Lang: Go
FileName: main.go
CodeFull:+342
// :glot
package main

import "fmt"

// :show start
func inverse(v float32) (reciprocal float32) {
	if v == 0 {
		return
	}
	reciprocal = 1 / v
	return
}

// function can return multiple values
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Printf("inverse(5)=%.2f\n", inverse(5))
}

// :show end
CodeToRun:+305
package main

import "fmt"

func inverse(v float32) (reciprocal float32) {
	if v == 0 {
		return
	}
	reciprocal = 1 / v
	return
}

// function can return multiple values
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Printf("inverse(5)=%.2f\n", inverse(5))
}
Output:+16
inverse(5)=0.20
66 1553595273565 glotid
Sha1: f1d2c33f76c58834569a520c2f55d040d39e4c1f
GlotID: fapbtd6tao
955 1553595274693 glotoutput
Sha1: 5d913901bb94de6e5bffc6162668c1c3c5a2cf23
Lang: Go
FileName: main.go
CodeFull:+410
// :glot
package main

import (
	"fmt"
)

// :show start
func variadic(strs ...string) {
	// strs is a slice of string
	for i, str := range strs {
		fmt.Printf("%d: %s\n", i, str)
	}
	fmt.Print("\n")
}

func main() {
	variadic("Hello", "Goodbye")
	variadic("Str1", "Str2", "Str3")

	// you can also give a slice to a variadic function, with `...`:
	strs := []string{"a", "b"}
	variadic(strs...)
}

// :show end
CodeToRun:+373
package main

import (
	"fmt"
)

func variadic(strs ...string) {
	// strs is a slice of string
	for i, str := range strs {
		fmt.Printf("%d: %s\n", i, str)
	}
	fmt.Print("\n")
}

func main() {
	variadic("Hello", "Goodbye")
	variadic("Str1", "Str2", "Str3")

	// you can also give a slice to a variadic function, with `...`:
	strs := []string{"a", "b"}
	variadic(strs...)
}
Output:+57
0: Hello
1: Goodbye

0: Str1
1: Str2
2: Str3

0: a
1: b

66 1553595274860 glotid
Sha1: 5d913901bb94de6e5bffc6162668c1c3c5a2cf23
GlotID: fapbtdyk1r
323 1553595276245 glotoutput
Sha1: 0d76c8baf40f3a0a9d1ff6aea74f1b5918469dce
Lang: Go
FileName: main.go
CodeFull:+120
// :glot
package main

import "fmt"

// :show start
func main() {
	func() {
		fmt.Println("Hello!")
	}()
}

// :show end
CodeToRun:+83
package main

import "fmt"

func main() {
	func() {
		fmt.Println("Hello!")
	}()
}
Output:+7
Hello!
66 1553595276411 glotid
Sha1: 0d76c8baf40f3a0a9d1ff6aea74f1b5918469dce
GlotID: fapbtevt1x
349 1553595277576 glotoutput
Sha1: 942beb94ef5ac966956b559673631ae065d379ab
Lang: Go
FileName: main.go
CodeFull:+133
// :glot
package main

import "fmt"

// :show start
func main() {
	func(str string) {
		fmt.Println(str)
	}("Hello!")
}

// :show end
CodeToRun:+96
package main

import "fmt"

func main() {
	func(str string) {
		fmt.Println(str)
	}("Hello!")
}
Output:+7
Hello!
66 1553595277744 glotid
Sha1: 942beb94ef5ac966956b559673631ae065d379ab
GlotID: fapbtfocqv
347 1553595278795 glotoutput
Sha1: e9adc102fdac5ab042b9fd4adade18528f31c81c
Lang: Go
FileName: main.go
CodeFull:+132
// :glot
package main

import "fmt"

// :show start
func main() {
	str := "Hello!"
	func() {
		fmt.Println(str)
	}()
}

// :show end
CodeToRun:+95
package main

import "fmt"

func main() {
	str := "Hello!"
	func() {
		fmt.Println(str)
	}()
}
Output:+7
Hello!
66 1553595279002 glotid
Sha1: e9adc102fdac5ab042b9fd4adade18528f31c81c
GlotID: fapbtgf9sv
1042 1553595280145 glotoutput
Sha1: e2a4c9b47b3040bd87cb988b1fd2404eb004e390
Lang: Go
FileName: main.go
CodeFull:+466
// :glot
package main

import "fmt"

// :show start
// intOp is a variable whose type is function that takes
// 2 integers as arguments and returns an integer
var intOp func(int, int) int

func intAdd(a, b int) int {
	return a + b
}

func main() {
	intOp = intAdd
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))

	// we can assign literal functions as well
	intOp = func(a, b int) int {
		return a * b
	}
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))
}

// :show end
CodeToRun:+429
package main

import "fmt"

// intOp is a variable whose type is function that takes
// 2 integers as arguments and returns an integer
var intOp func(int, int) int

func intAdd(a, b int) int {
	return a + b
}

func main() {
	intOp = intAdd
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))

	// we can assign literal functions as well
	intOp = func(a, b int) int {
		return a * b
	}
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))
}
Output:+32
intOp(2, 3) = 5
intOp(2, 3) = 6
66 1553595280311 glotid
Sha1: e2a4c9b47b3040bd87cb988b1fd2404eb004e390
GlotID: fapbth7eto
826 1553595281421 glotoutput
Sha1: a8a2cf44b25aabddb19813ffef1bc141118bf315
Lang: Go
FileName: main.go
CodeFull:+358
// :glot
package main

import "fmt"

// :show start
func funcAdd(a, b int) int {
	return a + b
}

func runFunc(a, b int, intOp func(int, int) int) {
	fmt.Printf("intOp(%d, %d) = %d\n", a, b, intOp(a, b))
}

func main() {
	runFunc(2, 3, funcAdd)

	// we can pass literal functions as well
	runFunc(2, 3, func(a, b int) int {
		return a * b
	})
}

// :show end
CodeToRun:+321
package main

import "fmt"

func funcAdd(a, b int) int {
	return a + b
}

func runFunc(a, b int, intOp func(int, int) int) {
	fmt.Printf("intOp(%d, %d) = %d\n", a, b, intOp(a, b))
}

func main() {
	runFunc(2, 3, funcAdd)

	// we can pass literal functions as well
	runFunc(2, 3, func(a, b int) int {
		return a * b
	})
}
Output:+32
intOp(2, 3) = 5
intOp(2, 3) = 6
66 1553595281589 glotid
Sha1: a8a2cf44b25aabddb19813ffef1bc141118bf315
GlotID: fapbthyrwm
738 1553595282799 glotoutput
Sha1: 448b8cb13af14429843725c0d5b3d22cd65b2828
Lang: Go
FileName: main.go
CodeFull:+330
// :glot
package main

import (
	"fmt"
)

// :show start

// MyError is a custom error type
type MyError struct {
	msg string
}

func (e *MyError) Error() string {
	return e.msg
}

// :show end

func main() {
	// :show start
	var err error = &MyError{msg: "This is custom error type"}
	fmt.Printf("err: %s\n", err)
	// :show end
}
CodeToRun:+261
package main

import (
	"fmt"
)

// MyError is a custom error type
type MyError struct {
	msg string
}

func (e *MyError) Error() string {
	return e.msg
}

func main() {
	var err error = &MyError{msg: "This is custom error type"}
	fmt.Printf("err: %s\n", err)
}
Output:+31
err: This is custom error type
66 1553595282966 glotid
Sha1: 448b8cb13af14429843725c0d5b3d22cd65b2828
GlotID: fapbtisaqr
2398 1553595284200 glotoutput
Sha1: f52024f519749cee055bced69feac30ec2843adb
Lang: Go
FileName: main.go
CodeFull:+1017
// :glot
// allow error
package main

import (
	"errors"
	"fmt"
)

// :show start
// FmtArgs formats args as a string. First argument should be format string
// and the rest are arguments to the format
func FmtArgs(args ...interface{}) string {
	if len(args) == 0 {
		return ""
	}
	format := args[0].(string)
	if len(args) == 1 {
		return format
	}
	return fmt.Sprintf(format, args[1:]...)
}

func panicWithMsg(defaultMsg string, args ...interface{}) {
	s := FmtArgs(args...)
	if s == "" {
		s = defaultMsg
	}
	fmt.Printf("%s\n", s)
	panic(s)
}

// PanicIf panics if cond is true
func PanicIf(cond bool, args ...interface{}) {
	if !cond {
		return
	}
	panicWithMsg("PanicIf: condition failed", args...)
}

// PanicIfErr panics if err is not nil
func PanicIfErr(err error, args ...interface{}) {
	if err == nil {
		return
	}
	panicWithMsg(err.Error(), args...)
}

func main() {
	PanicIfErr(nil)                              // nothing happens
	PanicIfErr(errors.New("there was an error")) // will panic
}

// :show end
CodeToRun:+965
package main

import (
	"errors"
	"fmt"
)

// FmtArgs formats args as a string. First argument should be format string
// and the rest are arguments to the format
func FmtArgs(args ...interface{}) string {
	if len(args) == 0 {
		return ""
	}
	format := args[0].(string)
	if len(args) == 1 {
		return format
	}
	return fmt.Sprintf(format, args[1:]...)
}

func panicWithMsg(defaultMsg string, args ...interface{}) {
	s := FmtArgs(args...)
	if s == "" {
		s = defaultMsg
	}
	fmt.Printf("%s\n", s)
	panic(s)
}

// PanicIf panics if cond is true
func PanicIf(cond bool, args ...interface{}) {
	if !cond {
		return
	}
	panicWithMsg("PanicIf: condition failed", args...)
}

// PanicIfErr panics if err is not nil
func PanicIfErr(err error, args ...interface{}) {
	if err == nil {
		return
	}
	panicWithMsg(err.Error(), args...)
}

func main() {
	PanicIfErr(nil)                              // nothing happens
	PanicIfErr(errors.New("there was an error")) // will panic
}
Output:+299
there was an error
panic: there was an error

goroutine 1 [running]:
main.panicWithMsg(0x4b4db2, 0x12, 0x0, 0x0, 0x0)
	/tmp/325991207/main.go:27 +0x13e
main.PanicIfErr(0x4c48e0, 0xc42000e1f0, 0x0, 0x0, 0x0)
	/tmp/325991207/main.go:43 +0x6c
main.main()
	/tmp/325991207/main.go:48 +0x92
exit status 2
66 1553595284369 glotid
Sha1: f52024f519749cee055bced69feac30ec2843adb
GlotID: fapbtjmcxc
750 1553595285473 glotoutput
Sha1: 9e9c2b5370ec29df42ca1c4902fb2e68fab05493
Lang: Go
FileName: main.go
CodeFull:+304
// :glot
package main

import "fmt"

// :show start
func logExit(name string) {
	fmt.Printf("Function %s returned\n", name)
}

func main() {
	fmt.Println("First main statement")
	defer logExit("main") // position of defer statement here does not matter
	fmt.Println("Last main statement")
}

// :show end
CodeToRun:+267
package main

import "fmt"

func logExit(name string) {
	fmt.Printf("Function %s returned\n", name)
}

func main() {
	fmt.Println("First main statement")
	defer logExit("main") // position of defer statement here does not matter
	fmt.Println("Last main statement")
}
Output:+64
First main statement
Last main statement
Function main returned
66 1553595285642 glotid
Sha1: 9e9c2b5370ec29df42ca1c4902fb2e68fab05493
GlotID: fapbtkdm2t
992 1553595286894 glotoutput
Sha1: 16d959a51afdf61ca4dc11fc8a8e2eaa0d3293e8
Lang: Go
FileName: main.go
CodeFull:+392
// :glot
// allow error
package main

import "fmt"

// :show start
func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	defer logNum(1)
	fmt.Println("First main statement")
	defer logNum(2)
	defer logNum(3)
	panic("panic occurred")

	fmt.Println("Last main statement") // not printed

	// not deferred since execution flow never reaches this line
	defer logNum(3)
}

// :show end
CodeToRun:+340
package main

import "fmt"

func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	defer logNum(1)
	fmt.Println("First main statement")
	defer logNum(2)
	defer logNum(3)
	panic("panic occurred")

	fmt.Println("Last main statement") // not printed

	// not deferred since execution flow never reaches this line
	defer logNum(3)
}
Output:+144
First main statement
Num 3
Num 2
Num 1
panic: panic occurred

goroutine 1 [running]:
main.main()
	/tmp/541521614/main.go:14 +0xf0
exit status 2
66 1553595287071 glotid
Sha1: 16d959a51afdf61ca4dc11fc8a8e2eaa0d3293e8
GlotID: fapbtl83oz
822 1553595288430 glotoutput
Sha1: a2fca1ed8ac800ef241c67e38629b41a14f8f9a7
Lang: Go
FileName: main.go
CodeFull:+353
// :glot
package main

import "fmt"

// :show start

func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	i := 1
	defer logNum(i) // deferred function call: logNum(1)
	fmt.Println("First main statement")
	i++
	defer logNum(i)     // deferred function call: logNum(2)
	defer logNum(i * i) // deferred function call: logNum(4)
}

// :show end
CodeToRun:+315
package main

import "fmt"

func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	i := 1
	defer logNum(i) // deferred function call: logNum(1)
	fmt.Println("First main statement")
	i++
	defer logNum(i)     // deferred function call: logNum(2)
	defer logNum(i * i) // deferred function call: logNum(4)
}
Output:+39
First main statement
Num 4
Num 2
Num 1
66 1553595288614 glotid
Sha1: a2fca1ed8ac800ef241c67e38629b41a14f8f9a7
GlotID: fapbtm59m5
778 1553595289680 glotoutput
Sha1: 7cb4c7c516268e692428fa7666b5f7b33ab76fae
Lang: Go
FileName: main.go
CodeFull:+350
// :glot
package main

import "fmt"

// :show start

func plusOne(i int) (result int) {
	// anonymous function must be called by adding ()
	defer func() { result++ }()

	// i is returned as result, which is updated by deferred function above
	// after execution of below return
	return i
}

func main() {
	fmt.Println(plusOne(1)) // 2
}

// :show end
CodeToRun:+312
package main

import "fmt"

func plusOne(i int) (result int) {
	// anonymous function must be called by adding ()
	defer func() { result++ }()

	// i is returned as result, which is updated by deferred function above
	// after execution of below return
	return i
}

func main() {
	fmt.Println(plusOne(1)) // 2
}
Output:+2
2
66 1553595289851 glotid
Sha1: 7cb4c7c516268e692428fa7666b5f7b33ab76fae
GlotID: fapbtmvunh
465 1553595291195 glotoutput
Sha1: e5635947de2f9aa63ccaef38a7867baf08bb599b
Lang: Go
FileName: main.go
CodeFull:+180
// :glot
package main

import "fmt"

// :show start

func main() {
	fmt.Print("Before if\n")
	if true {
		defer fmt.Print("inside if\n")
	}

	fmt.Print("Ater if\n")
}

// :show end
CodeToRun:+142
package main

import "fmt"

func main() {
	fmt.Print("Before if\n")
	if true {
		defer fmt.Print("inside if\n")
	}

	fmt.Print("Ater if\n")
}
Output:+28
Before if
Ater if
inside if
66 1553595291367 glotid
Sha1: e5635947de2f9aa63ccaef38a7867baf08bb599b
GlotID: fapbtnscer
398 1553595292526 glotoutput
Sha1: 6e5dcbc1c9c8fbf64e572d5a5559b99a2042f825
Lang: Go
FileName: main.go
CodeFull:+159
// :glot
package main

import "fmt"

// :show start

func main() {
	for i := 0; i < 2; i++ {
		defer func() {
			fmt.Printf("%d\n", i)
		}()
	}
}

// :show end
CodeToRun:+121
package main

import "fmt"

func main() {
	for i := 0; i < 2; i++ {
		defer func() {
			fmt.Printf("%d\n", i)
		}()
	}
}
Output:+4
2
2
66 1553595292695 glotid
Sha1: 6e5dcbc1c9c8fbf64e572d5a5559b99a2042f825
GlotID: fapbtoksrn
414 1553595294267 glotoutput
Sha1: a48844bc100dbc50c459ffd0389201be9a6dadc2
Lang: Go
FileName: main.go
CodeFull:+167
// :glot
package main

import "fmt"

// :show start

func main() {
	for i := 0; i < 2; i++ {
		defer func(i2 int) {
			fmt.Printf("%d\n", i2)
		}(i)
	}
}

// :show end
CodeToRun:+129
package main

import "fmt"

func main() {
	for i := 0; i < 2; i++ {
		defer func(i2 int) {
			fmt.Printf("%d\n", i2)
		}(i)
	}
}
Output:+4
1
0
66 1553595294442 glotid
Sha1: a48844bc100dbc50c459ffd0389201be9a6dadc2
GlotID: fapbtpm9k5
630 1553595295528 glotoutput
Sha1: 1e256e65a1277d4f935c8bc31116095f298447cd
Lang: Go
FileName: main.go
CodeFull:+202
// :glot
// allow error
package main

import "fmt"

// :show start
func foo() {
	defer fmt.Println("Exiting foo")
	panic("bar")
}

func main() {
	defer fmt.Println("Exiting main")
	foo()
}

// :show end
CodeToRun:+150
package main

import "fmt"

func foo() {
	defer fmt.Println("Exiting foo")
	panic("bar")
}

func main() {
	defer fmt.Println("Exiting main")
	foo()
}
Output:+162
Exiting foo
Exiting main
panic: bar

goroutine 1 [running]:
main.foo()
	/tmp/768337092/main.go:7 +0x95
main.main()
	/tmp/768337092/main.go:12 +0x7e
exit status 2
66 1553595295701 glotid
Sha1: 1e256e65a1277d4f935c8bc31116095f298447cd
GlotID: fapbtqd5c9
886 1553595296828 glotoutput
Sha1: 64fc9f4d528e40141968f786a7fed2ecf3c5300f
Lang: Go
FileName: main.go
CodeFull:+377
// :glot
// allow error
package main

import "fmt"

// :show start
func foo() {
	panic("bar")
}

func bar() {
	defer func() {
		if msg := recover(); msg != nil {
			fmt.Printf("Recovered with message %s\n", msg)
		}
	}()
	foo()
	fmt.Println("Never gets executed")
}

func main() {
	fmt.Println("Entering main")
	bar()
	fmt.Println("Exiting main the normal way")
}

// :show end
CodeToRun:+325
package main

import "fmt"

func foo() {
	panic("bar")
}

func bar() {
	defer func() {
		if msg := recover(); msg != nil {
			fmt.Printf("Recovered with message %s\n", msg)
		}
	}()
	foo()
	fmt.Println("Never gets executed")
}

func main() {
	fmt.Println("Entering main")
	bar()
	fmt.Println("Exiting main the normal way")
}
Output:+69
Entering main
Recovered with message bar
Exiting main the normal way
66 1553595296996 glotid
Sha1: 64fc9f4d528e40141968f786a7fed2ecf3c5300f
GlotID: fapbtr4z6x
1188 1553595298773 glotoutput
Sha1: 70c274c74c35d553eb3299db24ef84068cb26f3c
Lang: Go
FileName: main.go
CodeFull:+533
// :glot
package main

import (
	"fmt"
	"runtime"
)

// :show start
type Foo struct {
	Is []int
}

func (fp *Foo) Panic() (err error) {
	defer PanicRecovery(&err)
	fp.Is[0] = 5
	return nil
}

func PanicRecovery(err *error) {

	if r := recover(); r != nil {
		if _, ok := r.(runtime.Error); ok {
			//fmt.Println("Panicing")
			//panic(r)
			*err = r.(error)
		} else {
			*err = r.(error)
		}
	}
}

func main() {
	fp := &Foo{}
	if err := fp.Panic(); err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Println("ok")
}

// :show end
CodeToRun:+496
package main

import (
	"fmt"
	"runtime"
)

type Foo struct {
	Is []int
}

func (fp *Foo) Panic() (err error) {
	defer PanicRecovery(&err)
	fp.Is[0] = 5
	return nil
}

func PanicRecovery(err *error) {

	if r := recover(); r != nil {
		if _, ok := r.(runtime.Error); ok {
			//fmt.Println("Panicing")
			//panic(r)
			*err = r.(error)
		} else {
			*err = r.(error)
		}
	}
}

func main() {
	fp := &Foo{}
	if err := fp.Panic(); err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Println("ok")
}
Output:+44
Error: runtime error: index out of range
ok
66 1553595298972 glotid
Sha1: 70c274c74c35d553eb3299db24ef84068cb26f3c
GlotID: fapbtsaq7a
859 1553595301743 glotoutput
Sha1: a3f8167a088d85d0e0a4deb1d52ffb78d220f018
Lang: Go
FileName: main.go
CodeFull:+376
// :glot
package main

import (
	"fmt"
	"time"
)

// :show start
func main() {
	// create new channel of type string
	ch := make(chan string)

	// start new anonymous goroutine
	go func() {
		time.Sleep(time.Second)
		// send "Hello World" to channel
		ch <- "Hello World"
	}()
	// read from channel
	msg, ok := <-ch
	fmt.Printf("msg='%s', ok='%v'\n", msg, ok)
}

// :show end
CodeToRun:+339
package main

import (
	"fmt"
	"time"
)

func main() {
	// create new channel of type string
	ch := make(chan string)

	// start new anonymous goroutine
	go func() {
		time.Sleep(time.Second)
		// send "Hello World" to channel
		ch <- "Hello World"
	}()
	// read from channel
	msg, ok := <-ch
	fmt.Printf("msg='%s', ok='%v'\n", msg, ok)
}
Output:+29
msg='Hello World', ok='true'
66 1553595301917 glotid
Sha1: a3f8167a088d85d0e0a4deb1d52ffb78d220f018
GlotID: fapbtu2ewk
811 1553595303791 glotoutput
Sha1: 6b628f63aef51bdda23d821182c22fbe5c6e9486
Lang: Go
FileName: main.go
CodeFull:+371
// :glot
package main

import (
	"fmt"
	"time"
)

// :show start
func mult(x, y int) {
	fmt.Printf("%d * %d = %d\n", x, y, x*y)
}

// :show end

func main() {
	// :show start
	go mult(1, 2) // first execution, non-blocking
	go mult(3, 4) // second execution, also non-blocking
	// :show end

	// that's not how you do it in real code
	time.Sleep(200 * time.Millisecond)
}
CodeToRun:+303
package main

import (
	"fmt"
	"time"
)

func mult(x, y int) {
	fmt.Printf("%d * %d = %d\n", x, y, x*y)
}

func main() {
	go mult(1, 2) // first execution, non-blocking
	go mult(3, 4) // second execution, also non-blocking

	// that's not how you do it in real code
	time.Sleep(200 * time.Millisecond)
}
Output:+21
1 * 2 = 2
3 * 4 = 12
66 1553595303959 glotid
Sha1: 6b628f63aef51bdda23d821182c22fbe5c6e9486
GlotID: fapbtva8di
929 1553595305327 glotoutput
Sha1: b95c2782ec2b174c0b25f5e16b9a099713c40deb
Lang: Go
FileName: main.go
CodeFull:+323
// :glot
package main

import (
	"fmt"
	"sync"
)

// :show start
var wg sync.WaitGroup // 1

func routine(i int) {
	defer wg.Done() // 3
	fmt.Printf("routine %v finished\n", i)
}

func main() {
	wg.Add(10) // 2
	for i := 0; i < 10; i++ {
		go routine(i) // *
	}
	wg.Wait() // 4
	fmt.Println("main finished")
}

// :show end
CodeToRun:+286
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup // 1

func routine(i int) {
	defer wg.Done() // 3
	fmt.Printf("routine %v finished\n", i)
}

func main() {
	wg.Add(10) // 2
	for i := 0; i < 10; i++ {
		go routine(i) // *
	}
	wg.Wait() // 4
	fmt.Println("main finished")
}
Output:+204
routine 9 finished
routine 0 finished
routine 1 finished
routine 2 finished
routine 3 finished
routine 4 finished
routine 5 finished
routine 6 finished
routine 7 finished
routine 8 finished
main finished
66 1553595305497 glotid
Sha1: b95c2782ec2b174c0b25f5e16b9a099713c40deb
GlotID: fapbtw769r
2046 1553595306863 glotoutput
Sha1: 2deea8bacdd5cf6f5b65656ed42cdac027f0436c
Lang: Go
FileName: main.go
CodeFull:+960
// :glot
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start

var (
	semaphoreSize = 4

	mu                 sync.Mutex
	totalTasks         int
	curConcurrentTasks int
	maxConcurrentTasks int
)

func timeConsumingTask() {
	mu.Lock()
	totalTasks++
	curConcurrentTasks++
	if curConcurrentTasks > maxConcurrentTasks {
		maxConcurrentTasks = curConcurrentTasks
	}
	mu.Unlock()

	// in real system this would be a CPU intensive operation
	time.Sleep(10 * time.Millisecond)

	mu.Lock()
	curConcurrentTasks--
	mu.Unlock()
}

func main() {
	sem := make(chan struct{}, semaphoreSize)
	var wg sync.WaitGroup
	for i := 0; i < 32; i++ {
		// acquire semaphore
		sem <- struct{}{}
		wg.Add(1)

		go func() {
			timeConsumingTask()
			// release semaphore
			<-sem
			wg.Done()
		}()
	}

	// wait for all task to finish
	wg.Wait()

	fmt.Printf("total tasks         : %d\n", totalTasks)
	fmt.Printf("max concurrent tasks: %d\n", maxConcurrentTasks)
}

// :show end
CodeToRun:+922
package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	semaphoreSize = 4

	mu                 sync.Mutex
	totalTasks         int
	curConcurrentTasks int
	maxConcurrentTasks int
)

func timeConsumingTask() {
	mu.Lock()
	totalTasks++
	curConcurrentTasks++
	if curConcurrentTasks > maxConcurrentTasks {
		maxConcurrentTasks = curConcurrentTasks
	}
	mu.Unlock()

	// in real system this would be a CPU intensive operation
	time.Sleep(10 * time.Millisecond)

	mu.Lock()
	curConcurrentTasks--
	mu.Unlock()
}

func main() {
	sem := make(chan struct{}, semaphoreSize)
	var wg sync.WaitGroup
	for i := 0; i < 32; i++ {
		// acquire semaphore
		sem <- struct{}{}
		wg.Add(1)

		go func() {
			timeConsumingTask()
			// release semaphore
			<-sem
			wg.Done()
		}()
	}

	// wait for all task to finish
	wg.Wait()

	fmt.Printf("total tasks         : %d\n", totalTasks)
	fmt.Printf("max concurrent tasks: %d\n", maxConcurrentTasks)
}
Output:+49
total tasks         : 32
max concurrent tasks: 4
66 1553595307567 glotid
Sha1: 2deea8bacdd5cf6f5b65656ed42cdac027f0436c
GlotID: fapbtxeykh
615 1553595308730 glotoutput
Sha1: dbe2d98ae7dc4d5dfbeed0b715f43dd031256f90
Lang: Go
FileName: main.go
CodeFull:+256
// :glot
package main

import (
	"fmt"
)

// :show start

func foo(ch chan int) {
	ch <- 1
	ch <- 2
	close(ch)
}

func main() {
	ch := make(chan int)
	go foo(ch)
	for n := range ch {
		fmt.Println(n)
	}
	fmt.Println("channel is now closed")
}

// :show end
CodeToRun:+218
package main

import (
	"fmt"
)

func foo(ch chan int) {
	ch <- 1
	ch <- 2
	close(ch)
}

func main() {
	ch := make(chan int)
	go foo(ch)
	for n := range ch {
		fmt.Println(n)
	}
	fmt.Println("channel is now closed")
}
Output:+26
1
2
channel is now closed
66 1553595308902 glotid
Sha1: dbe2d98ae7dc4d5dfbeed0b715f43dd031256f90
GlotID: fapbty86cn
908 1553595310137 glotoutput
Sha1: 68078f2d51d12feef64509a2cd7a24adc4c11c68
Lang: Go
FileName: main.go
CodeFull:+399
// :glot
package main

import (
	"fmt"
	"time"
)

// :show start

func main() {
	chResult := make(chan int, 1)

	go func() {
		time.Sleep(1 * time.Second)
		chResult <- 5
		fmt.Printf("Worker finished")
	}()

	select {
	case res := <-chResult:
		fmt.Printf("Got %d from worker\n", res)
	case <-time.After(100 * time.Millisecond):
		fmt.Printf("Timed out before worker finished\n")
	}
}

// :show end
CodeToRun:+361
package main

import (
	"fmt"
	"time"
)

func main() {
	chResult := make(chan int, 1)

	go func() {
		time.Sleep(1 * time.Second)
		chResult <- 5
		fmt.Printf("Worker finished")
	}()

	select {
	case res := <-chResult:
		fmt.Printf("Got %d from worker\n", res)
	case <-time.After(100 * time.Millisecond):
		fmt.Printf("Timed out before worker finished\n")
	}
}
Output:+33
Timed out before worker finished
66 1553595310304 glotid
Sha1: 68078f2d51d12feef64509a2cd7a24adc4c11c68
GlotID: fapbtz28d4
982 1553595311575 glotoutput
Sha1: 159940fec5f3fae47ef5796e8db0ecb7f5d07d83
Lang: Go
FileName: main.go
CodeFull:+418
// :glot
package main

import (
	"fmt"
	"time"
)

func main() {
	// :show start
	ch := make(chan string)

	go func() {
		for s := range ch {
			fmt.Printf("received from channel: %s\n", s)
		}
		fmt.Print("range loop finished because ch was closed\n")
	}()

	ch <- "foo"
	close(ch)
	// :show end

	// only to simplify example, don't sleep to coordinate
	// goroutines in real code
	time.Sleep(100 * time.Millisecond)
}
CodeToRun:+379
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan string)

	go func() {
		for s := range ch {
			fmt.Printf("received from channel: %s\n", s)
		}
		fmt.Print("range loop finished because ch was closed\n")
	}()

	ch <- "foo"
	close(ch)

	// only to simplify example, don't sleep to coordinate
	// goroutines in real code
	time.Sleep(100 * time.Millisecond)
}
Output:+69
received from channel: foo
range loop finished because ch was closed
66 1553595311781 glotid
Sha1: 159940fec5f3fae47ef5796e8db0ecb7f5d07d83
GlotID: fapbtzxv90
612 1553595313315 glotoutput
Sha1: 19881d71571e37f5a13a37cded8c1e5f790b9381
Lang: Go
FileName: main.go
CodeFull:+230
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	ch := make(chan string)
	close(ch)
	v := <-ch
	fmt.Printf("Receive from closed channel immediately returns zero value of the type: %#v\n", v)
	// :show end
}
CodeToRun:+191
package main

import (
	"fmt"
)

func main() {
	ch := make(chan string)
	close(ch)
	v := <-ch
	fmt.Printf("Receive from closed channel immediately returns zero value of the type: %#v\n", v)
}
Output:+75
Receive from closed channel immediately returns zero value of the type: ""
66 1553595313482 glotid
Sha1: 19881d71571e37f5a13a37cded8c1e5f790b9381
GlotID: fapbu0ycxi
790 1553595315055 glotoutput
Sha1: 650f265dcfbb71045d0ef5e7d04867172f7dd5d7
Lang: Go
FileName: main.go
CodeFull:+320
// :glot
package main

import (
	"fmt"
)

func main() {
	// :show start
	ch := make(chan int)
	go func() {
		ch <- 1
		close(ch)
	}()
	v, isClosed := <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
	v, isClosed = <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
	// :show end
}
CodeToRun:+281
package main

import (
	"fmt"
)

func main() {
	ch := make(chan int)
	go func() {
		ch <- 1
		close(ch)
	}()
	v, isClosed := <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
	v, isClosed = <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
}
Output:+73
received 1, is channel closed: true
received 0, is channel closed: false
66 1553595315223 glotid
Sha1: 650f265dcfbb71045d0ef5e7d04867172f7dd5d7
GlotID: fapbu1znjp
435 1553595316182 glotoutput
Sha1: c060d9b4fdc117b233f6fc3da0efc083ae7593af
Lang: Go
FileName: main.go
CodeFull:+130
// :glot
// allow error
package main

func main() {
	// :show start
	ch := make(chan string)
	close(ch)
	close(ch)
	// :show end
}
CodeToRun:+76
package main

func main() {
	ch := make(chan string)
	close(ch)
	close(ch)
}
Output:+113
panic: close of closed channel

goroutine 1 [running]:
main.main()
	/tmp/338409185/main.go:6 +0x57
exit status 2
66 1553595316352 glotid
Sha1: c060d9b4fdc117b233f6fc3da0efc083ae7593af
GlotID: fapbu2nsy3
444 1553595317407 glotoutput
Sha1: d9243c8f861e86a72554584d986c0ff6cf09d103
Lang: Go
FileName: main.go
CodeFull:+135
// :glot
// allow error
package main

func main() {
	// :show start
	ch := make(chan int)
	close(ch)
	ch <- 5 // panics
	// :show end
}
CodeToRun:+81
package main

func main() {
	ch := make(chan int)
	close(ch)
	ch <- 5 // panics
}
Output:+112
panic: send on closed channel

goroutine 1 [running]:
main.main()
	/tmp/364630557/main.go:6 +0x63
exit status 2
66 1553595317575 glotid
Sha1: d9243c8f861e86a72554584d986c0ff6cf09d103
GlotID: fapbu3e2lo
1795 1553595319151 glotoutput
Sha1: fbe8b28d90db43b75ba8a641ec0fcdfa93c39332
Lang: Go
FileName: main.go
CodeFull:+824
// :glot
package main

import (
	"fmt"
	"time"
)

// :show start

func producer(ch chan int) {
	for i := 0; i < 5; i++ {
		if i%2 == 0 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		ch <- i
	}
}

func consumer(ch chan int) {
	total := 0
	for i := 0; i < 5; i++ {
		if i%2 == 1 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		total += <-ch
	}
}

func unbuffered() {
	timeStart := time.Now()
	ch := make(chan int)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Unbuffered version took %s\n", time.Since(timeStart))
}

func buffered() {
	timeStart := time.Now()
	ch := make(chan int, 5)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Buffered version took %s\n", time.Since(timeStart))
}

func main() {
	unbuffered()
	buffered()
}

// :show end
CodeToRun:+786
package main

import (
	"fmt"
	"time"
)

func producer(ch chan int) {
	for i := 0; i < 5; i++ {
		if i%2 == 0 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		ch <- i
	}
}

func consumer(ch chan int) {
	total := 0
	for i := 0; i < 5; i++ {
		if i%2 == 1 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		total += <-ch
	}
}

func unbuffered() {
	timeStart := time.Now()
	ch := make(chan int)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Unbuffered version took %s\n", time.Since(timeStart))
}

func buffered() {
	timeStart := time.Now()
	ch := make(chan int, 5)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Buffered version took %s\n", time.Since(timeStart))
}

func main() {
	unbuffered()
	buffered()
}
Output:+70
Unbuffered version took 51.059855ms
Buffered version took 32.807154ms
66 1553595319321 glotid
Sha1: fbe8b28d90db43b75ba8a641ec0fcdfa93c39332
GlotID: fapbu4fh4m
975 1553595320944 glotoutput
Sha1: 0cc674220a55946467297aa2d9ce4c29a7ec67dc
Lang: Go
FileName: main.go
CodeFull:+427
// :glot
package main

import (
	"fmt"
	"time"
)

// :show start
func main() {
	ch := make(chan int, 1)

end:
	for {
		select {
		case n := <-ch:
			fmt.Printf("Received %d from a channel\n", n)
			break end
		default:
			fmt.Print("Channel is empty\n")
			ch <- 8
		}
		// wait for channel to be filled with values
		// don't use time.Sleep() like that in production code
		time.Sleep(20 * time.Millisecond)
	}
}

// :show end
CodeToRun:+390
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int, 1)

end:
	for {
		select {
		case n := <-ch:
			fmt.Printf("Received %d from a channel\n", n)
			break end
		default:
			fmt.Print("Channel is empty\n")
			ch <- 8
		}
		// wait for channel to be filled with values
		// don't use time.Sleep() like that in production code
		time.Sleep(20 * time.Millisecond)
	}
}
Output:+43
Channel is empty
Received 8 from a channel
66 1553595321110 glotid
Sha1: 0cc674220a55946467297aa2d9ce4c29a7ec67dc
GlotID: fapbu5huml
1091 1553595322408 glotoutput
Sha1: e658b0cae090defbc2d89b632e3a2dabcebf4d68
Lang: Go
FileName: main.go
CodeFull:+482
// :glot
package main

import (
	"fmt"
)

// :show start
func worker(ch chan int, chQuit chan struct{}) {
	for {
		select {
		case v := <-ch:
			fmt.Printf("Got value %d\n", v)
		case <-chQuit:
			fmt.Printf("Signalled on quit channel. Finishing\n")
			chQuit <- struct{}{}
			return
		}
	}
}
func main() {
	ch, chQuit := make(chan int), make(chan struct{})
	go worker(ch, chQuit)
	ch <- 3
	chQuit <- struct{}{}

	// wait to be signalled back by the worker
	<-chQuit
}

// :show end
CodeToRun:+445
package main

import (
	"fmt"
)

func worker(ch chan int, chQuit chan struct{}) {
	for {
		select {
		case v := <-ch:
			fmt.Printf("Got value %d\n", v)
		case <-chQuit:
			fmt.Printf("Signalled on quit channel. Finishing\n")
			chQuit <- struct{}{}
			return
		}
	}
}
func main() {
	ch, chQuit := make(chan int), make(chan struct{})
	go worker(ch, chQuit)
	ch <- 3
	chQuit <- struct{}{}

	// wait to be signalled back by the worker
	<-chQuit
}
Output:+49
Got value 3
Signalled on quit channel. Finishing
66 1553595322575 glotid
Sha1: e658b0cae090defbc2d89b632e3a2dabcebf4d68
GlotID: fapbu6d8h2
1690 1553595324374 glotoutput
Sha1: fd50a8ecc34ed6166775f9b0c5a00e6a601d880e
Lang: Go
FileName: main.go
CodeFull:+811
// :glot
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start
var cache map[int]int
var mu sync.RWMutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.RLock()
	v, isCached := cache[n]
	mu.RUnlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

// :show end

func main() {
	// :show start
	cache = make(map[int]int)
	go accessCache()
	accessCache()
	// :show end

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
CodeToRun:+743
package main

import (
	"fmt"
	"sync"
	"time"
)

var cache map[int]int
var mu sync.RWMutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.RLock()
	v, isCached := cache[n]
	mu.RUnlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

func main() {
	cache = make(map[int]int)
	go accessCache()
	accessCache()

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
Output:+20
total: 30
total: 30
66 1553595324542 glotid
Sha1: fd50a8ecc34ed6166775f9b0c5a00e6a601d880e
GlotID: fapbu7jdid
1505 1553595326837 glotoutput
Sha1: 1c10de6ae3293ba67f3f16651f9b6b47fda4a581
Lang: Go
FileName: main.go
CodeFull:+479
// :glot, :name main.go, :run go run -race main.go, :allow error
package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

// :show start
var (
	n int
)

func main() {
	var wg sync.WaitGroup
	nCPU := runtime.NumCPU()
	nIter := 10
	for i := 0; i < nCPU; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < nIter; j++ {
				n++
				time.Sleep(time.Microsecond * 10)
			}
		}()
	}
	wg.Wait()
	fmt.Printf("n is: %d, expected: %d\n", n, nCPU*nIter)
}

// :show end
CodeToRun:+386
package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

var (
	n int
)

func main() {
	var wg sync.WaitGroup
	nCPU := runtime.NumCPU()
	nIter := 10
	for i := 0; i < nCPU; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < nIter; j++ {
				n++
				time.Sleep(time.Microsecond * 10)
			}
		}()
	}
	wg.Wait()
	fmt.Printf("n is: %d, expected: %d\n", n, nCPU*nIter)
}
RunCmd: go run -race main.go
Output:+495
n is: 19, expected: 20
==================
WARNING: DATA RACE
Read at 0x0000005ba3c0 by goroutine 7:
  main.main.func1()
      /tmp/353703938/main.go:23 +0x6d

Previous write at 0x0000005ba3c0 by goroutine 6:
  main.main.func1()
      /tmp/353703938/main.go:23 +0x89

Goroutine 7 (running) created at:
  main.main()
      /tmp/353703938/main.go:20 +0xcf

Goroutine 6 (running) created at:
  main.main()
      /tmp/353703938/main.go:20 +0xcf
==================
Found 1 data race(s)
exit status 66
66 1553595327374 glotid
Sha1: 1c10de6ae3293ba67f3f16651f9b6b47fda4a581
GlotID: fapbu98333
1550 1553595328675 glotoutput
Sha1: d14d99c8e3f04bb1a5bd3e9b3352c9a21c244eb8
Lang: Go
FileName: main.go
CodeFull:+731
// :glot, :name main.go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// :show start

// ReadLines reads all lines from a file
func ReadLines(filePath string) ([]string, error) {
	file, err := os.OpenFile(filePath, os.O_RDONLY, 0666)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	res := make([]string, 0)
	for scanner.Scan() {
		line := scanner.Bytes()
		res = append(res, string(line))
	}
	if err = scanner.Err(); err != nil {
		return nil, err
	}
	return res, nil
}

func main() {
	path := "main.go"
	lines, err := ReadLines(path)
	if err != nil {
		log.Fatalf("ReadLines failed with '%s'\n", err)
	}
	fmt.Printf("File %s has %d lines\n", path, len(lines))
}

// :show end
CodeToRun:+678
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// ReadLines reads all lines from a file
func ReadLines(filePath string) ([]string, error) {
	file, err := os.OpenFile(filePath, os.O_RDONLY, 0666)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	res := make([]string, 0)
	for scanner.Scan() {
		line := scanner.Bytes()
		res = append(res, string(line))
	}
	if err = scanner.Err(); err != nil {
		return nil, err
	}
	return res, nil
}

func main() {
	path := "main.go"
	lines, err := ReadLines(path)
	if err != nil {
		log.Fatalf("ReadLines failed with '%s'\n", err)
	}
	fmt.Printf("File %s has %d lines\n", path, len(lines))
}
Output:+26
File main.go has 36 lines
66 1553595328846 glotid
Sha1: d14d99c8e3f04bb1a5bd3e9b3352c9a21c244eb8
GlotID: fapbua3lr9
1098 1553595330006 glotoutput
Sha1: 018992d8a0300eba30208ac06cb7bde5a6c2521f
Lang: Go
FileName: main.go
CodeFull:+501
// :glot, :name main.go
package main

import (
	"fmt"
	"log"
	"os"
)

// :show start

// GetFileSize returns file size or error if e.g. file doesn't exist
func GetFileSize(path string) (int64, error) {
	st, err := os.Lstat(path)
	if err != nil {
		return -1, err
	}
	return st.Size(), nil
}

func main() {
	path := "main.go"
	size, err := GetFileSize(path)
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf("File %s is %d bytes in size\n", path, size)
}

// :show end
CodeToRun:+448
package main

import (
	"fmt"
	"log"
	"os"
)

// GetFileSize returns file size or error if e.g. file doesn't exist
func GetFileSize(path string) (int64, error) {
	st, err := os.Lstat(path)
	if err != nil {
		return -1, err
	}
	return st.Size(), nil
}

func main() {
	path := "main.go"
	size, err := GetFileSize(path)
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf("File %s is %d bytes in size\n", path, size)
}
Output:+34
File main.go is 448 bytes in size
66 1553595330197 glotid
Sha1: 018992d8a0300eba30208ac06cb7bde5a6c2521f
GlotID: fapbuaw3tc
1232 1553595331439 glotoutput
Sha1: b2f72d61c825b5d3bf11a02094212cea45bb8ace
Lang: Go
FileName: main.go
CodeFull:+363
// :glot, :name main.go
package main

import (
	"fmt"
	"log"
	"os"
)

// :show start

func main() {
	st, err := os.Stat("main.go")
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf(`Name: %s
Size: %d
IsDir: %v
Mode: %x
ModTime: %s
OS info: %#v
`, st.Name(), st.Size(), st.IsDir(), st.Mode, st.ModTime(), st.Sys())
}

// :show end
CodeToRun:+310
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	st, err := os.Stat("main.go")
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf(`Name: %s
Size: %d
IsDir: %v
Mode: %x
ModTime: %s
OS info: %#v
`, st.Name(), st.Size(), st.IsDir(), st.Mode, st.ModTime(), st.Sys())
}
Output:+443
Name: main.go
Size: 310
IsDir: false
Mode: 48ec30
ModTime: 2019-03-26 10:12:13.595588037 +0000 UTC
OS info: &syscall.Stat_t{Dev:0x3c, Ino:0x336796, Nlink:0x1, Mode:0x81a4, Uid:0x3e8, Gid:0x3e8, X__pad0:0, Rdev:0x0, Size:310, Blksize:4096, Blocks:8, Atim:syscall.Timespec{Sec:1553595133, Nsec:611588290}, Mtim:syscall.Timespec{Sec:1553595133, Nsec:595588037}, Ctim:syscall.Timespec{Sec:1553595133, Nsec:595588037}, X__unused:[3]int64{0, 0, 0}}
66 1553595331609 glotid
Sha1: b2f72d61c825b5d3bf11a02094212cea45bb8ace
GlotID: fapbubqtrq
1681 1553595332682 glotoutput
Sha1: b7b5f95ec46cde56f25433897d506db8e354e2a8
Lang: Go
FileName: main.go
CodeFull:+774
// :glot, :name main.go
package main

import (
	"fmt"
	"os"
)

// :show start

// IsPathxists returns true if a given path exists, false if it doesn't.
// It might return an error if e.g. file exists but you don't have
// access
func IsPathxists(path string) (bool, error) {
	_, err := os.Lstat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	// error other than not existing e.g. permission denied
	return false, err
}

func printExists(path string) {
	exists, err := IsPathxists(path)
	if err == nil {
		fmt.Printf("File '%s' exists: %v\n", path, exists)
	} else {
		fmt.Printf("IsFileExists('%s') failed with '%s'\n", path, err)
	}
}
func main() {
	printExists("main.go")
	printExists("non-existent-file.txt")
}

// :show end
CodeToRun:+721
package main

import (
	"fmt"
	"os"
)

// IsPathxists returns true if a given path exists, false if it doesn't.
// It might return an error if e.g. file exists but you don't have
// access
func IsPathxists(path string) (bool, error) {
	_, err := os.Lstat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	// error other than not existing e.g. permission denied
	return false, err
}

func printExists(path string) {
	exists, err := IsPathxists(path)
	if err == nil {
		fmt.Printf("File '%s' exists: %v\n", path, exists)
	} else {
		fmt.Printf("IsFileExists('%s') failed with '%s'\n", path, err)
	}
}
func main() {
	printExists("main.go")
	printExists("non-existent-file.txt")
}
Output:+71
File 'main.go' exists: true
File 'non-existent-file.txt' exists: false
66 1553595333195 glotid
Sha1: b7b5f95ec46cde56f25433897d506db8e354e2a8
GlotID: fapbucov40
1470 1553595334512 glotoutput
Sha1: 4c36a16feaee673f172840873123ee4246ef98da
Lang: Go
FileName: main.go
CodeFull:+710
// :glot, :no output, :name main.go
package main

import (
	"io"
	"log"
	"os"
)

// :show start
// CopyFile copies a src file to dst
func CopyFile(dst, src string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	_, err = io.Copy(dstFile, srcFile)
	err2 := dstFile.Close()
	if err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		// delete the destination if copy failed
		os.Remove(dst)
	}
	return err
}

// :show end

func main() {
	src := "main.go"
	dst := "main_copy.go"
	err := CopyFile(dst, src)
	if err != nil {
		log.Fatalf("CopyFile failed with '%s'\n", err)
	}
	os.Remove(dst)
}
CodeToRun:+645
package main

import (
	"io"
	"log"
	"os"
)

// CopyFile copies a src file to dst
func CopyFile(dst, src string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	_, err = io.Copy(dstFile, srcFile)
	err2 := dstFile.Close()
	if err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		// delete the destination if copy failed
		os.Remove(dst)
	}
	return err
}

func main() {
	src := "main.go"
	dst := "main_copy.go"
	err := CopyFile(dst, src)
	if err != nil {
		log.Fatalf("CopyFile failed with '%s'\n", err)
	}
	os.Remove(dst)
}
Output:+0
66 1553595334682 glotid
Sha1: 4c36a16feaee673f172840873123ee4246ef98da
GlotID: fapbudkpi8
909 1553595336254 glotoutput
Sha1: 212cd1c890ef5b5dcd77095154c912626ce91232
Lang: Go
FileName: main.go
CodeFull:+400
// :glot, :name main.go
package main

import (
	"fmt"
	"io/ioutil"
	"log"
)

// :show start
func main() {
	dir := "."
	fileInfos, err := ioutil.ReadDir(dir)
	if err != nil {
		log.Fatalf("ioutil.ReadDir('%s') failed with '%s'\n", dir, err)
	}
	for i, fi := range fileInfos {
		if i < 4 {
			fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		}
	}
}

// :show end
CodeToRun:+348
package main

import (
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	dir := "."
	fileInfos, err := ioutil.ReadDir(dir)
	if err != nil {
		log.Fatalf("ioutil.ReadDir('%s') failed with '%s'\n", dir, err)
	}
	for i, fi := range fileInfos {
		if i < 4 {
			fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		}
	}
}
Output:+46
Path: main.go, is dir: false, size: 348 bytes
66 1553595336422 glotid
Sha1: 212cd1c890ef5b5dcd77095154c912626ce91232
GlotID: fapbuem0ep
1096 1553595337692 glotoutput
Sha1: 63daccf5e68ca1610e46527cb77350c8c59934ad
Lang: Go
FileName: main.go
CodeFull:+466
// :glot
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

// :show start
func main() {
	nShown := 0
	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if nShown > 4 {
			return nil
		}
		nShown++
		fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		return nil
	})

	if err != nil {
		fmt.Printf("filepath.Walk failed with '%s'\n", err)
	}
}

// :show end
CodeToRun:+429
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func main() {
	nShown := 0
	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if nShown > 4 {
			return nil
		}
		nShown++
		fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		return nil
	})

	if err != nil {
		fmt.Printf("filepath.Walk failed with '%s'\n", err)
	}
}
Output:+86
Path: ., is dir: true, size: 4096 bytes
Path: main.go, is dir: false, size: 429 bytes
66 1553595337860 glotid
Sha1: 63daccf5e68ca1610e46527cb77350c8c59934ad
GlotID: fapbufgtqk
452 1553595338947 glotoutput
Sha1: 99de41208b66aaaec91b35cc359f12c74d285ff3
Lang: Go
FileName: main.go
CodeFull:+178
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start
	path := filepath.Join("dir", "file.txt")
	fmt.Printf("path: %s\n", path)
	// :show end
}
CodeToRun:+139
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	path := filepath.Join("dir", "file.txt")
	fmt.Printf("path: %s\n", path)
}
Output:+19
path: dir/file.txt
66 1553595339472 glotid
Sha1: 99de41208b66aaaec91b35cc359f12c74d285ff3
GlotID: fapbug7qwl
557 1553595340658 glotoutput
Sha1: f6384759f63aebb74dc6126ab64f644eafeb1f61
Lang: Go
FileName: main.go
CodeFull:+227
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start
	path := filepath.Join("dir", "file.txt")
	dir, file := filepath.Split(path)
	fmt.Printf("dir: %s, file: %s\n", dir, file)
	// :show end
}
CodeToRun:+188
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	path := filepath.Join("dir", "file.txt")
	dir, file := filepath.Split(path)
	fmt.Printf("dir: %s, file: %s\n", dir, file)
}
Output:+26
dir: dir/, file: file.txt
66 1553595340825 glotid
Sha1: f6384759f63aebb74dc6126ab64f644eafeb1f61
GlotID: fapbuh8e7h
485 1553595342192 glotoutput
Sha1: 96a8592e650f581a57ac737459ecd8e56b25e6d9
Lang: Go
FileName: main.go
CodeFull:+186
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start

	parts := filepath.SplitList("/usr/bin:/tmp")
	fmt.Printf("parts: %#v\n", parts)
	// :show end
}
CodeToRun:+147
package main

import (
	"fmt"
	"path/filepath"
)

func main() {

	parts := filepath.SplitList("/usr/bin:/tmp")
	fmt.Printf("parts: %#v\n", parts)
}
Output:+36
parts: []string{"/usr/bin", "/tmp"}
66 1553595342360 glotid
Sha1: 96a8592e650f581a57ac737459ecd8e56b25e6d9
GlotID: fapbui59sl
558 1553595344373 glotoutput
Sha1: 0b296fc21e7a7961aabced31923a26c214bbc739
Lang: Go
FileName: main.go
CodeFull:+223
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start
	path := filepath.Join("dir", "file.txt")
	file := filepath.Base(path)
	fmt.Printf("path: %s, file: %s\n", path, file)
	// :show end
}
CodeToRun:+184
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	path := filepath.Join("dir", "file.txt")
	file := filepath.Base(path)
	fmt.Printf("path: %s, file: %s\n", path, file)
}
Output:+35
path: dir/file.txt, file: file.txt
66 1553595344541 glotid
Sha1: 0b296fc21e7a7961aabced31923a26c214bbc739
GlotID: fapbujg1hc
544 1553595345879 glotoutput
Sha1: 49519b6918d10de6a4f1baa0d526cabb5945e786
Lang: Go
FileName: main.go
CodeFull:+219
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start
	path := filepath.Join("dir", "file.txt")
	dir := filepath.Dir(path)
	fmt.Printf("path: %s, dif: %s\n", path, dir)
	// :show end
}
CodeToRun:+180
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	path := filepath.Join("dir", "file.txt")
	dir := filepath.Dir(path)
	fmt.Printf("path: %s, dif: %s\n", path, dir)
}
Output:+29
path: dir/file.txt, dif: dir
66 1553595346048 glotid
Sha1: 49519b6918d10de6a4f1baa0d526cabb5945e786
GlotID: fapbukcbjs
421 1553595347619 glotoutput
Sha1: ebd51d0e8d59e434a0898a2611fd32cdf12ecd9a
Lang: Go
FileName: main.go
CodeFull:+167
// :glot
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	// :show start
	ext := filepath.Ext("file.txt")
	fmt.Printf("ext: %s\n", ext)
	// :show end
}
CodeToRun:+128
package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	ext := filepath.Ext("file.txt")
	fmt.Printf("ext: %s\n", ext)
}
Output:+10
ext: .txt
66 1553595347787 glotid
Sha1: ebd51d0e8d59e434a0898a2611fd32cdf12ecd9a
GlotID: fapbuldlv1
940 1553595349054 glotoutput
Sha1: e32eb9c104082c1a34c2f56b91a10d31f145b1e1
Lang: Go
FileName: main.go
CodeFull:+379
// :glot
package main

import (
	"fmt"
	"time"
)

func main() {
	// :show start
	t := time.Date(2017, 9, 4, 3, 38, 45, 0, time.UTC)
	fmt.Println(t.Format("2006-02-01 15:04:05.000 MST"))
	fmt.Println(t.Format("2006-02-1 15pm"))
	fmt.Println(t.Format("Jan 06 Mon 2 01"))
	fmt.Println(t.Format("January 6 Mon 2 1"))
	fmt.Println(t.Format("Month: Jan '1', '01', _2"))
	// :show end
}
CodeToRun:+340
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Date(2017, 9, 4, 3, 38, 45, 0, time.UTC)
	fmt.Println(t.Format("2006-02-01 15:04:05.000 MST"))
	fmt.Println(t.Format("2006-02-1 15pm"))
	fmt.Println(t.Format("Jan 06 Mon 2 01"))
	fmt.Println(t.Format("January 6 Mon 2 1"))
	fmt.Println(t.Format("Month: Jan '1', '01', _2"))
}
Output:+104
2017-04-09 03:38:45.000 UTC
2017-04-9 03am
Sep 17 Mon 4 09
September 6 Mon 4 9
Month: Sep '9', '09',  4
66 1553595349221 glotid
Sha1: e32eb9c104082c1a34c2f56b91a10d31f145b1e1
GlotID: fapbum8clv
792 1553595350344 glotoutput
Sha1: e216279918ea87af05dd256f1fce9b115bd6415f
Lang: Go
FileName: main.go
CodeFull:+343
// :glot
package main

import (
	"fmt"
	"log"
	"time"
)

func main() {
	// :show start
	s := "2017-04-09 03:38:45.000 UTC"
	t, err := time.Parse("2006-02-01 15:04:05.000 MST", s)
	if err != nil {
		log.Fatalf("time.Parse() failed wiht '%s'\n", err)
	}
	fmt.Printf("year: %d, month: %d, day: %d\n", t.Year(), t.Month(), t.Day())
	// :show end
}
CodeToRun:+304
package main

import (
	"fmt"
	"log"
	"time"
)

func main() {
	s := "2017-04-09 03:38:45.000 UTC"
	t, err := time.Parse("2006-02-01 15:04:05.000 MST", s)
	if err != nil {
		log.Fatalf("time.Parse() failed wiht '%s'\n", err)
	}
	fmt.Printf("year: %d, month: %d, day: %d\n", t.Year(), t.Month(), t.Day())
}
Output:+29
year: 2017, month: 9, day: 4
66 1553595350512 glotid
Sha1: e216279918ea87af05dd256f1fce9b115bd6415f
GlotID: fapbun003h
841 1553595352023 glotoutput
Sha1: 8ab12f13c94f77d5166be67c025bba57e17faa0c
Lang: Go
FileName: main.go
CodeFull:+312
// :glot, :name main.go
// :run go run main.go -echo echo-arg additional arg
package main

import (
	"fmt"
	"os"
)

// :show start
func main() {
	fmt.Printf("Name of executable: '%s'\n", os.Args[0])
	args := os.Args[1:]
	for i, arg := range args {
		fmt.Printf("Arg %d, value: '%s'\n", i, arg)
	}
}

// :show end
CodeToRun:+207
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Printf("Name of executable: '%s'\n", os.Args[0])
	args := os.Args[1:]
	for i, arg := range args {
		fmt.Printf("Arg %d, value: '%s'\n", i, arg)
	}
}
RunCmd: go run main.go -echo echo-arg additional arg
Output:+153
Name of executable: '/tmp/go-build145371810/b001/exe/main'
Arg 0, value: '-echo'
Arg 1, value: 'echo-arg'
Arg 2, value: 'additional'
Arg 3, value: 'arg'
66 1553595352230 glotid
Sha1: 8ab12f13c94f77d5166be67c025bba57e17faa0c
GlotID: fapbuo0t36
1239 1553595353561 glotoutput
Sha1: c66b0487b3683fa96da392951ef6128c0c9e593a
Lang: Go
FileName: main.go
CodeFull:+562
// :glot
package main

import (
	"fmt"
	"log"
	"os/exec"
	"sync/atomic"
	"time"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	var timedOut int32
	timeout := 1 * time.Millisecond
	stopTimer := time.AfterFunc(timeout, func() {
		cmd.Process.Kill()
		atomic.StoreInt32(&timedOut, 1)
	})

	err = cmd.Wait()
	stopTimer.Stop()
	didTimeout := atomic.LoadInt32(&timedOut) != 0
	fmt.Printf("didTimeout: %v, err: %v\n", didTimeout, err)
	// :show end
}
CodeToRun:+523
package main

import (
	"fmt"
	"log"
	"os/exec"
	"sync/atomic"
	"time"
)

func main() {
	cmd := exec.Command("go", "version")

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	var timedOut int32
	timeout := 1 * time.Millisecond
	stopTimer := time.AfterFunc(timeout, func() {
		cmd.Process.Kill()
		atomic.StoreInt32(&timedOut, 1)
	})

	err = cmd.Wait()
	stopTimer.Stop()
	didTimeout := atomic.LoadInt32(&timedOut) != 0
	fmt.Printf("didTimeout: %v, err: %v\n", didTimeout, err)
}
Output:+38
didTimeout: true, err: signal: killed
66 1553595353729 glotid
Sha1: c66b0487b3683fa96da392951ef6128c0c9e593a
GlotID: fapbuowy9y
948 1553595355095 glotoutput
Sha1: 5bc84c408c9097098ca4930cc94cfdc1c97b1b9f
Lang: Go
FileName: main.go
CodeFull:+391
// :glot, :allow error
package main

import (
	"log"
	"os/exec"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")
	_, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("first cmd.CombintedOutput() failed with '%s'\n", err)
	}

	_, err = cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("second cmd.CombintedOutput() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+338
package main

import (
	"log"
	"os/exec"
)

func main() {
	cmd := exec.Command("go", "version")
	_, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("first cmd.CombintedOutput() failed with '%s'\n", err)
	}

	_, err = cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("second cmd.CombintedOutput() failed with '%s'\n", err)
	}
}
Output:+102
2019/03/26 10:12:37 second cmd.CombintedOutput() failed with 'exec: Stdout already set'
exit status 1
66 1553595355301 glotid
Sha1: 5bc84c408c9097098ca4930cc94cfdc1c97b1b9f
GlotID: fapbuptt90
1197 1553595356836 glotoutput
Sha1: 9fc3d05b4d352fe3895491d7875647365dfce57d
Lang: Go
FileName: main.go
CodeFull:+534
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`
// :show end

func main() {
	// :show start
	var doc map[string]interface{}
	err := json.Unmarshal([]byte(jsonStr), &doc)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("doc: %#v\n", doc)
	name, ok := doc["name"].(string)
	if !ok {
		log.Fatalf("doc has no key 'name' or its value is not string\n")
	}
	fmt.Printf("name: %#v\n", name)
	// :show end
}
CodeToRun:+467
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`

func main() {
	var doc map[string]interface{}
	err := json.Unmarshal([]byte(jsonStr), &doc)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("doc: %#v\n", doc)
	name, ok := doc["name"].(string)
	if !ok {
		log.Fatalf("doc has no key 'name' or its value is not string\n")
	}
	fmt.Printf("name: %#v\n", name)
}
Output:+80
doc: map[string]interface {}{"name":"Jane", "age":24, "city":"ny"}
name: "Jane"
66 1553595357041 glotid
Sha1: 9fc3d05b4d352fe3895491d7875647365dfce57d
GlotID: fapbuqvy1c
2731 1553595358617 glotoutput
Sha1: 25c1b6dd899b59fc6b4618e01b7e36d1781e7fd0
Lang: Go
FileName: main.go
CodeFull:+1252
// :glot
package main

import (
	"encoding/json"
	"fmt"
)

// :show start
var jsonBlob = []byte(`
{
  "_total": 1,
  "_links": {
	"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=0",
	"next": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=25"
  },
  "subscriptions": [
	{
	  "created_at": "2011-11-23T02:53:17Z",
	  "_id": "abcdef0000000000000000000000000000000000",
	  "_links": {
		"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions/bar"
	  },
	  "user": {
		"display_name": "bar",
		"_id": 123456,
		"name": "bar",
		"created_at": "2011-06-16T18:23:11Z",
		"updated_at": "2014-10-23T02:20:51Z",
		"_links": {
		  "self": "https://api.twitch.tv/kraken/users/bar"
		}
	  }
	}
  ]
}
`)

// :show end

func main() {
	// :show start
	var js struct {
		Total int `json:"_total"`
		Links struct {
			Next string `json:"next"`
		} `json:"_links"`
		Subs []struct {
			Created string `json:"created_at"`
			User    struct {
				Name string `json:"name"`
				ID   int    `json:"_id"`
			} `json:"user"`
		} `json:"subscriptions"`
	}

	err := json.Unmarshal(jsonBlob, &js)
	if err != nil {
		fmt.Println("error:", err)
	}
	fmt.Printf("%+v", js)
	// :show end
}
CodeToRun:+1184
package main

import (
	"encoding/json"
	"fmt"
)

var jsonBlob = []byte(`
{
  "_total": 1,
  "_links": {
	"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=0",
	"next": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=25"
  },
  "subscriptions": [
	{
	  "created_at": "2011-11-23T02:53:17Z",
	  "_id": "abcdef0000000000000000000000000000000000",
	  "_links": {
		"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions/bar"
	  },
	  "user": {
		"display_name": "bar",
		"_id": 123456,
		"name": "bar",
		"created_at": "2011-06-16T18:23:11Z",
		"updated_at": "2014-10-23T02:20:51Z",
		"_links": {
		  "self": "https://api.twitch.tv/kraken/users/bar"
		}
	  }
	}
  ]
}
`)

func main() {
	var js struct {
		Total int `json:"_total"`
		Links struct {
			Next string `json:"next"`
		} `json:"_links"`
		Subs []struct {
			Created string `json:"created_at"`
			User    struct {
				Name string `json:"name"`
				ID   int    `json:"_id"`
			} `json:"user"`
		} `json:"subscriptions"`
	}

	err := json.Unmarshal(jsonBlob, &js)
	if err != nil {
		fmt.Println("error:", err)
	}
	fmt.Printf("%+v", js)
}
Output:+175
{Total:1 Links:{Next:https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=25} Subs:[{Created:2011-11-23T02:53:17Z User:{Name:bar ID:123456}}]}
66 1553595358787 glotid
Sha1: 25c1b6dd899b59fc6b4618e01b7e36d1781e7fd0
GlotID: fapburxb7x
2590 1553595360112 glotoutput
Sha1: bd80c8f5f0d5451925a8b424eea1f17fb0389a23
Lang: Go
FileName: main.go
CodeFull:+1202
// :glot
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

// :show start
type Student struct {
	Name     string
	Standard int `json:"Standard"`
}

func decodeFromReader(r io.Reader) ([]*Student, error) {
	var res []*Student

	dec := json.NewDecoder(r)
	err := dec.Decode(&res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func decodeFromString(s string) ([]*Student, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) ([]*Student, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

// :show end

const jsonStr = `
[
    {
        "Name" : "John Doe",
        "Standard" : 4
    },
    {
        "Name" : "Peter Parker",
        "Standard" : 11
    },
    {
        "Name" : "Bilbo Baggins",
        "Standard" : 150
    }
]
`

func main() {
	// studentList, err := decodeFromFile("data.json")
	studentList, err := decodeFromString(jsonStr)
	if err != nil {
		log.Fatalf("decodeFromString() failed with '%s'\n", err)
	}
	for _, student := range studentList {
		fmt.Printf("Student: %s, standard: %d\n", student.Name, student.Standard)
	}
}
CodeToRun:+1164
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

type Student struct {
	Name     string
	Standard int `json:"Standard"`
}

func decodeFromReader(r io.Reader) ([]*Student, error) {
	var res []*Student

	dec := json.NewDecoder(r)
	err := dec.Decode(&res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func decodeFromString(s string) ([]*Student, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) ([]*Student, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

const jsonStr = `
[
    {
        "Name" : "John Doe",
        "Standard" : 4
    },
    {
        "Name" : "Peter Parker",
        "Standard" : 11
    },
    {
        "Name" : "Bilbo Baggins",
        "Standard" : 150
    }
]
`

func main() {
	// studentList, err := decodeFromFile("data.json")
	studentList, err := decodeFromString(jsonStr)
	if err != nil {
		log.Fatalf("decodeFromString() failed with '%s'\n", err)
	}
	for _, student := range studentList {
		fmt.Printf("Student: %s, standard: %d\n", student.Name, student.Standard)
	}
}
Output:+105
Student: John Doe, standard: 4
Student: Peter Parker, standard: 11
Student: Bilbo Baggins, standard: 150
66 1553595360280 glotid
Sha1: bd80c8f5f0d5451925a8b424eea1f17fb0389a23
GlotID: fapbustdip
3013 1553595361546 glotoutput
Sha1: 44c351ddf34877baa3bab37ea4d4165a41110522
Lang: Go
FileName: main.go
CodeFull:+1423
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	// :show start
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
	// :show end
}

// :show start
type customTime time.Time

const customTimeFormat = `"2006-02-01"`

func (ct customTime) MarshalJSON() ([]byte, error) {
	t := time.Time(ct)
	s := t.Format(customTimeFormat)
	return []byte(s), nil
}

func (ct *customTime) UnmarshalJSON(d []byte) error {
	t, err := time.Parse(customTimeFormat, string(d))
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

// :show end

func custom() {
	// :show start
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time JSON: %s\n", string(d))
	var decoded Event2
	err = json.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
	// :show end
}

func main() {
	// :show start
	notCustom()
	custom()
	// :show end
}
CodeToRun:+1295
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
}

type customTime time.Time

const customTimeFormat = `"2006-02-01"`

func (ct customTime) MarshalJSON() ([]byte, error) {
	t := time.Time(ct)
	s := t.Format(customTimeFormat)
	return []byte(s), nil
}

func (ct *customTime) UnmarshalJSON(d []byte) error {
	t, err := time.Parse(customTimeFormat, string(d))
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

func custom() {
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time JSON: %s\n", string(d))
	var decoded Event2
	err = json.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
}

func main() {
	notCustom()
	custom()
}
Output:+176
Standard time JSON: {"What":"earthquake","When":"2019-03-26T10:12:44.11848256Z"}

Custom time JSON: {"What":"earthquake","When":"2019-26-03"}
Decoded custom time: "2019-26-03"
66 1553595361715 glotid
Sha1: 44c351ddf34877baa3bab37ea4d4165a41110522
GlotID: fapbuto3xr
1340 1553595363016 glotoutput
Sha1: c871fb399e1b7153618299acc0e55b24d5ef79ea
Lang: Go
FileName: main.go
CodeFull:+617
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type MyStruct struct {
	uuid string
	Name string
}

func (m MyStruct) MarshalJSON() ([]byte, error) {
	j, err := json.Marshal(struct {
		Uuid string
		Name string
	}{
		Uuid: m.uuid,
		Name: m.Name,
	})
	if err != nil {
		return nil, err
	}
	return j, nil
}

// :show end

func main() {
	// :show start
	s := MyStruct{
		uuid: "uid-john",
		Name: "John",
	}
	d, err := json.Marshal(&s)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

	// :show end
}
CodeToRun:+549
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

type MyStruct struct {
	uuid string
	Name string
}

func (m MyStruct) MarshalJSON() ([]byte, error) {
	j, err := json.Marshal(struct {
		Uuid string
		Name string
	}{
		Uuid: m.uuid,
		Name: m.Name,
	})
	if err != nil {
		return nil, err
	}
	return j, nil
}

func main() {
	s := MyStruct{
		uuid: "uid-john",
		Name: "John",
	}
	d, err := json.Marshal(&s)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

}
Output:+58
Person in compact JSON: {"Uuid":"uid-john","Name":"John"}
66 1553595363186 glotid
Sha1: c871fb399e1b7153618299acc0e55b24d5ef79ea
GlotID: fapbuujmf4
2244 1553595364418 glotoutput
Sha1: 5d77bfc0b7701a8ffe2a70eb38fd82f7257520ed
Lang: Go
FileName: main.go
CodeFull:+889
// :glot
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"text/tabwriter"
)

// :show start
func printSerialized(v interface{}, w io.Writer) {
	d, err := json.Marshal(v)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Fprintf(w, "%T\t%s\n", v, string(d))
}

// :show end

func main() {
	// :show start
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 5, 0, 1, ' ', 0)
	fmt.Fprint(w, "Go type:\tJSON value:\n")
	fmt.Fprint(w, "\t\n")
	printSerialized(nil, w)
	printSerialized(5, w)
	printSerialized(8.23, w)
	printSerialized("john", w)
	ai := []int{5, 4, 18}
	printSerialized(ai, w)
	a := []interface{}{4, "string"}
	printSerialized(a, w)
	d := map[string]interface{}{
		"i": 5,
		"s": "foo",
	}
	printSerialized(d, w)
	s := struct {
		Name string
		Age  int
	}{
		Name: "John",
		Age:  37,
	}
	printSerialized(s, w)
	w.Flush()
	// :show end
}
CodeToRun:+821
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"text/tabwriter"
)

func printSerialized(v interface{}, w io.Writer) {
	d, err := json.Marshal(v)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Fprintf(w, "%T\t%s\n", v, string(d))
}

func main() {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 5, 0, 1, ' ', 0)
	fmt.Fprint(w, "Go type:\tJSON value:\n")
	fmt.Fprint(w, "\t\n")
	printSerialized(nil, w)
	printSerialized(5, w)
	printSerialized(8.23, w)
	printSerialized("john", w)
	ai := []int{5, 4, 18}
	printSerialized(ai, w)
	a := []interface{}{4, "string"}
	printSerialized(a, w)
	d := map[string]interface{}{
		"i": 5,
		"s": "foo",
	}
	printSerialized(d, w)
	s := struct {
		Name string
		Age  int
	}{
		Name: "John",
		Age:  37,
	}
	printSerialized(s, w)
	w.Flush()
}
Output:+417
Go type:                        JSON value:
                                
<nil>                           null
int                             5
float64                         8.23
string                          "john"
[]int                           [5,4,18]
[]interface {}                  [4,"string"]
map[string]interface {}         {"i":5,"s":"foo"}
struct { Name string; Age int } {"Name":"John","Age":37}
66 1553595364586 glotid
Sha1: 5d77bfc0b7701a8ffe2a70eb38fd82f7257520ed
GlotID: fapbuvdnrm
2260 1553595366239 glotoutput
Sha1: e2fbf2eaa37d21190cba0094a83f14faca065b4c
Lang: Go
FileName: main.go
CodeFull:+1062
// :glot
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
)

// :show start
var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>
	<person age="23">
		<address>
			<city>Austin</city>
			<state>TX</state>
		</address>
	</person>
</people>`

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

// :show end

func main() {
	// :show start
	r := bytes.NewBufferString(xmlStr)
	decoder := xml.NewDecoder(r)
	for {
		t, err := decoder.Token()
		if err == io.EOF {
			// io.EOF is a successful end
			break
		}
		if err != nil {
			fmt.Printf("decoder.Token() failed with '%s'\n", err)
			break
		}

		switch v := t.(type) {

		case xml.StartElement:
			if v.Name.Local == "address" {
				var address Address
				err = decoder.DecodeElement(&address, &v)
				if err != nil {
					fmt.Printf("decoder.DecodeElement() failed with '%s'\n", err)
					break
				}
				fmt.Printf("%+#v\n", address)
			}
		}
	}
	// :show end
}
CodeToRun:+994
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
)

var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>
	<person age="23">
		<address>
			<city>Austin</city>
			<state>TX</state>
		</address>
	</person>
</people>`

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

func main() {
	r := bytes.NewBufferString(xmlStr)
	decoder := xml.NewDecoder(r)
	for {
		t, err := decoder.Token()
		if err == io.EOF {
			// io.EOF is a successful end
			break
		}
		if err != nil {
			fmt.Printf("decoder.Token() failed with '%s'\n", err)
			break
		}

		switch v := t.(type) {

		case xml.StartElement:
			if v.Name.Local == "address" {
				var address Address
				err = decoder.DecodeElement(&address, &v)
				if err != nil {
					fmt.Printf("decoder.DecodeElement() failed with '%s'\n", err)
					break
				}
				fmt.Printf("%+#v\n", address)
			}
		}
	}
}
Output:+87
main.Address{City:"San Francisco", State:"CA"}
main.Address{City:"Austin", State:"TX"}
66 1553595366408 glotid
Sha1: e2fbf2eaa37d21190cba0094a83f14faca065b4c
GlotID: fapbuwgq0p
2835 1553595367896 glotoutput
Sha1: 261e29c04854a80075c5e78c38144fed302c0d2a
Lang: Go
FileName: main.go
CodeFull:+1261
// :glot
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"log"
	"os"
)

var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

// :show start
func decodeFromReader(r io.Reader) (*People, error) {
	var people People
	decoder := xml.NewDecoder(r)
	err := decoder.Decode(&people)
	if err != nil {
		return nil, err
	}
	return &people, nil
}

func decodeFromString(s string) (*People, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) (*People, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

// :show end

func main() {
	people, err := decodeFromString(xmlStr)
	if err != nil {
		log.Fatalf("decodeFromString failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
}
CodeToRun:+1223
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"log"
	"os"
)

var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

func decodeFromReader(r io.Reader) (*People, error) {
	var people People
	decoder := xml.NewDecoder(r)
	err := decoder.Decode(&people)
	if err != nil {
		return nil, err
	}
	return &people, nil
}

func decodeFromString(s string) (*People, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) (*People, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

func main() {
	people, err := decodeFromString(xmlStr)
	if err != nil {
		log.Fatalf("decodeFromString failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
}
Output:+232
&main.People{Person:[]main.Person{main.Person{Age:34, FirstName:"John", Address:main.Address{City:(*string)(0xc42000e400), State:"CA"}}, main.Person{Age:23, FirstName:"Julia", Address:main.Address{City:(*string)(nil), State:""}}}}

66 1553595368065 glotid
Sha1: 261e29c04854a80075c5e78c38144fed302c0d2a
GlotID: fapbuxg7s7
961 1553595369432 glotoutput
Sha1: 7b063ca0e3f28d31eb7bab4963f69c3c5b22944c
Lang: Go
FileName: main.go
CodeFull:+443
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowXMLName struct {
	XMLName xml.Name `xml:"data"`
	N       int      `xml:"n"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowXMLName{
		N: 5,
	}
	printXML(v)

	// :show end
}
CodeToRun:+374
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowXMLName struct {
	XMLName xml.Name `xml:"data"`
	N       int      `xml:"n"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowXMLName{
		N: 5,
	}
	printXML(v)

}
Output:+28
XML: <data><n>5</n></data>

66 1553595369607 glotid
Sha1: 7b063ca0e3f28d31eb7bab4963f69c3c5b22944c
GlotID: fapbuyd4mj
1067 1553595371172 glotoutput
Sha1: 4fc7a070441142233a6ca47fd224872a3242203e
Lang: Go
FileName: main.go
CodeFull:+487
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowOmit struct {
	Name          string `xml:"name"`
	NotSerialized string `xml:"-"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowOmit{
		Name:          "John",
		NotSerialized: "Connor",
	}
	printXML(v)
	// :show end
}
CodeToRun:+419
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowOmit struct {
	Name          string `xml:"name"`
	NotSerialized string `xml:"-"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowOmit{
		Name:          "John",
		NotSerialized: "Connor",
	}
	printXML(v)
}
Output:+45
XML: <ShowOmit><name>John</name></ShowOmit>

66 1553595371344 glotid
Sha1: 4fc7a070441142233a6ca47fd224872a3242203e
GlotID: fapbuzef4c
1101 1553595372709 glotoutput
Sha1: 2b3b6c1d9969aee475c2a82121afe4792a0c86b4
Lang: Go
FileName: main.go
CodeFull:+493
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowOmitEmpty struct {
	NonEmpty string `xml:",omitempty"`
	Empty    string `xml:",omitempty"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowOmitEmpty{
		NonEmpty: "non empty",
		Empty:    "",
	}
	printXML(v)

	// :show end
}
CodeToRun:+424
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowOmitEmpty struct {
	NonEmpty string `xml:",omitempty"`
	Empty    string `xml:",omitempty"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowOmitEmpty{
		NonEmpty: "non empty",
		Empty:    "",
	}
	printXML(v)

}
Output:+68
XML: <ShowOmitEmpty><NonEmpty>non empty</NonEmpty></ShowOmitEmpty>

66 1553595372889 glotid
Sha1: 2b3b6c1d9969aee475c2a82121afe4792a0c86b4
GlotID: fapbv0bfe0
891 1553595374272 glotoutput
Sha1: f182a04d536649ed920827ddbc51567df96fe28f
Lang: Go
FileName: main.go
CodeFull:+403
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowAttr struct {
	B bool `xml:"n,attr"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowAttr{
		B: true,
	}
	printXML(v)

	// :show end
}
CodeToRun:+335
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowAttr struct {
	B bool `xml:"n,attr"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowAttr{
		B: true,
	}
	printXML(v)

}
Output:+37
XML: <ShowAttr n="true"></ShowAttr>

66 1553595374441 glotid
Sha1: f182a04d536649ed920827ddbc51567df96fe28f
GlotID: fapbv18v6a
921 1553595375885 glotoutput
Sha1: fdd105d0c195932125fc9e684150b9ce53838bf4
Lang: Go
FileName: main.go
CodeFull:+417
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowCharData struct {
	S string `xml:",chardata"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowCharData{
		S: "str",
	}
	printXML(v)

	// :show end
}
CodeToRun:+349
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowCharData struct {
	S string `xml:",chardata"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowCharData{
		S: "str",
	}
	printXML(v)

}
Output:+39
XML: <ShowCharData>str</ShowCharData>

66 1553595376055 glotid
Sha1: fdd105d0c195932125fc9e684150b9ce53838bf4
GlotID: fapbv27gcy
916 1553595377662 glotoutput
Sha1: 9f1b143344fbc8945c9497bbe6db02bfc9480bb5
Lang: Go
FileName: main.go
CodeFull:+411
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowCData struct {
	S string `xml:",cdata"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowCData{
		S: "cdata",
	}
	printXML(v)

	// :show end
}
CodeToRun:+342
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowCData struct {
	S string `xml:",cdata"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowCData{
		S: "cdata",
	}
	printXML(v)

}
Output:+47
XML: <ShowCData><![CDATA[cdata]]></ShowCData>

66 1553595377874 glotid
Sha1: 9f1b143344fbc8945c9497bbe6db02bfc9480bb5
GlotID: fapbv3afxi
1071 1553595379365 glotoutput
Sha1: c101b9ec516b6530a98c0a28134e6b0fbb5a9bda
Lang: Go
FileName: main.go
CodeFull:+473
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowInnerXML struct {
	Str string `xml:"s"`
	Raw string `xml:",innerxml"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowInnerXML{
		Str: "<foo></foo>",
		Raw: "<foo></foo>",
	}
	printXML(v)

	// :show end
}
CodeToRun:+405
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowInnerXML struct {
	Str string `xml:"s"`
	Raw string `xml:",innerxml"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowInnerXML{
		Str: "<foo></foo>",
		Raw: "<foo></foo>",
	}
	printXML(v)

}
Output:+77
XML: <ShowInnerXML><s>&lt;foo&gt;&lt;/foo&gt;</s><foo></foo></ShowInnerXML>

66 1553595379533 glotid
Sha1: c101b9ec516b6530a98c0a28134e6b0fbb5a9bda
GlotID: fapbv4a0ls
940 1553595380901 glotoutput
Sha1: 1d775ae3cff281a3a87fdce673b462399e458d1d
Lang: Go
FileName: main.go
CodeFull:+422
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowComment struct {
	Str string `xml:",comment"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowComment{
		Str: "comment",
	}
	printXML(v)

	// :show end
}
CodeToRun:+354
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowComment struct {
	Str string `xml:",comment"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowComment{
		Str: "comment",
	}
	printXML(v)

}
Output:+48
XML: <ShowComment><!--comment--></ShowComment>

66 1553595381069 glotid
Sha1: 1d775ae3cff281a3a87fdce673b462399e458d1d
GlotID: fapbv56xn9
945 1553595382335 glotoutput
Sha1: bc7649f03c191c135309b57714be473bf554a5fe
Lang: Go
FileName: main.go
CodeFull:+418
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowNesting struct {
	Str string `xml:"a>b>str"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowNesting{
		Str: "str",
	}
	printXML(v)

	// :show end
}
CodeToRun:+349
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

type ShowNesting struct {
	Str string `xml:"a>b>str"`
}

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	v := &ShowNesting{
		Str: "str",
	}
	printXML(v)

}
Output:+62
XML: <ShowNesting><a><b><str>str</str></b></a></ShowNesting>

66 1553595382503 glotid
Sha1: bc7649f03c191c135309b57714be473bf554a5fe
GlotID: fapbv61nyd
3319 1553595384183 glotoutput
Sha1: 30589b338c440a8b59cabaf4478b9e7b0a064631
Lang: Go
FileName: main.go
CodeFull:+1556
// :glot
package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	// :show start
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
	// :show end
}

// :show start
type customTime time.Time

const customTimeFormat = `2006-02-01`

func (ct customTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	t := time.Time(ct)
	v := t.Format(customTimeFormat)
	return e.EncodeElement(v, start)
}

func (ct *customTime) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string
	err := d.DecodeElement(&s, &start)
	if err != nil {
		return err
	}
	t, err := time.Parse(customTimeFormat, s)
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

// :show end

func custom() {
	// :show start
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time XML: %s\n", string(d))
	var decoded Event2
	err = xml.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
	// :show end
}

func main() {
	// :show start
	notCustom()
	custom()
	// :show end
}
CodeToRun:+1428
package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
}

type customTime time.Time

const customTimeFormat = `2006-02-01`

func (ct customTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	t := time.Time(ct)
	v := t.Format(customTimeFormat)
	return e.EncodeElement(v, start)
}

func (ct *customTime) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string
	err := d.DecodeElement(&s, &start)
	if err != nil {
		return err
	}
	t, err := time.Parse(customTimeFormat, s)
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

func custom() {
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time XML: %s\n", string(d))
	var decoded Event2
	err = xml.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
}

func main() {
	notCustom()
	custom()
}
Output:+216
Standard time JSON: <Event><What>earthquake</What><When>2019-03-26T10:13:06.685692288Z</When></Event>

Custom time XML: <Event2><What>earthquake</What><When>2019-26-03</When></Event2>
Decoded custom time: 2019-26-03
66 1553595384353 glotid
Sha1: 30589b338c440a8b59cabaf4478b9e7b0a064631
GlotID: fapbv75boa
1304 1553595385755 glotoutput
Sha1: 17dfd2def70d12b2220928799b3b7670aa455e96
Lang: Go
FileName: main.go
CodeFull:+596
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
var tmplStr = `Data from a field: '{{ .Field }}'
Data from a method: '{{ .Method }}'
`

// :show end

type Data struct {
	Field int
}

func (d Data) Method() string {
	return "data from a method"
}

func main() {
	// :show start
	t := template.New("method")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}

	data := Data{
		Field: 5,
	}

	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+528
package main

import (
	"log"
	"os"
	"text/template"
)

var tmplStr = `Data from a field: '{{ .Field }}'
Data from a method: '{{ .Method }}'
`

type Data struct {
	Field int
}

func (d Data) Method() string {
	return "data from a method"
}

func main() {
	t := template.New("method")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}

	data := Data{
		Field: 5,
	}

	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+64
Data from a field: '5'
Data from a method: 'data from a method'
66 1553595385922 glotid
Sha1: 17dfd2def70d12b2220928799b3b7670aa455e96
GlotID: fapbv82yos
1132 1553595387250 glotoutput
Sha1: cbcaf6c49d1a118e9353eac81aad45f6b2b29c46
Lang: Go
FileName: main.go
CodeFull:+519
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `{{range . -}}
{{if .IsNew}}'{{.Name}}' is new{{else}}'{{.Name}}' is not new{{end}}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	data := []struct {
		Name  string
		IsNew bool
	}{
		{"Bridge", false},
		{"Electric battery", true},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+451
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `{{range . -}}
{{if .IsNew}}'{{.Name}}' is new{{else}}'{{.Name}}' is not new{{end}}
{{end}}`

func main() {
	t := template.Must(template.New("if").Parse(tmplStr))

	data := []struct {
		Name  string
		IsNew bool
	}{
		{"Bridge", false},
		{"Electric battery", true},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+46
'Bridge' is not new
'Electric battery' is new
66 1553595387446 glotid
Sha1: cbcaf6c49d1a118e9353eac81aad45f6b2b29c46
GlotID: fapbv8z0r3
2120 1553595388810 glotoutput
Sha1: 75fab909a5a0f01d1e27ddde4f17b3f89d69caae
Lang: Go
FileName: main.go
CodeFull:+876
// :glot
package main

import (
	"log"
	"math"
	"os"
	"text/template"
)

// :show start
const tmplStr = `{{range . -}}
{{printf "%- 16s" .Name}} is: {{if .Value}}true{{else}}false{{end}}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	var nilPtr *string = nil
	var nilSlice []float32
	emptySlice := []int{}

	data := []struct {
		Name  string
		Value interface{}
	}{
		{"bool false", false},
		{"bool true", true},
		{"integer 0", 0},
		{"integer 1", 1},
		{"float32 0", float32(0)},
		{"float64 NaN", math.NaN},
		{"empty string", ""},
		{"non-empty string", "haha"},
		{"nil slice", nilSlice},
		{"empty slice", emptySlice},
		{"non-empty slice", []int{3}},
		{"nil pointer", nilPtr},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+808
package main

import (
	"log"
	"math"
	"os"
	"text/template"
)

const tmplStr = `{{range . -}}
{{printf "%- 16s" .Name}} is: {{if .Value}}true{{else}}false{{end}}
{{end}}`

func main() {
	t := template.Must(template.New("if").Parse(tmplStr))

	var nilPtr *string = nil
	var nilSlice []float32
	emptySlice := []int{}

	data := []struct {
		Name  string
		Value interface{}
	}{
		{"bool false", false},
		{"bool true", true},
		{"integer 0", 0},
		{"integer 1", 1},
		{"float32 0", float32(0)},
		{"float64 NaN", math.NaN},
		{"empty string", ""},
		{"non-empty string", "haha"},
		{"nil slice", nilSlice},
		{"empty slice", emptySlice},
		{"non-empty slice", []int{3}},
		{"nil pointer", nilPtr},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+319
bool false       is: false
bool true        is: true
integer 0        is: false
integer 1        is: true
float32 0        is: false
float64 NaN      is: true
empty string     is: false
non-empty string is: true
nil slice        is: false
empty slice      is: false
non-empty slice  is: true
nil pointer      is: false
66 1553595388978 glotid
Sha1: 75fab909a5a0f01d1e27ddde4f17b3f89d69caae
GlotID: fapbv9wh2g
1690 1553595390467 glotoutput
Sha1: f610daea1b72cc21474b5692e17554f4560e46d1
Lang: Go
FileName: main.go
CodeFull:+783
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
type UserTweets struct {
	User   string
	Tweets []string
}

const tmplStr = `
{{- if not .Tweets -}}
User '{{.User}}' has no tweets.
{{ else -}}
User '{{.User}}' has {{ len .Tweets }} tweets:
{{ range .Tweets -}}
  '{{ . }}'
{{ end }}
{{- end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	data := UserTweets{
		User: "kjk",
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	data = UserTweets{
		User:   "masa",
		Tweets: []string{"tweet one", "tweet two"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
CodeToRun:+715
package main

import (
	"log"
	"os"
	"text/template"
)

type UserTweets struct {
	User   string
	Tweets []string
}

const tmplStr = `
{{- if not .Tweets -}}
User '{{.User}}' has no tweets.
{{ else -}}
User '{{.User}}' has {{ len .Tweets }} tweets:
{{ range .Tweets -}}
  '{{ . }}'
{{ end }}
{{- end}}`

func main() {
	t := template.Must(template.New("if").Parse(tmplStr))

	data := UserTweets{
		User: "kjk",
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	data = UserTweets{
		User:   "masa",
		Tweets: []string{"tweet one", "tweet two"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

}
Output:+76
User 'kjk' has no tweets.
User 'masa' has 2 tweets:
'tweet one'
'tweet two'
66 1553595390637 glotid
Sha1: f610daea1b72cc21474b5692e17554f4560e46d1
GlotID: fapbvaw0m8
1197 1553595392064 glotoutput
Sha1: 3124bf9f78458503d1f91eccdfbc986828d9537a
Lang: Go
FileName: main.go
CodeFull:+540
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of arrays or slice: {{ range . }}{{ . }} {{end}}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	array := [...]int{3, 8}
	err := t.Execute(os.Stdout, array)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	slice := []int{12, 5}
	err = t.Execute(os.Stdout, slice)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+472
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `Elements of arrays or slice: {{ range . }}{{ . }} {{end}}
`

func main() {
	t := template.Must(template.New("range").Parse(tmplStr))

	array := [...]int{3, 8}
	err := t.Execute(os.Stdout, array)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	slice := []int{12, 5}
	err = t.Execute(os.Stdout, slice)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+69
Elements of arrays or slice: 3 8 
Elements of arrays or slice: 12 5 
66 1553595392234 glotid
Sha1: 3124bf9f78458503d1f91eccdfbc986828d9537a
GlotID: fapbvbu89f
970 1553595393805 glotoutput
Sha1: 23f6c769ca354df88d50ab5a8d64085800cd84c1
Lang: Go
FileName: main.go
CodeFull:+445
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of map:
{{ range $k, $v := . }}{{ $k }}: {{ $v }}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	data := map[string]int{
		"one":  1,
		"five": 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+377
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `Elements of map:
{{ range $k, $v := . }}{{ $k }}: {{ $v }}
{{end}}`

func main() {
	t := template.Must(template.New("range").Parse(tmplStr))

	data := map[string]int{
		"one":  1,
		"five": 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+32
Elements of map:
five: 5
one: 1
66 1553595393976 glotid
Sha1: 23f6c769ca354df88d50ab5a8d64085800cd84c1
GlotID: fapbvcvkwp
1016 1553595396628 glotoutput
Sha1: de90acc7ed7b2f1a94275a8d228943159450b4b6
Lang: Go
FileName: main.go
CodeFull:+469
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of a channel: {{ range . }}{{ . }} {{end}}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	ch := make(chan int)
	go func() {
		for i := 0; i < 3; i++ {
			ch <- i
		}
		close(ch)
	}()
	err := t.Execute(os.Stdout, ch)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+401
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `Elements of a channel: {{ range . }}{{ . }} {{end}}
`

func main() {
	t := template.Must(template.New("range").Parse(tmplStr))

	ch := make(chan int)
	go func() {
		for i := 0; i < 3; i++ {
			ch <- i
		}
		close(ch)
	}()
	err := t.Execute(os.Stdout, ch)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+30
Elements of a channel: 0 1 2 
66 1553595398765 glotid
Sha1: de90acc7ed7b2f1a94275a8d228943159450b4b6
GlotID: fapbvfq816
1253 1553595400050 glotoutput
Sha1: 50aadce3f65fb0b72dee3455c30bd278f93dab05
Lang: Go
FileName: main.go
CodeFull:+587
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

type Data struct {
	True  bool
	False bool
}

// :show start
const tmplStr = `Or:  {{ if or .True .False }}true{{ else }}false{{ end }}
And: {{ if and .True .False }}true{{ else }}false{{ end }}
Not: {{ if not .False }}true{{ else }}false{{ end }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("and_or_not").Parse(tmplStr))

	data := Data{True: true, False: false}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+519
package main

import (
	"log"
	"os"
	"text/template"
)

type Data struct {
	True  bool
	False bool
}

const tmplStr = `Or:  {{ if or .True .False }}true{{ else }}false{{ end }}
And: {{ if and .True .False }}true{{ else }}false{{ end }}
Not: {{ if not .False }}true{{ else }}false{{ end }}
`

func main() {
	t := template.Must(template.New("and_or_not").Parse(tmplStr))

	data := Data{True: true, False: false}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+31
Or:  true
And: false
Not: true
66 1553595400226 glotid
Sha1: 50aadce3f65fb0b72dee3455c30bd278f93dab05
GlotID: fapbvglkc7
1435 1553595401451 glotoutput
Sha1: c98c7912930951e4ff0e06617e3a67e2967aaeda
Lang: Go
FileName: main.go
CodeFull:+668
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Slice[0]: {{ index .Slice 0 }}
SliceNested[1][0]: {{ index .SliceNested 1 0 }}
Map["key"]: {{ index .Map "key" }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("index").Parse(tmplStr))

	data := struct {
		Slice       []string
		SliceNested [][]int
		Map         map[string]int
	}{
		Slice: []string{"first", "second"},
		SliceNested: [][]int{
			{3, 1},
			{2, 3},
		},
		Map: map[string]int{
			"key": 5,
		},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+600
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `Slice[0]: {{ index .Slice 0 }}
SliceNested[1][0]: {{ index .SliceNested 1 0 }}
Map["key"]: {{ index .Map "key" }}
`

func main() {
	t := template.Must(template.New("index").Parse(tmplStr))

	data := struct {
		Slice       []string
		SliceNested [][]int
		Map         map[string]int
	}{
		Slice: []string{"first", "second"},
		SliceNested: [][]int{
			{3, 1},
			{2, 3},
		},
		Map: map[string]int{
			"key": 5,
		},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+51
Slice[0]: first
SliceNested[1][0]: 2
Map["key"]: 5
66 1553595401629 glotid
Sha1: c98c7912930951e4ff0e06617e3a67e2967aaeda
GlotID: fapbvhflww
1544 1553595403122 glotoutput
Sha1: affeb81bafbb767c8e0e96ebccc9f6f07265d5ff
Lang: Go
FileName: main.go
CodeFull:+710
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `len(nil)       : {{ len .SliceNil }}
len(emptySlice): {{ len .SliceEmpty }}
len(slice)     : {{ len .Slice }}
len(map)       : {{ len .Map }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("len").Parse(tmplStr))

	data := struct {
		SliceNil   []int
		SliceEmpty []string
		Slice      []bool
		Map        map[int]bool
	}{
		SliceNil:   nil,
		SliceEmpty: []string{},
		Slice:      []bool{true, true, false},
		Map:        map[int]bool{5: true, 3: false},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+642
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `len(nil)       : {{ len .SliceNil }}
len(emptySlice): {{ len .SliceEmpty }}
len(slice)     : {{ len .Slice }}
len(map)       : {{ len .Map }}
`

func main() {
	t := template.Must(template.New("len").Parse(tmplStr))

	data := struct {
		SliceNil   []int
		SliceEmpty []string
		Slice      []bool
		Map        map[int]bool
	}{
		SliceNil:   nil,
		SliceEmpty: []string{},
		Slice:      []bool{true, true, false},
		Map:        map[int]bool{5: true, 3: false},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+76
len(nil)       : 0
len(emptySlice): 0
len(slice)     : 3
len(map)       : 2
66 1553595403299 glotid
Sha1: affeb81bafbb767c8e0e96ebccc9f6f07265d5ff
GlotID: fapbvifee6
1119 1553595404786 glotoutput
Sha1: caecf846a2ee15a7f4fee1e9439e38f8bfd6778f
Lang: Go
FileName: main.go
CodeFull:+510
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `print:   {{ print .Str .Num }}
println: {{ println .Str .Num }}
printf:  {{ printf "%s %#v %d" .Str .Str .Num }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		Str string
		Num int
	}{
		Str: "str",
		Num: 8,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+442
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `print:   {{ print .Str .Num }}
println: {{ println .Str .Num }}
printf:  {{ printf "%s %#v %d" .Str .Str .Num }}
`

func main() {
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		Str string
		Num int
	}{
		Str: "str",
		Num: 8,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+51
print:   str8
println: str 8

printf:  str "str" 8
66 1553595404960 glotid
Sha1: caecf846a2ee15a7f4fee1e9439e38f8bfd6778f
GlotID: fapbvjf0o5
1379 1553595406330 glotoutput
Sha1: 71c28604383214ad6210cbf03f1b5636803abacd
Lang: Go
FileName: main.go
CodeFull:+595
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `js escape  : {{ js .JS }}
html escape: {{ html .HTML }}
url escape : {{ urlquery .URL }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `function me(s) { return "foo"; }`,
		HTML: `<div>text</div>`,
		URL:  `http://www.programming-books.io`,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+527
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `js escape  : {{ js .JS }}
html escape: {{ html .HTML }}
url escape : {{ urlquery .URL }}
`

func main() {
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `function me(s) { return "foo"; }`,
		HTML: `<div>text</div>`,
		URL:  `http://www.programming-books.io`,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+140
js escape  : function me(s) { return \"foo\"; }
html escape: &lt;div&gt;text&lt;/div&gt;
url escape : http%3A%2F%2Fwww.programming-books.io
66 1553595406508 glotid
Sha1: 71c28604383214ad6210cbf03f1b5636803abacd
GlotID: fapbvkc67g
1089 1553595407833 glotoutput
Sha1: 6956a6584537fe4aa7e3f1a230a112cfe3c2ea01
Lang: Go
FileName: main.go
CodeFull:+515
// :glot
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `5 + 5 = {{ sum 5 .Arg }}
`

// :show end

func sum(x, y int) int {
	return x + y
}

func main() {
	// :show start
	customFunctions := template.FuncMap{
		"sum": sum,
	}

	t := template.Must(template.New("func").Funcs(customFunctions).Parse(tmplStr))

	data := struct {
		Arg int
	}{
		Arg: 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
CodeToRun:+447
package main

import (
	"log"
	"os"
	"text/template"
)

const tmplStr = `5 + 5 = {{ sum 5 .Arg }}
`

func sum(x, y int) int {
	return x + y
}

func main() {
	customFunctions := template.FuncMap{
		"sum": sum,
	}

	t := template.Must(template.New("func").Funcs(customFunctions).Parse(tmplStr))

	data := struct {
		Arg int
	}{
		Arg: 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
}
Output:+11
5 + 5 = 10
66 1553595408008 glotid
Sha1: 6956a6584537fe4aa7e3f1a230a112cfe3c2ea01
GlotID: fapbvl8cuc
1726 1553595409580 glotoutput
Sha1: 02d3c832b8e50661be2a9ae9370a8f9898ac36df
Lang: Go
FileName: main.go
CodeFull:+785
// :glot
package main

import (
	"fmt"
	html_template "html/template"
	"log"
	"os"
	text_template "text/template"
)

// :show start
const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

// :show end

func main() {
	// :show start
	txt := text_template.Must(text_template.New("text").Parse(tmplStr))

	html := html_template.Must(html_template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
		URL:  `http://www.programming-books.io`,
	}

	err := txt.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Println()

	err = html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
CodeToRun:+717
package main

import (
	"fmt"
	html_template "html/template"
	"log"
	"os"
	text_template "text/template"
)

const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

func main() {
	txt := text_template.Must(text_template.New("text").Parse(tmplStr))

	html := html_template.Must(html_template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
		URL:  `http://www.programming-books.io`,
	}

	err := txt.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Println()

	err = html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

}
Output:+107
<div onlick="foo"><span>text</span></div>

<div onlick="&#34;foo&#34;">&lt;span&gt;text&lt;/span&gt;</div>
66 1553595409758 glotid
Sha1: 02d3c832b8e50661be2a9ae9370a8f9898ac36df
GlotID: fapbvm9tr7
1688 1553595411034 glotoutput
Sha1: 1870fded55bde6e915b183ddc9ec332d4b1cb384
Lang: Go
FileName: main.go
CodeFull:+756
// :glot
package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
)

// :show start
const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

// :show end

func main() {
	// :show start

	html := template.Must(template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}

	fmt.Printf("Escaped:\n")
	err := html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Printf("\nUnescaped:\n")
	data2 := struct {
		JS   template.JS
		HTML template.HTML
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}
	err = html.Execute(os.Stdout, data2)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
CodeToRun:+688
package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
)

const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

func main() {

	html := template.Must(template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}

	fmt.Printf("Escaped:\n")
	err := html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Printf("\nUnescaped:\n")
	data2 := struct {
		JS   template.JS
		HTML template.HTML
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}
	err = html.Execute(os.Stdout, data2)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

}
Output:+127
Escaped:
<div onlick="&#34;foo&#34;">&lt;span&gt;text&lt;/span&gt;</div>

Unescaped:
<div onlick="foo"><span>text</span></div>
66 1553595411211 glotid
Sha1: 1870fded55bde6e915b183ddc9ec332d4b1cb384
GlotID: fapbvn4zv9
1442 1553595412554 glotoutput
Sha1: f3e9bca6dc3d47b0af5dc615346a3d8414b4c844
Lang: Go
FileName: main.go
CodeFull:+641
// :glot
package main

import (
	"fmt"
	"reflect"
)

// :show start

func printType(v interface{}) {
	rv := reflect.ValueOf(v)
	typ := rv.Type()
	typeName := ""
	switch rv.Kind() {
	case reflect.Ptr:
		typeName = "pointer"
	case reflect.Int:
		typeName = "int"
	case reflect.Int32:
		typeName = "int32"
	case reflect.String:
		typeName = "string"
	// ... handle more cases
	default:
		typeName = "unrecognized type"
	}
	fmt.Printf("v is of type '%s'. Size: %d bytes\n", typeName, typ.Size())
}

// :show end

func main() {
	// :show start
	printType(int32(3))
	printType("")
	i := 3
	printType(&i) // *int i.e. pointer to int
	// :show end
}
CodeToRun:+572
package main

import (
	"fmt"
	"reflect"
)

func printType(v interface{}) {
	rv := reflect.ValueOf(v)
	typ := rv.Type()
	typeName := ""
	switch rv.Kind() {
	case reflect.Ptr:
		typeName = "pointer"
	case reflect.Int:
		typeName = "int"
	case reflect.Int32:
		typeName = "int32"
	case reflect.String:
		typeName = "string"
	// ... handle more cases
	default:
		typeName = "unrecognized type"
	}
	fmt.Printf("v is of type '%s'. Size: %d bytes\n", typeName, typ.Size())
}

func main() {
	printType(int32(3))
	printType("")
	i := 3
	printType(&i) // *int i.e. pointer to int
}
Output:+112
v is of type 'int32'. Size: 4 bytes
v is of type 'string'. Size: 16 bytes
v is of type 'pointer'. Size: 8 bytes
66 1553595412731 glotid
Sha1: f3e9bca6dc3d47b0af5dc615346a3d8414b4c844
GlotID: fapbvo1knl
1049 1553595414080 glotoutput
Sha1: a7dd57167861847b194fd31c282041d9a0dc1bf7
Lang: Go
FileName: main.go
CodeFull:+336
// :glot
// allow error
package main

import (
	"fmt"
	"reflect"
)

// :show start

func getIntValue(v interface{}) {
	var reflectValue = reflect.ValueOf(v)
	n := reflectValue.Int()
	fmt.Printf("Int value is: %d\n", n)
}

// :show end

func main() {
	// :show start
	getIntValue(3)
	getIntValue(int8(4))
	getIntValue("")
	// :show end
}
CodeToRun:+252
package main

import (
	"fmt"
	"reflect"
)

func getIntValue(v interface{}) {
	var reflectValue = reflect.ValueOf(v)
	n := reflectValue.Int()
	fmt.Printf("Int value is: %d\n", n)
}

func main() {
	getIntValue(3)
	getIntValue(int8(4))
	getIntValue("")
}
Output:+344
Int value is: 3
Int value is: 4
panic: reflect: call of reflect.Value.Int on string Value

goroutine 1 [running]:
reflect.Value.Int(0x493920, 0x4c4420, 0x98, 0x4c4420)
	/usr/local/go/src/reflect/value.go:931 +0x127
main.getIntValue(0x493920, 0x4c4420)
	/tmp/649864871/main.go:10 +0x5b
main.main()
	/tmp/649864871/main.go:17 +0x7b
exit status 2
66 1553595414257 glotid
Sha1: a7dd57167861847b194fd31c282041d9a0dc1bf7
GlotID: fapbvoya1l
2661 1553595415618 glotoutput
Sha1: ca7f537bfe06a5b7bb245873c7087c3a1ca8e530
Lang: Go
FileName: main.go
CodeFull:+1134
// :glot
package main

import (
	"fmt"
	"reflect"
)

// :show start
type S struct {
	N int
}

func setIntPtr() {
	var n int = 2
	reflect.ValueOf(&n).Elem().SetInt(4)
	fmt.Printf("setIntPtr: n=%d\n", n)
}

func setStructFieldDirect() {
	var s S
	reflect.ValueOf(&s.N).Elem().SetInt(5)
	fmt.Printf("setStructFieldDirect: n=%d\n", s.N)
}

func setStructPtrField() {
	var s S
	reflect.ValueOf(&s).Elem().Field(0).SetInt(6)
	fmt.Printf("setStructPtrField: s.N: %d\n", s.N)
}

func handlePanic(funcName string) {
	if msg := recover(); msg != nil {
		fmt.Printf("%s panicked with '%s'\n", funcName, msg)
	}
}

func setStructField() {
	defer handlePanic("setStructField")
	var s S
	reflect.ValueOf(s).Elem().Field(0).SetInt(4)
	fmt.Printf("s.N: %d\n", s.N)
}

func setInt() {
	defer handlePanic("setInt")
	var n int = 2
	rv := reflect.ValueOf(n)
	rv.Elem().SetInt(4)
}

func setIntPtrWithString() {
	defer handlePanic("setIntPtrWithString")
	var n int = 2
	reflect.ValueOf(&n).Elem().SetString("8")
}

// :show end

func main() {
	setIntPtr()
	setStructFieldDirect()
	setStructPtrField()

	setInt()
	setStructField()

	setIntPtrWithString()
}
CodeToRun:+1096
package main

import (
	"fmt"
	"reflect"
)

type S struct {
	N int
}

func setIntPtr() {
	var n int = 2
	reflect.ValueOf(&n).Elem().SetInt(4)
	fmt.Printf("setIntPtr: n=%d\n", n)
}

func setStructFieldDirect() {
	var s S
	reflect.ValueOf(&s.N).Elem().SetInt(5)
	fmt.Printf("setStructFieldDirect: n=%d\n", s.N)
}

func setStructPtrField() {
	var s S
	reflect.ValueOf(&s).Elem().Field(0).SetInt(6)
	fmt.Printf("setStructPtrField: s.N: %d\n", s.N)
}

func handlePanic(funcName string) {
	if msg := recover(); msg != nil {
		fmt.Printf("%s panicked with '%s'\n", funcName, msg)
	}
}

func setStructField() {
	defer handlePanic("setStructField")
	var s S
	reflect.ValueOf(s).Elem().Field(0).SetInt(4)
	fmt.Printf("s.N: %d\n", s.N)
}

func setInt() {
	defer handlePanic("setInt")
	var n int = 2
	rv := reflect.ValueOf(n)
	rv.Elem().SetInt(4)
}

func setIntPtrWithString() {
	defer handlePanic("setIntPtrWithString")
	var n int = 2
	reflect.ValueOf(&n).Elem().SetString("8")
}

func main() {
	setIntPtr()
	setStructFieldDirect()
	setStructPtrField()

	setInt()
	setStructField()

	setIntPtrWithString()
}
Output:+312
setIntPtr: n=4
setStructFieldDirect: n=5
setStructPtrField: s.N: 6
setInt panicked with 'reflect: call of reflect.Value.Elem on int Value'
setStructField panicked with 'reflect: call of reflect.Value.Elem on struct Value'
setIntPtrWithString panicked with 'reflect: call of reflect.Value.SetString on int Value'
66 1553595415794 glotid
Sha1: ca7f537bfe06a5b7bb245873c7087c3a1ca8e530
GlotID: fapbvpv7qe
1286 1553595417527 glotoutput
Sha1: ea911c21a8df4fbd0898eff1f21c04e29f97963a
Lang: Go
FileName: main.go
CodeFull:+533
// :glot
package main

import (
	"fmt"
	"reflect"
)

// :show start
func printIntResolvingPointers(v interface{}) {
	rv := reflect.ValueOf(v)
	typeName := rv.Type().String()
	name := ""
	for rv.Kind() == reflect.Ptr {
		name = "pointer to " + name
		rv = rv.Elem()
	}
	name += rv.Type().String()
	fmt.Printf("Value: %d. Type: '%s' i.e. '%s'.\n\n", rv.Int(), name, typeName)
}

func main() {
	n := 3
	printIntResolvingPointers(n)

	n = 4
	printIntResolvingPointers(&n)

	n = 5
	np := &n
	printIntResolvingPointers(&np)
}

// :show end
CodeToRun:+496
package main

import (
	"fmt"
	"reflect"
)

func printIntResolvingPointers(v interface{}) {
	rv := reflect.ValueOf(v)
	typeName := rv.Type().String()
	name := ""
	for rv.Kind() == reflect.Ptr {
		name = "pointer to " + name
		rv = rv.Elem()
	}
	name += rv.Type().String()
	fmt.Printf("Value: %d. Type: '%s' i.e. '%s'.\n\n", rv.Int(), name, typeName)
}

func main() {
	n := 3
	printIntResolvingPointers(n)

	n = 4
	printIntResolvingPointers(&n)

	n = 5
	np := &n
	printIntResolvingPointers(&np)
}
Output:+141
Value: 3. Type: 'int' i.e. 'int'.

Value: 4. Type: 'pointer to int' i.e. '*int'.

Value: 5. Type: 'pointer to pointer to int' i.e. '**int'.

66 1553595417704 glotid
Sha1: ea911c21a8df4fbd0898eff1f21c04e29f97963a
GlotID: fapbvr04su
2093 1553595419044 glotoutput
Sha1: 84c131ee3b20b7716ef3355edfa402366168a054
Lang: Go
FileName: main.go
CodeFull:+893
// :glot
package main

import (
	"fmt"
	"reflect"
)

// :show start

type S struct {
	FirstName string `my_tag:"first-name"`
	lastName  string
	Age       int `json:"age",xml:"AgeXml`
}

func describeStructSimple(rv reflect.Value) {
	structType := rv.Type()
	for i := 0; i < rv.NumField(); i++ {
		v := rv.Field(i)
		structField := structType.Field(i)
		name := structField.Name
		typ := structField.Type
		tag := structField.Tag
		jsonTag := tag.Get("json")
		isExported := structField.PkgPath == ""
		if isExported {
			fmt.Printf("name: '%s',\ttype: '%s', value: %v,\ttag: '%s',\tjson tag: '%s'\n", name, typ, v.Interface(), tag, jsonTag)
		} else {
			fmt.Printf("name: '%s',\ttype: '%s',\tvalue: not accessible\n", name, v.Type().Name())
		}
	}
}

func main() {
	s := S{
		FirstName: "John",
		lastName:  "Doe",
		Age:       27,
	}
	describeStructSimple(reflect.ValueOf(s))
}

// :show end
CodeToRun:+855
package main

import (
	"fmt"
	"reflect"
)

type S struct {
	FirstName string `my_tag:"first-name"`
	lastName  string
	Age       int `json:"age",xml:"AgeXml`
}

func describeStructSimple(rv reflect.Value) {
	structType := rv.Type()
	for i := 0; i < rv.NumField(); i++ {
		v := rv.Field(i)
		structField := structType.Field(i)
		name := structField.Name
		typ := structField.Type
		tag := structField.Tag
		jsonTag := tag.Get("json")
		isExported := structField.PkgPath == ""
		if isExported {
			fmt.Printf("name: '%s',\ttype: '%s', value: %v,\ttag: '%s',\tjson tag: '%s'\n", name, typ, v.Interface(), tag, jsonTag)
		} else {
			fmt.Printf("name: '%s',\ttype: '%s',\tvalue: not accessible\n", name, v.Type().Name())
		}
	}
}

func main() {
	s := S{
		FirstName: "John",
		lastName:  "Doe",
		Age:       27,
	}
	describeStructSimple(reflect.ValueOf(s))
}
Output:+229
name: 'FirstName',	type: 'string', value: John,	tag: 'my_tag:"first-name"',	json tag: ''
name: 'lastName',	type: 'string',	value: not accessible
name: 'Age',	type: 'int', value: 27,	tag: 'json:"age",xml:"AgeXml',	json tag: 'age'
66 1553595419222 glotid
Sha1: 84c131ee3b20b7716ef3355edfa402366168a054
GlotID: fapbvrwo3q
3966 1553595420559 glotoutput
Sha1: 7d6a992f36a99f6492f1706b4940635a20fbf02d
Lang: Go
FileName: main.go
CodeFull:+1703
// :glot
package main

import (
	"fmt"
	"reflect"
	"strings"
)

// :show start
type Inner struct {
	N int
}

type S struct {
	Inner
	NamedInner Inner
	PtrInner   *Inner
	unexported int
	N          int8
}

func indentStr(level int) string {
	return strings.Repeat("  ", level)
}

// if sf is not nil, this is a field of a struct
func describeStruct(level int, rv reflect.Value, sf *reflect.StructField) {
	structType := rv.Type()
	nFields := rv.NumField()
	typ := rv.Type()
	if sf == nil {
		fmt.Printf("%sstruct %s, %d field(s), size: %d bytes\n", indentStr(level), structType.Name(), nFields, typ.Size())
	} else {
		fmt.Printf("%sname: '%s' type: 'struct %s', offset: %d, %d field(s), size: %d bytes, embedded: %v\n", indentStr(level), sf.Name, structType.Name(), sf.Offset, nFields, typ.Size(), sf.Anonymous)
	}

	for i := 0; i < nFields; i++ {
		fv := rv.Field(i)
		sf := structType.Field(i)
		describeType(level+1, fv, &sf)
	}
}

// if sf is not nil, this is a field of a struct
func describeType(level int, rv reflect.Value, sf *reflect.StructField) {
	switch rv.Kind() {

	case reflect.Int, reflect.Int8:
		// in real code we would handle more primitive types
		i := rv.Int()
		typ := rv.Type()
		if sf == nil {
			fmt.Printf("%stype: '%s', value: '%d'\n", indentStr(level), typ.Name(), i)
		} else {
			fmt.Printf("%s name: '%s' type: '%s', value: '%d', offset: %d, size: %d\n", indentStr(level), sf.Name, typ.Name(), i, sf.Offset, typ.Size())
		}

	case reflect.Ptr:
		fmt.Printf("%spointer\n", indentStr(level))
		describeType(level+1, rv.Elem(), nil)

	case reflect.Struct:
		describeStruct(level, rv, sf)
	}
}

func main() {
	var s S
	describeType(0, reflect.ValueOf(s), nil)
}

// :show end
CodeToRun:+1666
package main

import (
	"fmt"
	"reflect"
	"strings"
)

type Inner struct {
	N int
}

type S struct {
	Inner
	NamedInner Inner
	PtrInner   *Inner
	unexported int
	N          int8
}

func indentStr(level int) string {
	return strings.Repeat("  ", level)
}

// if sf is not nil, this is a field of a struct
func describeStruct(level int, rv reflect.Value, sf *reflect.StructField) {
	structType := rv.Type()
	nFields := rv.NumField()
	typ := rv.Type()
	if sf == nil {
		fmt.Printf("%sstruct %s, %d field(s), size: %d bytes\n", indentStr(level), structType.Name(), nFields, typ.Size())
	} else {
		fmt.Printf("%sname: '%s' type: 'struct %s', offset: %d, %d field(s), size: %d bytes, embedded: %v\n", indentStr(level), sf.Name, structType.Name(), sf.Offset, nFields, typ.Size(), sf.Anonymous)
	}

	for i := 0; i < nFields; i++ {
		fv := rv.Field(i)
		sf := structType.Field(i)
		describeType(level+1, fv, &sf)
	}
}

// if sf is not nil, this is a field of a struct
func describeType(level int, rv reflect.Value, sf *reflect.StructField) {
	switch rv.Kind() {

	case reflect.Int, reflect.Int8:
		// in real code we would handle more primitive types
		i := rv.Int()
		typ := rv.Type()
		if sf == nil {
			fmt.Printf("%stype: '%s', value: '%d'\n", indentStr(level), typ.Name(), i)
		} else {
			fmt.Printf("%s name: '%s' type: '%s', value: '%d', offset: %d, size: %d\n", indentStr(level), sf.Name, typ.Name(), i, sf.Offset, typ.Size())
		}

	case reflect.Ptr:
		fmt.Printf("%spointer\n", indentStr(level))
		describeType(level+1, rv.Elem(), nil)

	case reflect.Struct:
		describeStruct(level, rv, sf)
	}
}

func main() {
	var s S
	describeType(0, reflect.ValueOf(s), nil)
}
Output:+479
struct S, 5 field(s), size: 40 bytes
  name: 'Inner' type: 'struct Inner', offset: 0, 1 field(s), size: 8 bytes, embedded: true
     name: 'N' type: 'int', value: '0', offset: 0, size: 8
  name: 'NamedInner' type: 'struct Inner', offset: 8, 1 field(s), size: 8 bytes, embedded: false
     name: 'N' type: 'int', value: '0', offset: 0, size: 8
  pointer
   name: 'unexported' type: 'int', value: '0', offset: 24, size: 8
   name: 'N' type: 'int8', value: '0', offset: 32, size: 1
66 1553595420737 glotid
Sha1: 7d6a992f36a99f6492f1706b4940635a20fbf02d
GlotID: fapbvst4my
1350 1553595421849 glotoutput
Sha1: f9f43b0ed790c12e0a01c691d2675228bea8e2c8
Lang: Go
FileName: main.go
CodeFull:+575
// :glot
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	a := []int{3, 1, 8}
	rv := reflect.ValueOf(a)

	fmt.Printf("len(a): %d\n", rv.Len())
	fmt.Printf("cap(a): %d\n", rv.Cap())

	fmt.Printf("slice kind: '%s'\n", rv.Kind().String())

	fmt.Printf("element type: '%s'\n", rv.Type().Elem().Name())

	el := rv.Index(0).Interface()
	fmt.Printf("a[0]: %v\n", el)

	elRef := rv.Index(1)
	fmt.Printf("elRef.CanAddr(): %v\n", elRef.CanAddr())
	fmt.Printf("elRef.CanSet(): %v\n", elRef.CanSet())

	elRef.SetInt(5)
	fmt.Printf("a: %v\n", a)

	// :show end
}
CodeToRun:+536
package main

import (
	"fmt"
	"reflect"
)

func main() {
	a := []int{3, 1, 8}
	rv := reflect.ValueOf(a)

	fmt.Printf("len(a): %d\n", rv.Len())
	fmt.Printf("cap(a): %d\n", rv.Cap())

	fmt.Printf("slice kind: '%s'\n", rv.Kind().String())

	fmt.Printf("element type: '%s'\n", rv.Type().Elem().Name())

	el := rv.Index(0).Interface()
	fmt.Printf("a[0]: %v\n", el)

	elRef := rv.Index(1)
	fmt.Printf("elRef.CanAddr(): %v\n", elRef.CanAddr())
	fmt.Printf("elRef.CanSet(): %v\n", elRef.CanSet())

	elRef.SetInt(5)
	fmt.Printf("a: %v\n", a)

}
Output:+122
len(a): 3
cap(a): 3
slice kind: 'slice'
element type: 'int'
a[0]: 3
elRef.CanAddr(): true
elRef.CanSet(): true
a: [3 5 8]
66 1553595422027 glotid
Sha1: f9f43b0ed790c12e0a01c691d2675228bea8e2c8
GlotID: fapbvtkrsr
742 1553595423297 glotoutput
Sha1: a2a0a6e0e52b77c5b10284f57a8d816e1e766224
Lang: Go
FileName: main.go
CodeFull:+323
// :glot
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	typ := reflect.SliceOf(reflect.TypeOf("example"))
	// create slice with capacity 10 and length 1
	rv := reflect.MakeSlice(typ, 1, 10)
	rv.Index(0).SetString("foo")

	a := rv.Interface().([]string)
	fmt.Printf("a: %#v\n", a)
	// :show end
}
CodeToRun:+284
package main

import (
	"fmt"
	"reflect"
)

func main() {
	typ := reflect.SliceOf(reflect.TypeOf("example"))
	// create slice with capacity 10 and length 1
	rv := reflect.MakeSlice(typ, 1, 10)
	rv.Index(0).SetString("foo")

	a := rv.Interface().([]string)
	fmt.Printf("a: %#v\n", a)
}
Output:+19
a: []string{"foo"}
66 1553595423485 glotid
Sha1: a2a0a6e0e52b77c5b10284f57a8d816e1e766224
GlotID: fapbvufst6
1832 1553595425038 glotoutput
Sha1: cab832773f4fb002099f24af8fd56c1fc001dab8
Lang: Go
FileName: main.go
CodeFull:+853
// :glot
package main

import (
	"context"
	"fmt"
)

// :show start
type User struct {
	Name       string
	IsLoggedIn bool
}

type userKeyType int

var userKey userKeyType

func contextWithUser(ctx context.Context, user *User) context.Context {
	return context.WithValue(ctx, userKey, user)
}

// returns nil if not set
func getUserFromContext(ctx context.Context) *User {
	user, ok := ctx.Value(userKey).(*User)
	if !ok {
		return nil
	}
	return user
}

// will panic if not set
func mustGetUserFromContext(ctx context.Context) *User {
	return ctx.Value(userKey).(*User)
}

func printUser(ctx context.Context) {
	user := getUserFromContext(ctx)
	fmt.Printf("User: %#v\n", user)
}

func main() {
	ctx := context.Background()
	user := &User{
		Name:       "John",
		IsLoggedIn: false,
	}
	ctx = contextWithUser(ctx, user)

	printUser(ctx)
}

// :show end
CodeToRun:+816
package main

import (
	"context"
	"fmt"
)

type User struct {
	Name       string
	IsLoggedIn bool
}

type userKeyType int

var userKey userKeyType

func contextWithUser(ctx context.Context, user *User) context.Context {
	return context.WithValue(ctx, userKey, user)
}

// returns nil if not set
func getUserFromContext(ctx context.Context) *User {
	user, ok := ctx.Value(userKey).(*User)
	if !ok {
		return nil
	}
	return user
}

// will panic if not set
func mustGetUserFromContext(ctx context.Context) *User {
	return ctx.Value(userKey).(*User)
}

func printUser(ctx context.Context) {
	user := getUserFromContext(ctx)
	fmt.Printf("User: %#v\n", user)
}

func main() {
	ctx := context.Background()
	user := &User{
		Name:       "John",
		IsLoggedIn: false,
	}
	ctx = contextWithUser(ctx, user)

	printUser(ctx)
}
Output:+48
User: &main.User{Name:"John", IsLoggedIn:false}
66 1553595425217 glotid
Sha1: cab832773f4fb002099f24af8fd56c1fc001dab8
GlotID: fapbvvh58e
1739 1553595426574 glotoutput
Sha1: 1951017a94fda2fcf405e0c28732dfc7813f8f94
Lang: Go
FileName: main.go
CodeFull:+760
// :glot
package main

import (
	"context"
	"fmt"
	"time"
)

// :show start
func longMathOp(ctx context.Context, n int) (int, error) {
	res := n
	for i := 0; i < 100; i++ {
		select {
		case <-ctx.Done():
			return 0, ctx.Err()
		default:
			res += i
			// simulate long operation by sleeping
			time.Sleep(time.Millisecond)
		}
	}
	return res, nil
}

func main() {
	ctx, _ := context.WithTimeout(context.Background(), time.Millisecond*200)
	res, err := longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 200ms timeout. res; %d, err: %v\n", res, err)

	ctx, _ = context.WithTimeout(context.Background(), time.Millisecond*10)
	res, err = longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 10ms timeout. res: %d, err: %v\n", res, err)
}

// :show end
CodeToRun:+723
package main

import (
	"context"
	"fmt"
	"time"
)

func longMathOp(ctx context.Context, n int) (int, error) {
	res := n
	for i := 0; i < 100; i++ {
		select {
		case <-ctx.Done():
			return 0, ctx.Err()
		default:
			res += i
			// simulate long operation by sleeping
			time.Sleep(time.Millisecond)
		}
	}
	return res, nil
}

func main() {
	ctx, _ := context.WithTimeout(context.Background(), time.Millisecond*200)
	res, err := longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 200ms timeout. res; %d, err: %v\n", res, err)

	ctx, _ = context.WithTimeout(context.Background(), time.Millisecond*10)
	res, err = longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 10ms timeout. res: %d, err: %v\n", res, err)
}
Output:+140
Called longMathOp() with 200ms timeout. res; 4955, err: <nil>
Called longMathOp() with 10ms timeout. res: 0, err: context deadline exceeded
66 1553595426792 glotid
Sha1: 1951017a94fda2fcf405e0c28732dfc7813f8f94
GlotID: fapbvwevrq
1364 1553595428109 glotoutput
Sha1: 4165c6d7d92f9116b6745daa8cd6757680ff56af
Lang: Go
FileName: main.go
CodeFull:+613
// :glot
package main

import (
	"fmt"
)

type Runner interface {
	Run()
}

type Admin struct {
	Username, Password string
}

func (admin Admin) Run() {
	fmt.Println("Admin ==> Run()")
}

type User struct {
	ID              uint64
	FullName, Email string
}

func (user User) Run() {
	fmt.Println("User ==> Run()")
}

// RunnerExample takes any type that fullfils the Runner interface
func RunnerExample(r Runner) {
	r.Run()
}

func main() {
	admin := Admin{
		"zola",
		"supersecretpassword",
	}

	user := User{
		1,
		"Zelalem Mekonen",
		"zola.mk.27@gmail.com",
	}

	RunnerExample(admin)

	RunnerExample(user)
}
CodeToRun:+604
package main

import (
	"fmt"
)

type Runner interface {
	Run()
}

type Admin struct {
	Username, Password string
}

func (admin Admin) Run() {
	fmt.Println("Admin ==> Run()")
}

type User struct {
	ID              uint64
	FullName, Email string
}

func (user User) Run() {
	fmt.Println("User ==> Run()")
}

// RunnerExample takes any type that fullfils the Runner interface
func RunnerExample(r Runner) {
	r.Run()
}

func main() {
	admin := Admin{
		"zola",
		"supersecretpassword",
	}

	user := User{
		1,
		"Zelalem Mekonen",
		"zola.mk.27@gmail.com",
	}

	RunnerExample(admin)

	RunnerExample(user)
}
Output:+31
Admin ==> Run()
User ==> Run()
66 1553595428299 glotid
Sha1: 4165c6d7d92f9116b6745daa8cd6757680ff56af
GlotID: fapbvxb8d6
